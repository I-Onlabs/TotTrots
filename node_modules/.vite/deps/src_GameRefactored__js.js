import {
  EventBus,
  Logger
} from "./chunk-DH7WYVGW.js";

// src/managers/GameManager.js
var GameManager = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("GameManager requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("GameManager requires logger dependency");
    }
    this.state = {
      currentLevel: 1,
      maxLevel: 10,
      score: 0,
      highScore: 0,
      lives: 3,
      levelStartTime: null,
      levelCompleted: false,
      gameOver: false
    };
    this.levelConfigs = this.initializeLevelConfigs();
    this.setupEventHandlers();
    this.logger.info("GameManager initialized");
  }
  /**
   * Initialize the manager
   */
  async initialize() {
    this.logger.info("Initializing GameManager...");
    await this.loadGameData();
    this.setupLevel(this.state.currentLevel);
    this.logger.info("GameManager initialized successfully");
  }
  /**
   * Cleanup the manager
   */
  cleanup() {
    this.logger.info("Cleaning up GameManager...");
    this.saveGameData();
    this.removeEventHandlers();
    this.logger.info("GameManager cleaned up");
  }
  /**
   * Update the manager
   */
  update(deltaTime, gameState) {
    if (this.state.levelStartTime && !this.state.levelCompleted) {
      const levelTime = Date.now() - this.state.levelStartTime;
      const levelConfig = this.levelConfigs[this.state.currentLevel - 1];
      if (levelConfig.timeLimit && levelTime > levelConfig.timeLimit) {
        this.handleLevelTimeout();
      }
    }
    this.updateLevelSpecificLogic(deltaTime, gameState);
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("player:scoreChanged", this.handleScoreChange.bind(this));
    this.eventBus.on("player:damaged", this.handlePlayerDamaged.bind(this));
    this.eventBus.on(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.on(
      "player:levelCompleted",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.on("game:input", this.handleGameInput.bind(this));
    this.eventBus.on("game:configChanged", this.handleConfigChange.bind(this));
    this.eventBus.on(
      "achievement:unlocked",
      this.handleAchievementUnlock.bind(this)
    );
    this.eventBus.on(
      "dailyChallenge:completed",
      this.handleDailyChallengeCompletion.bind(this)
    );
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.off(
      "player:scoreChanged",
      this.handleScoreChange.bind(this)
    );
    this.eventBus.off(
      "player:damaged",
      this.handlePlayerDamaged.bind(this)
    );
    this.eventBus.off(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.off(
      "player:levelCompleted",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.off("game:input", this.handleGameInput.bind(this));
    this.eventBus.removeListener(
      "game:configChanged",
      this.handleConfigChange.bind(this)
    );
    this.eventBus.removeListener(
      "achievement:unlocked",
      this.handleAchievementUnlock.bind(this)
    );
    this.eventBus.removeListener(
      "dailyChallenge:completed",
      this.handleDailyChallengeCompletion.bind(this)
    );
  }
  /**
   * Initialize level configurations
   */
  initializeLevelConfigs() {
    return [
      { timeLimit: 6e4, targetScore: 1e3, difficulty: "easy" },
      { timeLimit: 9e4, targetScore: 2500, difficulty: "easy" },
      { timeLimit: 12e4, targetScore: 5e3, difficulty: "medium" },
      { timeLimit: 15e4, targetScore: 7500, difficulty: "medium" },
      { timeLimit: 18e4, targetScore: 1e4, difficulty: "hard" },
      { timeLimit: 2e5, targetScore: 15e3, difficulty: "hard" },
      { timeLimit: 22e4, targetScore: 2e4, difficulty: "expert" },
      { timeLimit: 24e4, targetScore: 25e3, difficulty: "expert" },
      { timeLimit: 26e4, targetScore: 3e4, difficulty: "master" },
      { timeLimit: 3e5, targetScore: 4e4, difficulty: "master" }
    ];
  }
  /**
   * Set up a level
   */
  setupLevel(levelNumber) {
    this.state.currentLevel = levelNumber;
    this.state.levelStartTime = Date.now();
    this.state.levelCompleted = false;
    this.state.gameOver = false;
    const levelConfig = this.levelConfigs[levelNumber - 1];
    if (!levelConfig) {
      this.logger.error(`Invalid level number: ${levelNumber}`);
      return;
    }
    this.logger.info(
      `Setting up level ${levelNumber} (${levelConfig.difficulty})`
    );
    this.eventBus.emit("level:started", {
      level: levelNumber,
      config: levelConfig,
      timestamp: Date.now()
    });
  }
  /**
   * Handle score changes
   */
  handleScoreChange(data) {
    this.state.score += data.scoreChange || 0;
    if (this.state.score > this.state.highScore) {
      this.state.highScore = this.state.score;
    }
    const levelConfig = this.levelConfigs[this.state.currentLevel - 1];
    if (levelConfig && this.state.score >= levelConfig.targetScore && !this.state.levelCompleted) {
      this.completeLevel();
    }
    this.eventBus.emit("game:scoreUpdated", {
      score: this.state.score,
      highScore: this.state.highScore,
      timestamp: Date.now()
    });
  }
  /**
   * Handle player damage
   */
  handlePlayerDamaged(data) {
    this.state.lives -= data.damage || 1;
    if (this.state.lives <= 0) {
      this.gameOver();
    } else {
      this.eventBus.emit("game:livesUpdated", {
        lives: this.state.lives,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Handle item collection
   */
  handleItemCollected(data) {
    const scoreValue = data.scoreValue || 0;
    this.handleScoreChange({ scoreChange: scoreValue });
    this.logger.info(`Item collected: ${data.itemType}, +${scoreValue} points`);
  }
  /**
   * Handle level completion
   */
  handleLevelCompleted(data) {
    this.completeLevel();
  }
  /**
   * Complete the current level
   */
  completeLevel() {
    if (this.state.levelCompleted) {
      return;
    }
    this.state.levelCompleted = true;
    const levelTime = Date.now() - this.state.levelStartTime;
    this.logger.info(
      `Level ${this.state.currentLevel} completed in ${levelTime}ms`
    );
    this.eventBus.emit("level:completed", {
      level: this.state.currentLevel,
      score: this.state.score,
      time: levelTime,
      timestamp: Date.now()
    });
    if (this.state.currentLevel >= this.state.maxLevel) {
      this.completeGame();
    } else {
      setTimeout(() => {
        this.setupLevel(this.state.currentLevel + 1);
      }, 2e3);
    }
  }
  /**
   * Handle level timeout
   */
  handleLevelTimeout() {
    this.logger.info(`Level ${this.state.currentLevel} timed out`);
    this.eventBus.emit("level:timeout", {
      level: this.state.currentLevel,
      timestamp: Date.now()
    });
    this.handlePlayerDamaged({ damage: 1 });
    if (!this.state.gameOver) {
      this.setupLevel(this.state.currentLevel);
    }
  }
  /**
   * Complete the entire game
   */
  completeGame() {
    this.logger.info("Game completed!");
    this.eventBus.emit("game:completed", {
      finalScore: this.state.score,
      finalLevel: this.state.currentLevel,
      timestamp: Date.now()
    });
  }
  /**
   * Handle game over
   */
  gameOver() {
    this.state.gameOver = true;
    this.logger.info("Game Over");
    this.eventBus.emit("game:gameOver", {
      finalScore: this.state.score,
      finalLevel: this.state.currentLevel,
      timestamp: Date.now()
    });
  }
  /**
   * Handle game input
   */
  handleGameInput(data) {
    switch (data.type) {
      case "restart":
        this.restartGame();
        break;
      case "nextLevel":
        if (this.state.levelCompleted) {
          this.setupLevel(this.state.currentLevel + 1);
        }
        break;
      case "pause":
        this.eventBus.emit("game:pauseRequested", { timestamp: Date.now() });
        break;
    }
  }
  /**
   * Handle config changes
   */
  handleConfigChange(data) {
    this.config = { ...this.config, ...data.config };
    this.logger.info("GameManager config updated");
  }
  /**
   * Handle achievement unlock
   */
  handleAchievementUnlock(data) {
    const bonusScore = data.bonusScore || 0;
    if (bonusScore > 0) {
      this.handleScoreChange({ scoreChange: bonusScore });
    }
    if (data.effects) {
      this.applyAchievementEffects(data.effects);
    }
  }
  /**
   * Handle daily challenge completion
   */
  handleDailyChallengeCompletion(data) {
    const bonusScore = data.bonusScore || 0;
    if (bonusScore > 0) {
      this.handleScoreChange({ scoreChange: bonusScore });
    }
    if (data.effects) {
      this.applyChallengeEffects(data.effects);
    }
  }
  /**
   * Apply achievement effects
   */
  applyAchievementEffects(effects) {
    if (effects.extraLives) {
      this.state.lives += effects.extraLives;
    }
    if (effects.scoreMultiplier) {
      this.temporaryScoreMultiplier = effects.scoreMultiplier;
      setTimeout(() => {
        this.temporaryScoreMultiplier = 1;
      }, effects.duration || 3e4);
    }
  }
  /**
   * Apply challenge effects
   */
  applyChallengeEffects(effects) {
    if (effects.temporaryPowerUp) {
      this.eventBus.emit("game:powerUpActivated", {
        type: effects.temporaryPowerUp,
        duration: effects.duration || 3e4,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Restart the game
   */
  restartGame() {
    this.state = {
      currentLevel: 1,
      maxLevel: 10,
      score: 0,
      highScore: this.state.highScore,
      // Keep high score
      lives: 3,
      levelStartTime: null,
      levelCompleted: false,
      gameOver: false
    };
    this.setupLevel(1);
    this.eventBus.emit("game:restarted", {
      timestamp: Date.now()
    });
  }
  /**
   * Update level-specific logic
   */
  updateLevelSpecificLogic(deltaTime, gameState) {
    const levelConfig = this.levelConfigs[this.state.currentLevel - 1];
    if (!levelConfig) return;
    switch (levelConfig.difficulty) {
      case "easy":
        break;
      case "medium":
        break;
      case "hard":
        break;
      case "expert":
        break;
      case "master":
        break;
    }
  }
  /**
   * Load game data from storage
   */
  async loadGameData() {
    try {
      const savedData = localStorage.getItem("gameData");
      if (savedData) {
        const data = JSON.parse(savedData);
        this.state.highScore = data.highScore || 0;
        this.logger.info("Game data loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load game data:", error);
    }
  }
  /**
   * Save game data to storage
   */
  saveGameData() {
    try {
      const data = {
        highScore: this.state.highScore,
        lastPlayed: Date.now()
      };
      localStorage.setItem("gameData", JSON.stringify(data));
      this.logger.info("Game data saved to storage");
    } catch (error) {
      this.logger.error("Failed to save game data:", error);
    }
  }
  /**
   * Get current game state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get level configuration
   */
  getLevelConfig(levelNumber) {
    return this.levelConfigs[levelNumber - 1];
  }
  /**
   * Set level configuration
   */
  setLevelConfig(levelNumber, config) {
    if (levelNumber >= 1 && levelNumber <= this.levelConfigs.length) {
      this.levelConfigs[levelNumber - 1] = {
        ...this.levelConfigs[levelNumber - 1],
        ...config
      };
    }
  }
};

// src/managers/AchievementManager.js
var AchievementManager = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.gameState = dependencies.gameState;
    if (!this.eventBus) {
      throw new Error("AchievementManager requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("AchievementManager requires logger dependency");
    }
    this.achievements = /* @__PURE__ */ new Map();
    this.unlockedAchievements = /* @__PURE__ */ new Set();
    this.progress = /* @__PURE__ */ new Map();
    this.initializeAchievements();
    this.setupEventHandlers();
    this.logger.info("AchievementManager initialized");
  }
  /**
   * Initialize the manager
   */
  async initialize() {
    this.logger.info("Initializing AchievementManager...");
    await this.loadAchievementData();
    this.logger.info("AchievementManager initialized successfully");
  }
  /**
   * Cleanup the manager
   */
  cleanup() {
    this.logger.info("Cleaning up AchievementManager...");
    this.saveAchievementData();
    this.removeEventHandlers();
    this.logger.info("AchievementManager cleaned up");
  }
  /**
   * Update the manager
   */
  update(deltaTime, gameState) {
    this.checkTimeBasedAchievements(gameState);
    this.checkComboAchievements(gameState);
  }
  /**
   * Initialize achievement definitions
   */
  initializeAchievements() {
    this.defineAchievement("first_score", {
      name: "First Steps",
      description: "Score your first 100 points",
      type: "score",
      target: 100,
      reward: { score: 50, title: "Beginner" },
      icon: "star"
    });
    this.defineAchievement("score_master", {
      name: "Score Master",
      description: "Reach 10,000 points",
      type: "score",
      target: 1e4,
      reward: { score: 500, title: "Score Master" },
      icon: "trophy"
    });
    this.defineAchievement("high_score_king", {
      name: "High Score King",
      description: "Reach 50,000 points",
      type: "score",
      target: 5e4,
      reward: { score: 2e3, title: "High Score King" },
      icon: "crown"
    });
    this.defineAchievement("level_5", {
      name: "Level 5 Complete",
      description: "Complete level 5",
      type: "level",
      target: 5,
      reward: { extraLives: 1, title: "Level 5 Veteran" },
      icon: "medal"
    });
    this.defineAchievement("level_10", {
      name: "Level 10 Complete",
      description: "Complete level 10",
      type: "level",
      target: 10,
      reward: { score: 1e3, title: "Level 10 Master" },
      icon: "diamond"
    });
    this.defineAchievement("collector", {
      name: "Collector",
      description: "Collect 50 items",
      type: "collection",
      target: 50,
      reward: { score: 300, title: "Collector" },
      icon: "bag"
    });
    this.defineAchievement("hoarder", {
      name: "Hoarder",
      description: "Collect 200 items",
      type: "collection",
      target: 200,
      reward: { score: 1e3, title: "Hoarder" },
      icon: "treasure"
    });
    this.defineAchievement("speed_demon", {
      name: "Speed Demon",
      description: "Complete a level in under 30 seconds",
      type: "speed",
      target: 3e4,
      // 30 seconds in milliseconds
      reward: { score: 500, title: "Speed Demon" },
      icon: "lightning"
    });
    this.defineAchievement("marathon_runner", {
      name: "Marathon Runner",
      description: "Play for 30 minutes straight",
      type: "playtime",
      target: 18e5,
      // 30 minutes in milliseconds
      reward: { score: 1e3, title: "Marathon Runner" },
      icon: "clock"
    });
    this.defineAchievement("combo_master", {
      name: "Combo Master",
      description: "Achieve a 10x combo",
      type: "combo",
      target: 10,
      reward: { score: 200, title: "Combo Master" },
      icon: "fire"
    });
    this.defineAchievement("combo_legend", {
      name: "Combo Legend",
      description: "Achieve a 25x combo",
      type: "combo",
      target: 25,
      reward: { score: 1e3, title: "Combo Legend" },
      icon: "explosion"
    });
    this.defineAchievement("perfect_level", {
      name: "Perfect Level",
      description: "Complete a level without taking damage",
      type: "perfect",
      target: 1,
      reward: { score: 750, title: "Perfect Player" },
      icon: "shield"
    });
    this.defineAchievement("comeback_kid", {
      name: "Comeback Kid",
      description: "Complete a level with only 1 life remaining",
      type: "comeback",
      target: 1,
      reward: { score: 500, title: "Comeback Kid" },
      icon: "heart"
    });
  }
  /**
   * Define an achievement
   */
  defineAchievement(id, definition) {
    this.achievements.set(id, {
      id,
      ...definition,
      unlocked: false,
      unlockedAt: null,
      progress: 0
    });
    this.progress.set(id, 0);
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("player:scoreChanged", this.handleScoreChange.bind(this));
    this.eventBus.on(
      "player:levelCompleted",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.on(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.on("game:started", this.handleGameStarted.bind(this));
    this.eventBus.on("level:completed", this.handleLevelCompleted.bind(this));
    this.eventBus.on("player:comboChanged", this.handleComboChanged.bind(this));
    this.eventBus.on("player:damaged", this.handlePlayerDamaged.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener(
      "player:scoreChanged",
      this.handleScoreChange.bind(this)
    );
    this.eventBus.removeListener(
      "player:levelCompleted",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.removeListener(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.removeListener(
      "game:started",
      this.handleGameStarted.bind(this)
    );
    this.eventBus.removeListener(
      "level:completed",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.removeListener(
      "player:comboChanged",
      this.handleComboChanged.bind(this)
    );
    this.eventBus.removeListener(
      "player:damaged",
      this.handlePlayerDamaged.bind(this)
    );
  }
  /**
   * Handle score changes
   */
  handleScoreChange(data) {
    const currentScore = this.gameState().score;
    this.checkScoreAchievements(currentScore);
  }
  /**
   * Handle level completion
   */
  handleLevelCompleted(data) {
    this.checkLevelAchievements(data.level);
    this.checkSpeedAchievements(data.time);
    this.checkPerfectLevelAchievements(data);
  }
  /**
   * Handle item collection
   */
  handleItemCollected(data) {
    this.checkCollectionAchievements(data.itemType);
  }
  /**
   * Handle game start
   */
  handleGameStarted(data) {
    this.gameStartTime = data.timestamp;
  }
  /**
   * Handle combo changes
   */
  handleComboChanged(data) {
    this.checkComboAchievements(data.combo);
  }
  /**
   * Handle player damage
   */
  handlePlayerDamaged(data) {
    this.currentLevelPerfect = false;
  }
  /**
   * Check score-based achievements
   */
  checkScoreAchievements(currentScore) {
    this.checkAchievementsByType("score", currentScore);
  }
  /**
   * Check level-based achievements
   */
  checkLevelAchievements(level) {
    this.checkAchievementsByType("level", level);
  }
  /**
   * Check collection-based achievements
   */
  checkCollectionAchievements(itemType) {
    const currentCount = this.progress.get("collector") || 0;
    this.progress.set("collector", currentCount + 1);
    this.checkAchievementsByType("collection", this.progress.get("collector"));
  }
  /**
   * Check speed-based achievements
   */
  checkSpeedAchievements(levelTime) {
    this.checkAchievementsByType("speed", levelTime);
  }
  /**
   * Check combo-based achievements
   */
  checkComboAchievements(combo) {
    this.checkAchievementsByType("combo", combo);
  }
  /**
   * Check time-based achievements
   */
  checkTimeBasedAchievements(gameState) {
    if (this.gameStartTime) {
      const playTime = Date.now() - this.gameStartTime;
      this.checkAchievementsByType("playtime", playTime);
    }
  }
  /**
   * Check combo achievements
   */
  checkComboAchievements(gameState) {
  }
  /**
   * Check perfect level achievements
   */
  checkPerfectLevelAchievements(levelData) {
    if (levelData.perfect) {
      this.checkAchievementsByType("perfect", 1);
    }
  }
  /**
   * Check achievements by type
   */
  checkAchievementsByType(type, value) {
    for (const [id, achievement] of this.achievements) {
      if (achievement.type === type && !achievement.unlocked) {
        if (value >= achievement.target) {
          this.unlockAchievement(id);
        } else {
          this.progress.set(id, value);
          achievement.progress = value;
        }
      }
    }
  }
  /**
   * Unlock an achievement
   */
  unlockAchievement(id) {
    const achievement = this.achievements.get(id);
    if (!achievement || achievement.unlocked) {
      return;
    }
    achievement.unlocked = true;
    achievement.unlockedAt = Date.now();
    this.unlockedAchievements.add(id);
    this.logger.info(`Achievement unlocked: ${achievement.name}`);
    this.eventBus.emit("achievement:unlocked", {
      id,
      name: achievement.name,
      description: achievement.description,
      reward: achievement.reward,
      icon: achievement.icon,
      timestamp: Date.now()
    });
    this.applyAchievementReward(achievement);
  }
  /**
   * Apply achievement reward
   */
  applyAchievementReward(achievement) {
    if (!achievement.reward) return;
    const reward = achievement.reward;
    if (reward.score) {
      this.eventBus.emit("player:scoreChanged", {
        scoreChange: reward.score,
        source: "achievement",
        achievementId: achievement.id
      });
    }
    if (reward.extraLives) {
      this.eventBus.emit("player:livesChanged", {
        livesChange: reward.extraLives,
        source: "achievement",
        achievementId: achievement.id
      });
    }
    if (reward.title) {
      this.eventBus.emit("player:titleChanged", {
        title: reward.title,
        source: "achievement",
        achievementId: achievement.id
      });
    }
    if (reward.effects) {
      this.eventBus.emit("game:achievementEffect", {
        effects: reward.effects,
        achievementId: achievement.id
      });
    }
  }
  /**
   * Get achievement by ID
   */
  getAchievement(id) {
    return this.achievements.get(id);
  }
  /**
   * Get all achievements
   */
  getAllAchievements() {
    return Array.from(this.achievements.values());
  }
  /**
   * Get unlocked achievements
   */
  getUnlockedAchievements() {
    return Array.from(this.achievements.values()).filter((a) => a.unlocked);
  }
  /**
   * Get achievement progress
   */
  getAchievementProgress(id) {
    const achievement = this.achievements.get(id);
    if (!achievement) return null;
    return {
      id,
      name: achievement.name,
      description: achievement.description,
      progress: achievement.progress,
      target: achievement.target,
      percentage: Math.min(
        achievement.progress / achievement.target * 100,
        100
      ),
      unlocked: achievement.unlocked
    };
  }
  /**
   * Get all achievement progress
   */
  getAllAchievementProgress() {
    const progress = [];
    for (const [id, achievement] of this.achievements) {
      progress.push(this.getAchievementProgress(id));
    }
    return progress;
  }
  /**
   * Load achievement data from storage
   */
  async loadAchievementData() {
    try {
      const savedData = localStorage.getItem("achievementData");
      if (savedData) {
        const data = JSON.parse(savedData);
        if (data.unlocked) {
          data.unlocked.forEach((id) => {
            if (this.achievements.has(id)) {
              this.achievements.get(id).unlocked = true;
              this.unlockedAchievements.add(id);
            }
          });
        }
        if (data.progress) {
          for (const [id, progress] of Object.entries(data.progress)) {
            if (this.achievements.has(id)) {
              this.achievements.get(id).progress = progress;
              this.progress.set(id, progress);
            }
          }
        }
        this.logger.info("Achievement data loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load achievement data:", error);
    }
  }
  /**
   * Save achievement data to storage
   */
  saveAchievementData() {
    try {
      const data = {
        unlocked: Array.from(this.unlockedAchievements),
        progress: Object.fromEntries(this.progress)
      };
      localStorage.setItem("achievementData", JSON.stringify(data));
      this.logger.info("Achievement data saved to storage");
    } catch (error) {
      this.logger.error("Failed to save achievement data:", error);
    }
  }
  /**
   * Reset all achievements
   */
  resetAchievements() {
    this.unlockedAchievements.clear();
    this.progress.clear();
    for (const [id, achievement] of this.achievements) {
      achievement.unlocked = false;
      achievement.unlockedAt = null;
      achievement.progress = 0;
      this.progress.set(id, 0);
    }
    this.logger.info("All achievements reset");
  }
};

// src/managers/DailyChallengeManager.js
var DailyChallengeManager = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.gameState = dependencies.gameState;
    if (!this.eventBus) {
      throw new Error("DailyChallengeManager requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("DailyChallengeManager requires logger dependency");
    }
    this.challenges = /* @__PURE__ */ new Map();
    this.activeChallenges = [];
    this.completedChallenges = /* @__PURE__ */ new Set();
    this.challengeProgress = /* @__PURE__ */ new Map();
    this.lastChallengeDate = null;
    this.challengeTemplates = this.initializeChallengeTemplates();
    this.setupEventHandlers();
    this.logger.info("DailyChallengeManager initialized");
  }
  /**
   * Initialize the manager
   */
  async initialize() {
    this.logger.info("Initializing DailyChallengeManager...");
    await this.loadChallengeData();
    this.generateDailyChallenges();
    this.logger.info("DailyChallengeManager initialized successfully");
  }
  /**
   * Cleanup the manager
   */
  cleanup() {
    this.logger.info("Cleaning up DailyChallengeManager...");
    this.saveChallengeData();
    this.removeEventHandlers();
    this.logger.info("DailyChallengeManager cleaned up");
  }
  /**
   * Update the manager
   */
  update(deltaTime, gameState) {
    this.checkDailyChallengeRotation();
    this.updateChallengeProgress(gameState);
  }
  /**
   * Initialize challenge templates
   */
  initializeChallengeTemplates() {
    return {
      score: [
        {
          name: "Score Hunter",
          description: "Score {target} points in a single game",
          type: "score",
          difficulty: "easy",
          target: 1e3,
          reward: { score: 200, coins: 10 }
        },
        {
          name: "Score Master",
          description: "Score {target} points in a single game",
          type: "score",
          difficulty: "medium",
          target: 5e3,
          reward: { score: 500, coins: 25 }
        },
        {
          name: "Score Legend",
          description: "Score {target} points in a single game",
          type: "score",
          difficulty: "hard",
          target: 15e3,
          reward: { score: 1e3, coins: 50 }
        }
      ],
      level: [
        {
          name: "Level Climber",
          description: "Reach level {target}",
          type: "level",
          difficulty: "easy",
          target: 3,
          reward: { score: 300, coins: 15 }
        },
        {
          name: "Level Master",
          description: "Reach level {target}",
          type: "level",
          difficulty: "medium",
          target: 7,
          reward: { score: 750, coins: 35 }
        },
        {
          name: "Level Legend",
          description: "Reach level {target}",
          type: "level",
          difficulty: "hard",
          target: 10,
          reward: { score: 1500, coins: 75 }
        }
      ],
      collection: [
        {
          name: "Item Collector",
          description: "Collect {target} items in a single game",
          type: "collection",
          difficulty: "easy",
          target: 10,
          reward: { score: 150, coins: 8 }
        },
        {
          name: "Item Hoarder",
          description: "Collect {target} items in a single game",
          type: "collection",
          difficulty: "medium",
          target: 25,
          reward: { score: 400, coins: 20 }
        },
        {
          name: "Item Master",
          description: "Collect {target} items in a single game",
          type: "collection",
          difficulty: "hard",
          target: 50,
          reward: { score: 800, coins: 40 }
        }
      ],
      combo: [
        {
          name: "Combo Starter",
          description: "Achieve a {target}x combo",
          type: "combo",
          difficulty: "easy",
          target: 5,
          reward: { score: 100, coins: 5 }
        },
        {
          name: "Combo Master",
          description: "Achieve a {target}x combo",
          type: "combo",
          difficulty: "medium",
          target: 15,
          reward: { score: 300, coins: 15 }
        },
        {
          name: "Combo Legend",
          description: "Achieve a {target}x combo",
          type: "combo",
          difficulty: "hard",
          target: 30,
          reward: { score: 600, coins: 30 }
        }
      ],
      time: [
        {
          name: "Speed Runner",
          description: "Complete a level in under {target} seconds",
          type: "time",
          difficulty: "easy",
          target: 60,
          reward: { score: 200, coins: 10 }
        },
        {
          name: "Speed Master",
          description: "Complete a level in under {target} seconds",
          type: "time",
          difficulty: "medium",
          target: 30,
          reward: { score: 500, coins: 25 }
        },
        {
          name: "Speed Legend",
          description: "Complete a level in under {target} seconds",
          type: "time",
          difficulty: "hard",
          target: 15,
          reward: { score: 1e3, coins: 50 }
        }
      ],
      survival: [
        {
          name: "Survivor",
          description: "Complete {target} levels without dying",
          type: "survival",
          difficulty: "easy",
          target: 3,
          reward: { score: 400, coins: 20 }
        },
        {
          name: "Survival Master",
          description: "Complete {target} levels without dying",
          type: "survival",
          difficulty: "medium",
          target: 7,
          reward: { score: 1e3, coins: 50 }
        },
        {
          name: "Survival Legend",
          description: "Complete {target} levels without dying",
          type: "survival",
          difficulty: "hard",
          target: 10,
          reward: { score: 2e3, coins: 100 }
        }
      ]
    };
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("player:scoreChanged", this.handleScoreChange.bind(this));
    this.eventBus.on(
      "player:levelCompleted",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.on(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.on("player:comboChanged", this.handleComboChanged.bind(this));
    this.eventBus.on("game:started", this.handleGameStarted.bind(this));
    this.eventBus.on("level:completed", this.handleLevelCompleted.bind(this));
    this.eventBus.on("player:damaged", this.handlePlayerDamaged.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener(
      "player:scoreChanged",
      this.handleScoreChange.bind(this)
    );
    this.eventBus.removeListener(
      "player:levelCompleted",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.removeListener(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.removeListener(
      "player:comboChanged",
      this.handleComboChanged.bind(this)
    );
    this.eventBus.removeListener(
      "game:started",
      this.handleGameStarted.bind(this)
    );
    this.eventBus.removeListener(
      "level:completed",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.removeListener(
      "player:damaged",
      this.handlePlayerDamaged.bind(this)
    );
  }
  /**
   * Generate daily challenges
   */
  generateDailyChallenges() {
    const today = (/* @__PURE__ */ new Date()).toDateString();
    if (this.lastChallengeDate === today) {
      return;
    }
    this.activeChallenges = [];
    this.completedChallenges.clear();
    this.challengeProgress.clear();
    const challengeTypes = Object.keys(this.challengeTemplates);
    const selectedTypes = this.getRandomElements(challengeTypes, 3);
    selectedTypes.forEach((type, index) => {
      const template = this.getRandomElement(this.challengeTemplates[type]);
      const challenge = this.createChallenge(template, index);
      this.activeChallenges.push(challenge);
      this.challenges.set(challenge.id, challenge);
    });
    this.lastChallengeDate = today;
    this.logger.info(
      `Generated ${this.activeChallenges.length} daily challenges for ${today}`
    );
    this.eventBus.emit("dailyChallenges:generated", {
      challenges: this.activeChallenges,
      date: today,
      timestamp: Date.now()
    });
  }
  /**
   * Create a challenge from template
   */
  createChallenge(template, index) {
    const id = `daily_${Date.now()}_${index}`;
    const challenge = {
      id,
      name: template.name,
      description: template.description.replace("{target}", template.target),
      type: template.type,
      difficulty: template.difficulty,
      target: template.target,
      reward: template.reward,
      progress: 0,
      completed: false,
      completedAt: null,
      createdAt: Date.now()
    };
    return challenge;
  }
  /**
   * Check daily challenge rotation
   */
  checkDailyChallengeRotation() {
    const today = (/* @__PURE__ */ new Date()).toDateString();
    if (this.lastChallengeDate !== today) {
      this.generateDailyChallenges();
    }
  }
  /**
   * Update challenge progress
   */
  updateChallengeProgress(gameState) {
  }
  /**
   * Handle score changes
   */
  handleScoreChange(data) {
    this.checkScoreChallenges(data.score);
  }
  /**
   * Handle level completion
   */
  handleLevelCompleted(data) {
    this.checkLevelChallenges(data.level);
    this.checkTimeChallenges(data.time);
    this.checkSurvivalChallenges(data);
  }
  /**
   * Handle item collection
   */
  handleItemCollected(data) {
    this.checkCollectionChallenges(data.itemType);
  }
  /**
   * Handle combo changes
   */
  handleComboChanged(data) {
    this.checkComboChallenges(data.combo);
  }
  /**
   * Handle game start
   */
  handleGameStarted(data) {
    this.gameStartTime = data.timestamp;
    this.currentGameScore = 0;
    this.currentGameLevel = 0;
    this.currentGameItems = 0;
    this.currentGameCombo = 0;
    this.survivalCount = 0;
  }
  /**
   * Handle player damage
   */
  handlePlayerDamaged(data) {
    this.survivalCount = 0;
  }
  /**
   * Check score-based challenges
   */
  checkScoreChallenges(currentScore) {
    this.currentGameScore = currentScore;
    this.checkChallengesByType("score", currentScore);
  }
  /**
   * Check level-based challenges
   */
  checkLevelChallenges(level) {
    this.currentGameLevel = level;
    this.checkChallengesByType("level", level);
  }
  /**
   * Check collection-based challenges
   */
  checkCollectionChallenges(itemType) {
    this.currentGameItems++;
    this.checkChallengesByType("collection", this.currentGameItems);
  }
  /**
   * Check combo-based challenges
   */
  checkComboChallenges(combo) {
    this.currentGameCombo = combo;
    this.checkChallengesByType("combo", combo);
  }
  /**
   * Check time-based challenges
   */
  checkTimeChallenges(levelTime) {
    const timeInSeconds = Math.floor(levelTime / 1e3);
    this.checkChallengesByType("time", timeInSeconds);
  }
  /**
   * Check survival challenges
   */
  checkSurvivalChallenges(levelData) {
    this.survivalCount++;
    this.checkChallengesByType("survival", this.survivalCount);
  }
  /**
   * Check challenges by type
   */
  checkChallengesByType(type, value) {
    for (const challenge of this.activeChallenges) {
      if (challenge.type === type && !challenge.completed) {
        if (value >= challenge.target) {
          this.completeChallenge(challenge.id);
        } else {
          challenge.progress = value;
          this.challengeProgress.set(challenge.id, value);
        }
      }
    }
  }
  /**
   * Complete a challenge
   */
  completeChallenge(challengeId) {
    const challenge = this.challenges.get(challengeId);
    if (!challenge || challenge.completed) {
      return;
    }
    challenge.completed = true;
    challenge.completedAt = Date.now();
    this.completedChallenges.add(challengeId);
    this.logger.info(`Daily challenge completed: ${challenge.name}`);
    this.eventBus.emit("dailyChallenge:completed", {
      id: challengeId,
      name: challenge.name,
      description: challenge.description,
      reward: challenge.reward,
      timestamp: Date.now()
    });
    this.applyChallengeReward(challenge);
  }
  /**
   * Apply challenge reward
   */
  applyChallengeReward(challenge) {
    if (!challenge.reward) return;
    const reward = challenge.reward;
    if (reward.score) {
      this.eventBus.emit("player:scoreChanged", {
        scoreChange: reward.score,
        source: "dailyChallenge",
        challengeId: challenge.id
      });
    }
    if (reward.coins) {
      this.eventBus.emit("player:coinsChanged", {
        coinsChange: reward.coins,
        source: "dailyChallenge",
        challengeId: challenge.id
      });
    }
    if (reward.effects) {
      this.eventBus.emit("game:challengeEffect", {
        effects: reward.effects,
        challengeId: challenge.id
      });
    }
  }
  /**
   * Get active challenges
   */
  getActiveChallenges() {
    return this.activeChallenges.filter((c) => !c.completed);
  }
  /**
   * Get completed challenges
   */
  getCompletedChallenges() {
    return this.activeChallenges.filter((c) => c.completed);
  }
  /**
   * Get all challenges
   */
  getAllChallenges() {
    return this.activeChallenges;
  }
  /**
   * Get challenge progress
   */
  getChallengeProgress(challengeId) {
    const challenge = this.challenges.get(challengeId);
    if (!challenge) return null;
    return {
      id: challengeId,
      name: challenge.name,
      description: challenge.description,
      progress: challenge.progress,
      target: challenge.target,
      percentage: Math.min(challenge.progress / challenge.target * 100, 100),
      completed: challenge.completed,
      difficulty: challenge.difficulty,
      reward: challenge.reward
    };
  }
  /**
   * Get all challenge progress
   */
  getAllChallengeProgress() {
    const progress = [];
    for (const challenge of this.activeChallenges) {
      progress.push(this.getChallengeProgress(challenge.id));
    }
    return progress;
  }
  /**
   * Get random elements from array
   */
  getRandomElements(array, count) {
    const shuffled = array.sort(() => 0.5 - Math.random());
    return shuffled.slice(0, count);
  }
  /**
   * Get random element from array
   */
  getRandomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
  }
  /**
   * Load challenge data from storage
   */
  async loadChallengeData() {
    try {
      const savedData = localStorage.getItem("dailyChallengeData");
      if (savedData) {
        const data = JSON.parse(savedData);
        this.lastChallengeDate = data.lastChallengeDate;
        if (data.completed) {
          data.completed.forEach((id) => {
            this.completedChallenges.add(id);
          });
        }
        if (data.progress) {
          for (const [id, progress] of Object.entries(data.progress)) {
            this.challengeProgress.set(id, progress);
          }
        }
        this.logger.info("Daily challenge data loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load daily challenge data:", error);
    }
  }
  /**
   * Save challenge data to storage
   */
  saveChallengeData() {
    try {
      const data = {
        lastChallengeDate: this.lastChallengeDate,
        completed: Array.from(this.completedChallenges),
        progress: Object.fromEntries(this.challengeProgress)
      };
      localStorage.setItem("dailyChallengeData", JSON.stringify(data));
      this.logger.info("Daily challenge data saved to storage");
    } catch (error) {
      this.logger.error("Failed to save daily challenge data:", error);
    }
  }
  /**
   * Reset all challenges
   */
  resetChallenges() {
    this.activeChallenges = [];
    this.completedChallenges.clear();
    this.challengeProgress.clear();
    this.lastChallengeDate = null;
    this.logger.info("All daily challenges reset");
  }
};

// src/managers/AccessibilityManager.js
var AccessibilityManager = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.gameState = dependencies.gameState;
    if (!this.eventBus) {
      throw new Error("AccessibilityManager requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("AccessibilityManager requires logger dependency");
    }
    this.settings = {
      screenReader: false,
      highContrast: false,
      colorblindMode: "none",
      // 'none', 'protanopia', 'deuteranopia', 'tritanopia'
      keyboardNavigation: false,
      audioCues: true,
      audioDescriptions: false,
      textScaling: 1,
      motionReduction: false,
      reducedAnimations: false,
      largeText: false,
      focusIndicators: true
    };
    this.audioContext = null;
    this.audioEnabled = true;
    this.announcements = [];
    this.announcementQueue = [];
    this.setupEventHandlers();
    this.logger.info("AccessibilityManager initialized");
  }
  /**
   * Initialize the manager
   */
  async initialize() {
    this.logger.info("Initializing AccessibilityManager...");
    await this.loadAccessibilitySettings();
    this.initializeAudio();
    this.setupDOMAccessibility();
    this.logger.info("AccessibilityManager initialized successfully");
  }
  /**
   * Cleanup the manager
   */
  cleanup() {
    this.logger.info("Cleaning up AccessibilityManager...");
    this.saveAccessibilitySettings();
    this.removeEventHandlers();
    if (this.audioContext) {
      this.audioContext.close();
    }
    this.logger.info("AccessibilityManager cleaned up");
  }
  /**
   * Update the manager
   */
  update(deltaTime, gameState) {
    this.processAnnouncementQueue();
    this.updateAccessibilityFeatures(gameState);
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("game:started", this.handleGameStarted.bind(this));
    this.eventBus.on("game:paused", this.handleGamePaused.bind(this));
    this.eventBus.on("game:resumed", this.handleGameResumed.bind(this));
    this.eventBus.on("game:stopped", this.handleGameStopped.bind(this));
    this.eventBus.on("player:scoreChanged", this.handleScoreChanged.bind(this));
    this.eventBus.on("player:damaged", this.handlePlayerDamaged.bind(this));
    this.eventBus.on(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.on("level:started", this.handleLevelStarted.bind(this));
    this.eventBus.on("level:completed", this.handleLevelCompleted.bind(this));
    this.eventBus.on(
      "achievement:unlocked",
      this.handleAchievementUnlocked.bind(this)
    );
    this.eventBus.on(
      "dailyChallenge:completed",
      this.handleDailyChallengeCompleted.bind(this)
    );
    this.eventBus.on("game:input", this.handleInput.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener(
      "game:started",
      this.handleGameStarted.bind(this)
    );
    this.eventBus.removeListener(
      "game:paused",
      this.handleGamePaused.bind(this)
    );
    this.eventBus.removeListener(
      "game:resumed",
      this.handleGameResumed.bind(this)
    );
    this.eventBus.removeListener(
      "game:stopped",
      this.handleGameStopped.bind(this)
    );
    this.eventBus.removeListener(
      "player:scoreChanged",
      this.handleScoreChanged.bind(this)
    );
    this.eventBus.removeListener(
      "player:damaged",
      this.handlePlayerDamaged.bind(this)
    );
    this.eventBus.removeListener(
      "player:itemCollected",
      this.handleItemCollected.bind(this)
    );
    this.eventBus.removeListener(
      "level:started",
      this.handleLevelStarted.bind(this)
    );
    this.eventBus.removeListener(
      "level:completed",
      this.handleLevelCompleted.bind(this)
    );
    this.eventBus.removeListener(
      "achievement:unlocked",
      this.handleAchievementUnlocked.bind(this)
    );
    this.eventBus.removeListener(
      "dailyChallenge:completed",
      this.handleDailyChallengeCompleted.bind(this)
    );
    this.eventBus.removeListener("game:input", this.handleInput.bind(this));
  }
  /**
   * Initialize audio context
   */
  initializeAudio() {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.audioEnabled = true;
    } catch (error) {
      this.logger.warn("Audio context not available:", error);
      this.audioEnabled = false;
    }
  }
  /**
   * Set up DOM accessibility features
   */
  setupDOMAccessibility() {
    this.createAnnouncementRegion();
    this.setupKeyboardNavigation();
    this.applyAccessibilitySettings();
  }
  /**
   * Create announcement region for screen readers
   */
  createAnnouncementRegion() {
    const announcementRegion = document.createElement("div");
    announcementRegion.id = "accessibility-announcements";
    announcementRegion.setAttribute("aria-live", "polite");
    announcementRegion.setAttribute("aria-atomic", "true");
    announcementRegion.style.cssText = `
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        `;
    document.body.appendChild(announcementRegion);
  }
  /**
   * Set up keyboard navigation
   */
  setupKeyboardNavigation() {
    if (!this.settings.keyboardNavigation) return;
    document.addEventListener("keydown", (event) => {
      this.handleKeyboardNavigation(event);
    });
  }
  /**
   * Handle keyboard navigation
   */
  handleKeyboardNavigation(event) {
    if (!this.settings.keyboardNavigation) return;
    switch (event.key) {
      case "Tab":
        this.handleTabNavigation(event);
        break;
      case "Enter":
      case " ":
        this.handleActivation(event);
        break;
      case "Escape":
        this.handleEscape(event);
        break;
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
        this.handleArrowNavigation(event);
        break;
    }
  }
  /**
   * Handle tab navigation
   */
  handleTabNavigation(event) {
    const focusableElements = document.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
  }
  /**
   * Handle activation
   */
  handleActivation(event) {
    const activeElement = document.activeElement;
    if (activeElement && activeElement.click) {
      activeElement.click();
    }
  }
  /**
   * Handle escape key
   */
  handleEscape(event) {
    this.eventBus.emit("accessibility:escape", {
      timestamp: Date.now()
    });
  }
  /**
   * Handle arrow key navigation
   */
  handleArrowNavigation(event) {
    this.eventBus.emit("accessibility:arrowNavigation", {
      direction: event.key.replace("Arrow", "").toLowerCase(),
      timestamp: Date.now()
    });
  }
  /**
   * Apply accessibility settings
   */
  applyAccessibilitySettings() {
    const root = document.documentElement;
    if (this.settings.highContrast) {
      root.classList.add("high-contrast");
    } else {
      root.classList.remove("high-contrast");
    }
    root.classList.remove(
      "colorblind-protanopia",
      "colorblind-deuteranopia",
      "colorblind-tritanopia"
    );
    if (this.settings.colorblindMode !== "none") {
      root.classList.add(`colorblind-${this.settings.colorblindMode}`);
    }
    root.style.setProperty("--text-scale", this.settings.textScaling);
    if (this.settings.motionReduction) {
      root.classList.add("motion-reduced");
    } else {
      root.classList.remove("motion-reduced");
    }
    if (this.settings.largeText) {
      root.classList.add("large-text");
    } else {
      root.classList.remove("large-text");
    }
    if (this.settings.focusIndicators) {
      root.classList.add("focus-indicators");
    } else {
      root.classList.remove("focus-indicators");
    }
  }
  /**
   * Update accessibility settings
   */
  updateSettings(newSettings) {
    this.settings = { ...this.settings, ...newSettings };
    this.applyAccessibilitySettings();
    this.logger.info("Accessibility settings updated");
    this.eventBus.emit("accessibility:settingsChanged", {
      settings: this.settings,
      timestamp: Date.now()
    });
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Announce text to screen readers
   */
  announce(text, priority = "polite") {
    if (!this.settings.screenReader) return;
    const announcement = {
      text,
      priority,
      timestamp: Date.now()
    };
    this.announcementQueue.push(announcement);
  }
  /**
   * Process announcement queue
   */
  processAnnouncementQueue() {
    if (this.announcementQueue.length === 0) return;
    const announcement = this.announcementQueue.shift();
    const announcementRegion = document.getElementById(
      "accessibility-announcements"
    );
    if (announcementRegion) {
      announcementRegion.setAttribute("aria-live", announcement.priority);
      announcementRegion.textContent = announcement.text;
    }
  }
  /**
   * Play audio cue
   */
  playAudioCue(cueType, frequency = 440, duration = 200) {
    if (!this.settings.audioCues || !this.audioEnabled || !this.audioContext)
      return;
    try {
      const oscillator = this.audioContext.createOscillator();
      const gainNode = this.audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      oscillator.frequency.setValueAtTime(
        frequency,
        this.audioContext.currentTime
      );
      oscillator.type = "sine";
      gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(
        0.1,
        this.audioContext.currentTime + 0.01
      );
      gainNode.gain.linearRampToValueAtTime(
        0,
        this.audioContext.currentTime + duration / 1e3
      );
      oscillator.start(this.audioContext.currentTime);
      oscillator.stop(this.audioContext.currentTime + duration / 1e3);
    } catch (error) {
      this.logger.warn("Failed to play audio cue:", error);
    }
  }
  /**
   * Handle game started
   */
  handleGameStarted(data) {
    this.announce("Game started");
    this.playAudioCue("gameStart", 523, 300);
  }
  /**
   * Handle game paused
   */
  handleGamePaused(data) {
    this.announce("Game paused");
    this.playAudioCue("pause", 330, 200);
  }
  /**
   * Handle game resumed
   */
  handleGameResumed(data) {
    this.announce("Game resumed");
    this.playAudioCue("resume", 523, 200);
  }
  /**
   * Handle game stopped
   */
  handleGameStopped(data) {
    this.announce("Game stopped");
    this.playAudioCue("gameOver", 220, 500);
  }
  /**
   * Handle score changed
   */
  handleScoreChanged(data) {
    if (data.scoreChange > 0) {
      this.announce(
        `Score increased by ${data.scoreChange}. Total score: ${data.score}`
      );
      this.playAudioCue("score", 659, 100);
    }
  }
  /**
   * Handle player damaged
   */
  handlePlayerDamaged(data) {
    this.announce(`Player damaged. Lives remaining: ${data.lives}`);
    this.playAudioCue("damage", 220, 300);
  }
  /**
   * Handle item collected
   */
  handleItemCollected(data) {
    this.announce(`Item collected: ${data.itemType}`);
    this.playAudioCue("item", 880, 150);
  }
  /**
   * Handle level started
   */
  handleLevelStarted(data) {
    this.announce(`Level ${data.level} started`);
    this.playAudioCue("levelStart", 523, 400);
  }
  /**
   * Handle level completed
   */
  handleLevelCompleted(data) {
    this.announce(
      `Level ${data.level} completed in ${Math.floor(data.time / 1e3)} seconds`
    );
    this.playAudioCue("levelComplete", 1047, 600);
  }
  /**
   * Handle achievement unlocked
   */
  handleAchievementUnlocked(data) {
    this.announce(`Achievement unlocked: ${data.name}`);
    this.playAudioCue("achievement", 1319, 800);
  }
  /**
   * Handle daily challenge completed
   */
  handleDailyChallengeCompleted(data) {
    this.announce(`Daily challenge completed: ${data.name}`);
    this.playAudioCue("challenge", 1047, 500);
  }
  /**
   * Handle input
   */
  handleInput(data) {
    if (this.settings.audioCues) {
      this.playAudioCue("input", 440, 50);
    }
  }
  /**
   * Update accessibility features based on game state
   */
  updateAccessibilityFeatures(gameState) {
    if (gameState.isPaused) {
      this.manageFocusOnPause();
    } else if (gameState.isRunning) {
      this.manageFocusDuringGameplay();
    }
  }
  /**
   * Manage focus when game is paused
   */
  manageFocusOnPause() {
    const pauseMenu = document.querySelector(".pause-menu");
    if (pauseMenu && pauseMenu.focus) {
      pauseMenu.focus();
    }
  }
  /**
   * Manage focus during gameplay
   */
  manageFocusDuringGameplay() {
    const gameArea = document.querySelector(".game-area");
    if (gameArea && gameArea.focus) {
      gameArea.focus();
    }
  }
  /**
   * Load accessibility settings from storage
   */
  async loadAccessibilitySettings() {
    try {
      const savedSettings = localStorage.getItem("accessibilitySettings");
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        this.settings = { ...this.settings, ...settings };
        this.applyAccessibilitySettings();
        this.logger.info("Accessibility settings loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load accessibility settings:", error);
    }
  }
  /**
   * Save accessibility settings to storage
   */
  saveAccessibilitySettings() {
    try {
      localStorage.setItem(
        "accessibilitySettings",
        JSON.stringify(this.settings)
      );
      this.logger.info("Accessibility settings saved to storage");
    } catch (error) {
      this.logger.error("Failed to save accessibility settings:", error);
    }
  }
  /**
   * Reset accessibility settings to defaults
   */
  resetSettings() {
    this.settings = {
      screenReader: false,
      highContrast: false,
      colorblindMode: "none",
      keyboardNavigation: false,
      audioCues: true,
      audioDescriptions: false,
      textScaling: 1,
      motionReduction: false,
      reducedAnimations: false,
      largeText: false,
      focusIndicators: true
    };
    this.applyAccessibilitySettings();
    this.logger.info("Accessibility settings reset to defaults");
  }
};

// src/core/PerformanceMonitor.js
var PerformanceMonitor = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("PerformanceMonitor requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("PerformanceMonitor requires logger dependency");
    }
    this.config = {
      enableFPSMonitoring: true,
      enableMemoryMonitoring: true,
      enableAudioMonitoring: true,
      enableRenderingMonitoring: true,
      enableInputMonitoring: true,
      enableNetworkMonitoring: true,
      enableAutoOptimization: true,
      fpsTarget: 60,
      fpsWarningThreshold: 45,
      fpsCriticalThreshold: 30,
      memoryWarningThreshold: 100 * 1024 * 1024,
      // 100MB
      memoryCriticalThreshold: 200 * 1024 * 1024,
      // 200MB
      frameTimeWarningThreshold: 16.67,
      // 60fps = 16.67ms per frame
      frameTimeCriticalThreshold: 33.33,
      // 30fps = 33.33ms per frame
      reportInterval: 5e3,
      // Report every 5 seconds
      maxHistorySize: 1e3,
      ...dependencies.config
    };
    this.metrics = {
      fps: {
        current: 0,
        average: 0,
        min: Infinity,
        max: 0,
        history: [],
        droppedFrames: 0
      },
      frameTime: {
        current: 0,
        average: 0,
        min: Infinity,
        max: 0,
        history: []
      },
      memory: {
        used: 0,
        total: 0,
        available: 0,
        history: [],
        leakDetected: false,
        leakCount: 0
      },
      audio: {
        contextState: "suspended",
        contextRecreations: 0,
        bufferUnderruns: 0,
        latency: 0,
        performanceScore: 0
      },
      rendering: {
        drawCalls: 0,
        triangles: 0,
        textures: 0,
        shaders: 0,
        batchCount: 0,
        cullingTime: 0,
        lightingTime: 0,
        postProcessingTime: 0
      },
      input: {
        lag: 0,
        eventCount: 0,
        droppedEvents: 0,
        averageResponseTime: 0
      },
      network: {
        latency: 0,
        bandwidth: 0,
        packetLoss: 0,
        connectionQuality: "good"
      }
    };
    this.isMonitoring = false;
    this.lastFrameTime = 0;
    this.frameCount = 0;
    this.lastReportTime = 0;
    this.optimizationSuggestions = [];
    this.performanceAlerts = [];
    this.observers = {
      fps: null,
      memory: null,
      audio: null,
      rendering: null,
      input: null,
      network: null
    };
    this.setupPerformanceMonitoring();
    this.setupEventHandlers();
    this.logger.info("PerformanceMonitor initialized");
  }
  /**
   * Initialize the monitor
   */
  async initialize() {
    this.logger.info("Initializing PerformanceMonitor...");
    if (this.config.enableFPSMonitoring || this.config.enableMemoryMonitoring) {
      this.startMonitoring();
    }
    this.logger.info("PerformanceMonitor initialized successfully");
  }
  /**
   * Cleanup the monitor
   */
  cleanup() {
    this.logger.info("Cleaning up PerformanceMonitor...");
    this.stopMonitoring();
    this.disconnectObservers();
    this.logger.info("PerformanceMonitor cleaned up");
  }
  /**
   * Set up performance monitoring
   */
  setupPerformanceMonitoring() {
    if (this.config.enableFPSMonitoring) {
      this.setupFPSMonitoring();
    }
    if (this.config.enableMemoryMonitoring) {
      this.setupMemoryMonitoring();
    }
    if (this.config.enableAudioMonitoring) {
      this.setupAudioMonitoring();
    }
    if (this.config.enableRenderingMonitoring) {
      this.setupRenderingMonitoring();
    }
    if (this.config.enableInputMonitoring) {
      this.setupInputMonitoring();
    }
    if (this.config.enableNetworkMonitoring) {
      this.setupNetworkMonitoring();
    }
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("game:started", this.handleGameStarted.bind(this));
    this.eventBus.on("game:paused", this.handleGamePaused.bind(this));
    this.eventBus.on("game:resumed", this.handleGameResumed.bind(this));
    this.eventBus.on("game:stopped", this.handleGameStopped.bind(this));
    this.eventBus.on("performance:frame", this.handleFrame.bind(this));
    this.eventBus.on("performance:memory", this.handleMemoryUpdate.bind(this));
    this.eventBus.on("performance:audio", this.handleAudioUpdate.bind(this));
    this.eventBus.on("performance:rendering", this.handleRenderingUpdate.bind(this));
    this.eventBus.on("performance:input", this.handleInputUpdate.bind(this));
    this.eventBus.on("performance:network", this.handleNetworkUpdate.bind(this));
  }
  /**
   * Set up FPS monitoring
   */
  setupFPSMonitoring() {
    this.lastFrameTime = performance.now();
    this.frameCount = 0;
    const measureFPS = (currentTime) => {
      if (!this.isMonitoring) return;
      const deltaTime = currentTime - this.lastFrameTime;
      this.lastFrameTime = currentTime;
      const fps = 1e3 / deltaTime;
      this.updateFPSMetrics(fps, deltaTime);
      requestAnimationFrame(measureFPS);
    };
    this.observers.fps = measureFPS;
  }
  /**
   * Set up memory monitoring
   */
  setupMemoryMonitoring() {
    if (!performance.memory) {
      this.logger.warn("Performance.memory API not available");
      return;
    }
    const measureMemory = () => {
      if (!this.isMonitoring) return;
      const memory = performance.memory;
      this.updateMemoryMetrics(memory);
      this.detectMemoryLeaks();
      setTimeout(measureMemory, 1e3);
    };
    this.observers.memory = measureMemory;
  }
  /**
   * Set up audio monitoring
   */
  setupAudioMonitoring() {
    const measureAudio = () => {
      if (!this.isMonitoring) return;
      this.checkAudioContextHealth();
      setTimeout(measureAudio, 2e3);
    };
    this.observers.audio = measureAudio;
  }
  /**
   * Set up rendering monitoring
   */
  setupRenderingMonitoring() {
    const measureRendering = () => {
      if (!this.isMonitoring) return;
      this.updateRenderingMetrics();
      requestAnimationFrame(measureRendering);
    };
    this.observers.rendering = measureRendering;
  }
  /**
   * Set up input monitoring
   */
  setupInputMonitoring() {
    let inputEventCount = 0;
    let lastInputTime = 0;
    const measureInput = (event) => {
      if (!this.isMonitoring) return;
      const currentTime = performance.now();
      const responseTime = currentTime - lastInputTime;
      inputEventCount++;
      this.updateInputMetrics(responseTime);
      lastInputTime = currentTime;
    };
    document.addEventListener("keydown", measureInput);
    document.addEventListener("mousedown", measureInput);
    document.addEventListener("touchstart", measureInput);
    this.observers.input = measureInput;
  }
  /**
   * Set up network monitoring
   */
  setupNetworkMonitoring() {
    const measureNetwork = () => {
      if (!this.isMonitoring) return;
      this.updateNetworkMetrics();
      setTimeout(measureNetwork, 5e3);
    };
    this.observers.network = measureNetwork;
  }
  /**
   * Start monitoring
   */
  startMonitoring() {
    if (this.isMonitoring) return;
    this.isMonitoring = true;
    this.lastReportTime = performance.now();
    if (this.observers.fps) {
      requestAnimationFrame(this.observers.fps);
    }
    if (this.observers.memory) {
      this.observers.memory();
    }
    if (this.observers.audio) {
      this.observers.audio();
    }
    if (this.observers.rendering) {
      requestAnimationFrame(this.observers.rendering);
    }
    if (this.observers.network) {
      this.observers.network();
    }
    this.logger.info("Performance monitoring started");
  }
  /**
   * Stop monitoring
   */
  stopMonitoring() {
    if (!this.isMonitoring) return;
    this.isMonitoring = false;
    this.logger.info("Performance monitoring stopped");
  }
  /**
   * Disconnect observers
   */
  disconnectObservers() {
    if (this.observers.input) {
      document.removeEventListener("keydown", this.observers.input);
      document.removeEventListener("mousedown", this.observers.input);
      document.removeEventListener("touchstart", this.observers.input);
    }
  }
  /**
   * Update FPS metrics
   */
  updateFPSMetrics(fps, frameTime) {
    this.metrics.fps.current = fps;
    this.metrics.fps.history.push(fps);
    this.metrics.fps.min = Math.min(this.metrics.fps.min, fps);
    this.metrics.fps.max = Math.max(this.metrics.fps.max, fps);
    if (this.metrics.fps.history.length > 0) {
      this.metrics.fps.average = this.metrics.fps.history.reduce((a, b) => a + b, 0) / this.metrics.fps.history.length;
    }
    this.metrics.frameTime.current = frameTime;
    this.metrics.frameTime.history.push(frameTime);
    this.metrics.frameTime.min = Math.min(this.metrics.frameTime.min, frameTime);
    this.metrics.frameTime.max = Math.max(this.metrics.frameTime.max, frameTime);
    if (this.metrics.frameTime.history.length > 0) {
      this.metrics.frameTime.average = this.metrics.frameTime.history.reduce((a, b) => a + b, 0) / this.metrics.frameTime.history.length;
    }
    if (frameTime > this.config.frameTimeCriticalThreshold) {
      this.metrics.fps.droppedFrames++;
    }
    if (this.metrics.fps.history.length > this.config.maxHistorySize) {
      this.metrics.fps.history.shift();
      this.metrics.frameTime.history.shift();
    }
    this.checkFPSPerformance();
  }
  /**
   * Update memory metrics
   */
  updateMemoryMetrics(memory) {
    this.metrics.memory.used = memory.usedJSHeapSize;
    this.metrics.memory.total = memory.totalJSHeapSize;
    this.metrics.memory.available = memory.jsHeapSizeLimit - memory.usedJSHeapSize;
    this.metrics.memory.history.push({
      used: memory.usedJSHeapSize,
      total: memory.totalJSHeapSize,
      timestamp: performance.now()
    });
    if (this.metrics.memory.history.length > this.config.maxHistorySize) {
      this.metrics.memory.history.shift();
    }
    this.checkMemoryPerformance();
  }
  /**
   * Update audio metrics
   */
  updateAudioMetrics(audioData) {
    this.metrics.audio = { ...this.metrics.audio, ...audioData };
    this.checkAudioPerformance();
  }
  /**
   * Update rendering metrics
   */
  updateRenderingMetrics() {
    this.metrics.rendering.drawCalls = 0;
    this.metrics.rendering.triangles = 0;
    this.metrics.rendering.textures = 0;
    this.metrics.rendering.shaders = 0;
  }
  /**
   * Update input metrics
   */
  updateInputMetrics(responseTime) {
    this.metrics.input.eventCount++;
    this.metrics.input.lag = responseTime;
    if (this.metrics.input.eventCount > 0) {
      this.metrics.input.averageResponseTime = (this.metrics.input.averageResponseTime * (this.metrics.input.eventCount - 1) + responseTime) / this.metrics.input.eventCount;
    }
    this.checkInputPerformance();
  }
  /**
   * Update network metrics
   */
  updateNetworkMetrics() {
    this.metrics.network.latency = 0;
    this.metrics.network.bandwidth = 0;
    this.metrics.network.packetLoss = 0;
    this.metrics.network.connectionQuality = "good";
  }
  /**
   * Check FPS performance
   */
  checkFPSPerformance() {
    const fps = this.metrics.fps.current;
    const frameTime = this.metrics.frameTime.current;
    if (fps < this.config.fpsCriticalThreshold) {
      this.addPerformanceAlert("critical", "FPS critically low", { fps, threshold: this.config.fpsCriticalThreshold });
      this.suggestOptimization("fps", "Consider reducing graphics quality or disabling non-essential features");
    } else if (fps < this.config.fpsWarningThreshold) {
      this.addPerformanceAlert("warning", "FPS below target", { fps, threshold: this.config.fpsWarningThreshold });
    }
    if (frameTime > this.config.frameTimeCriticalThreshold) {
      this.addPerformanceAlert("critical", "Frame time too high", { frameTime, threshold: this.config.frameTimeCriticalThreshold });
    } else if (frameTime > this.config.frameTimeWarningThreshold) {
      this.addPerformanceAlert("warning", "Frame time above target", { frameTime, threshold: this.config.frameTimeWarningThreshold });
    }
  }
  /**
   * Check memory performance
   */
  checkMemoryPerformance() {
    const used = this.metrics.memory.used;
    if (used > this.config.memoryCriticalThreshold) {
      this.addPerformanceAlert("critical", "Memory usage critically high", { used, threshold: this.config.memoryCriticalThreshold });
      this.suggestOptimization("memory", "Consider reducing texture quality or clearing unused assets");
    } else if (used > this.config.memoryWarningThreshold) {
      this.addPerformanceAlert("warning", "Memory usage high", { used, threshold: this.config.memoryWarningThreshold });
    }
  }
  /**
   * Check audio performance
   */
  checkAudioPerformance() {
    if (this.metrics.audio.contextRecreations > 5) {
      this.addPerformanceAlert("warning", "Audio context recreated multiple times", { recreations: this.metrics.audio.contextRecreations });
      this.suggestOptimization("audio", "Consider implementing audio context pooling or lazy initialization");
    }
    if (this.metrics.audio.bufferUnderruns > 10) {
      this.addPerformanceAlert("warning", "Audio buffer underruns detected", { underruns: this.metrics.audio.bufferUnderruns });
    }
  }
  /**
   * Check input performance
   */
  checkInputPerformance() {
    const lag = this.metrics.input.lag;
    if (lag > 100) {
      this.addPerformanceAlert("warning", "Input lag detected", { lag });
      this.suggestOptimization("input", "Consider optimizing input handling or reducing input processing overhead");
    }
  }
  /**
   * Detect memory leaks
   */
  detectMemoryLeaks() {
    const history = this.metrics.memory.history;
    if (history.length < 10) return;
    const recent = history.slice(-10);
    const isIncreasing = recent.every((entry, index) => {
      if (index === 0) return true;
      return entry.used > recent[index - 1].used;
    });
    if (isIncreasing) {
      this.metrics.memory.leakDetected = true;
      this.metrics.memory.leakCount++;
      this.addPerformanceAlert("warning", "Potential memory leak detected", { leakCount: this.metrics.memory.leakCount });
      this.suggestOptimization("memory", "Check for circular references or unremoved event listeners");
    }
  }
  /**
   * Check audio context health
   */
  checkAudioContextHealth() {
    const contextState = "running";
    if (contextState !== this.metrics.audio.contextState) {
      if (this.metrics.audio.contextState === "suspended" && contextState === "running") {
        this.metrics.audio.contextRecreations++;
        this.addPerformanceAlert("info", "Audio context recreated", { recreations: this.metrics.audio.contextRecreations });
      }
      this.metrics.audio.contextState = contextState;
    }
  }
  /**
   * Add performance alert
   */
  addPerformanceAlert(level, message, data) {
    const alert = {
      level,
      message,
      data,
      timestamp: performance.now()
    };
    this.performanceAlerts.push(alert);
    this.eventBus.emit("performance:alert", alert);
    switch (level) {
      case "critical":
        this.logger.error(`Performance Alert: ${message}`, data);
        break;
      case "warning":
        this.logger.warn(`Performance Alert: ${message}`, data);
        break;
      case "info":
        this.logger.info(`Performance Alert: ${message}`, data);
        break;
    }
  }
  /**
   * Suggest optimization
   */
  suggestOptimization(category, suggestion) {
    const optimization = {
      category,
      suggestion,
      timestamp: performance.now()
    };
    this.optimizationSuggestions.push(optimization);
    this.eventBus.emit("performance:optimization", optimization);
    this.logger.info(`Performance Optimization: ${suggestion}`);
  }
  /**
   * Get performance report
   */
  getPerformanceReport() {
    return {
      metrics: this.metrics,
      alerts: this.performanceAlerts,
      suggestions: this.optimizationSuggestions,
      timestamp: performance.now()
    };
  }
  /**
   * Get performance score
   */
  getPerformanceScore() {
    let score = 100;
    const fps = this.metrics.fps.current;
    if (fps < this.config.fpsCriticalThreshold) {
      score -= 40;
    } else if (fps < this.config.fpsWarningThreshold) {
      score -= 20;
    }
    const memoryUsage = this.metrics.memory.used / this.metrics.memory.total;
    if (memoryUsage > 0.9) {
      score -= 30;
    } else if (memoryUsage > 0.7) {
      score -= 15;
    }
    const frameTime = this.metrics.frameTime.current;
    if (frameTime > this.config.frameTimeCriticalThreshold) {
      score -= 20;
    } else if (frameTime > this.config.frameTimeWarningThreshold) {
      score -= 10;
    }
    return Math.max(0, Math.min(100, score));
  }
  /**
   * Handle game started
   */
  handleGameStarted(data) {
    this.startMonitoring();
  }
  /**
   * Handle game paused
   */
  handleGamePaused(data) {
  }
  /**
   * Handle game resumed
   */
  handleGameResumed(data) {
  }
  /**
   * Handle game stopped
   */
  handleGameStopped(data) {
    this.stopMonitoring();
  }
  /**
   * Handle frame event
   */
  handleFrame(data) {
  }
  /**
   * Handle memory update
   */
  handleMemoryUpdate(data) {
    this.updateMemoryMetrics(data);
  }
  /**
   * Handle audio update
   */
  handleAudioUpdate(data) {
    this.updateAudioMetrics(data);
  }
  /**
   * Handle rendering update
   */
  handleRenderingUpdate(data) {
    this.metrics.rendering = { ...this.metrics.rendering, ...data };
  }
  /**
   * Handle input update
   */
  handleInputUpdate(data) {
    this.updateInputMetrics(data.responseTime);
  }
  /**
   * Handle network update
   */
  handleNetworkUpdate(data) {
    this.metrics.network = { ...this.metrics.network, ...data };
  }
  /**
   * Update configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }
  /**
   * Get current metrics
   */
  getMetrics() {
    return this.metrics;
  }
  /**
   * Get alerts
   */
  getAlerts() {
    return this.performanceAlerts;
  }
  /**
   * Get optimization suggestions
   */
  getOptimizationSuggestions() {
    return this.optimizationSuggestions;
  }
  /**
   * Clear alerts
   */
  clearAlerts() {
    this.performanceAlerts = [];
  }
  /**
   * Clear optimization suggestions
   */
  clearOptimizationSuggestions() {
    this.optimizationSuggestions = [];
  }
};

// src/core/InputManager.js
var InputManager = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("InputManager requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("InputManager requires logger dependency");
    }
    this.keys = /* @__PURE__ */ new Map();
    this.mouse = {
      x: 0,
      y: 0,
      buttons: /* @__PURE__ */ new Map(),
      wheel: 0
    };
    this.touch = {
      touches: /* @__PURE__ */ new Map(),
      gestures: /* @__PURE__ */ new Map(),
      activeGestures: /* @__PURE__ */ new Map(),
      lastTapTime: 0,
      lastTapPosition: { x: 0, y: 0 },
      longPressTimer: null,
      doubleTapTimer: null
    };
    this.mobileUI = {
      virtualJoystick: {
        active: false,
        center: { x: 0, y: 0 },
        position: { x: 0, y: 0 },
        radius: 60,
        touchId: null
      },
      actionButtons: /* @__PURE__ */ new Map(),
      isVisible: false,
      orientation: "portrait"
    };
    this.gamepad = {
      controllers: /* @__PURE__ */ new Map(),
      lastUpdate: 0
    };
    this.keyMappings = /* @__PURE__ */ new Map();
    this.mouseMappings = /* @__PURE__ */ new Map();
    this.gamepadMappings = /* @__PURE__ */ new Map();
    this.touchMappings = /* @__PURE__ */ new Map();
    this.accessibility = {
      keyboardNavigation: false,
      focusManagement: true,
      tabOrder: [],
      currentFocusIndex: 0,
      focusableElements: /* @__PURE__ */ new Set(),
      skipLinks: /* @__PURE__ */ new Map()
    };
    this.settings = {
      mouseSensitivity: 1,
      keyboardLayout: "qwerty",
      enableMouseLook: true,
      enableKeyboardNavigation: true,
      enableGamepad: true,
      enableTouch: true,
      invertY: false,
      deadzone: 0.1,
      repeatDelay: 500,
      repeatRate: 50,
      // Mobile-specific settings
      mobileControls: {
        enabled: true,
        layout: "default",
        // 'default', 'compact', 'custom'
        size: "medium",
        // 'small', 'medium', 'large'
        opacity: 0.8,
        position: "bottom",
        // 'bottom', 'top', 'left', 'right', 'custom'
        showLabels: true,
        hapticFeedback: true,
        gestureSensitivity: 1,
        touchDeadzone: 0.05,
        multiTouch: true,
        pinchToZoom: true,
        swipeThreshold: 50,
        longPressDelay: 500,
        doubleTapDelay: 300
      },
      // Touch gesture settings
      gestures: {
        enableSwipe: true,
        enablePinch: true,
        enableRotate: true,
        enableLongPress: true,
        enableDoubleTap: true,
        swipeDirections: ["up", "down", "left", "right"],
        pinchThreshold: 0.1,
        rotateThreshold: 5
        // degrees
      },
      // Mobile UI controls
      mobileUI: {
        showVirtualJoystick: true,
        showActionButtons: true,
        showMenuButton: true,
        showPauseButton: true,
        buttonSpacing: 10,
        buttonSize: 60,
        joystickSize: 120,
        joystickDeadzone: 0.1,
        buttonOpacity: 0.8,
        buttonPressScale: 0.9,
        enableButtonHaptics: true
      }
    };
    this.boundHandlers = /* @__PURE__ */ new Map();
    this.isEnabled = true;
    this.isCaptured = false;
    this.initializeInputMappings();
    this.setupEventHandlers();
    this.setupAccessibility();
    this.setupMobileControls();
    this.logger.info("InputManager initialized");
  }
  /**
   * Initialize the manager
   */
  async initialize() {
    this.logger.info("Initializing InputManager...");
    if (this.config) {
      this.loadSettingsFromConfig();
    }
    this.setupFocusManagement();
    this.logger.info("InputManager initialized successfully");
  }
  /**
   * Cleanup the manager
   */
  cleanup() {
    this.logger.info("Cleaning up InputManager...");
    this.removeEventHandlers();
    this.keys.clear();
    this.mouse.buttons.clear();
    this.touch.touches.clear();
    this.gamepad.controllers.clear();
    this.logger.info("InputManager cleaned up");
  }
  /**
   * Update the manager
   */
  update(deltaTime) {
    if (!this.isEnabled) return;
    this.updateGamepadState();
    this.updateAccessibilityFeatures();
    this.processInputEvents();
  }
  /**
   * Initialize input mappings
   */
  initializeInputMappings() {
    this.keyMappings.set("moveUp", ["KeyW", "ArrowUp"]);
    this.keyMappings.set("moveDown", ["KeyS", "ArrowDown"]);
    this.keyMappings.set("moveLeft", ["KeyA", "ArrowLeft"]);
    this.keyMappings.set("moveRight", ["KeyD", "ArrowRight"]);
    this.keyMappings.set("jump", ["Space"]);
    this.keyMappings.set("crouch", ["KeyC", "ShiftLeft"]);
    this.keyMappings.set("run", ["ShiftLeft"]);
    this.keyMappings.set("interact", ["KeyE", "Enter"]);
    this.keyMappings.set("pause", ["Escape", "KeyP"]);
    this.keyMappings.set("inventory", ["KeyI", "Tab"]);
    this.keyMappings.set("menu", ["Escape", "KeyM"]);
    this.keyMappings.set("confirm", ["Enter", "Space"]);
    this.keyMappings.set("cancel", ["Escape", "Backspace"]);
    this.keyMappings.set("next", ["Tab", "ArrowDown"]);
    this.keyMappings.set("previous", ["ShiftLeft+Tab", "ArrowUp"]);
    this.mouseMappings.set("leftClick", 0);
    this.mouseMappings.set("rightClick", 2);
    this.mouseMappings.set("middleClick", 1);
    this.mouseMappings.set("scrollUp", "wheelUp");
    this.mouseMappings.set("scrollDown", "wheelDown");
    this.gamepadMappings.set("moveUp", "dpadUp");
    this.gamepadMappings.set("moveDown", "dpadDown");
    this.gamepadMappings.set("moveLeft", "dpadLeft");
    this.gamepadMappings.set("moveRight", "dpadRight");
    this.gamepadMappings.set("jump", "buttonA");
    this.gamepadMappings.set("interact", "buttonX");
    this.gamepadMappings.set("pause", "buttonStart");
    this.gamepadMappings.set("menu", "buttonSelect");
    this.gamepadMappings.set("confirm", "buttonA");
    this.gamepadMappings.set("cancel", "buttonB");
    this.touchMappings.set("tap", "tap");
    this.touchMappings.set("doubleTap", "doubleTap");
    this.touchMappings.set("longPress", "longPress");
    this.touchMappings.set("swipe", "swipe");
    this.touchMappings.set("pinch", "pinch");
    this.touchMappings.set("rotate", "rotate");
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.boundHandlers.set("keydown", this.handleKeyDown.bind(this));
    this.boundHandlers.set("keyup", this.handleKeyUp.bind(this));
    this.boundHandlers.set("keypress", this.handleKeyPress.bind(this));
    this.boundHandlers.set("mousedown", this.handleMouseDown.bind(this));
    this.boundHandlers.set("mouseup", this.handleMouseUp.bind(this));
    this.boundHandlers.set("mousemove", this.handleMouseMove.bind(this));
    this.boundHandlers.set("wheel", this.handleWheel.bind(this));
    this.boundHandlers.set("contextmenu", this.handleContextMenu.bind(this));
    this.boundHandlers.set("touchstart", this.handleTouchStart.bind(this));
    this.boundHandlers.set("touchend", this.handleTouchEnd.bind(this));
    this.boundHandlers.set("touchmove", this.handleTouchMove.bind(this));
    this.boundHandlers.set("touchcancel", this.handleTouchCancel.bind(this));
    this.boundHandlers.set(
      "gamepadconnected",
      this.handleGamepadConnected.bind(this)
    );
    this.boundHandlers.set(
      "gamepaddisconnected",
      this.handleGamepadDisconnected.bind(this)
    );
    this.boundHandlers.set("focusin", this.handleFocusIn.bind(this));
    this.boundHandlers.set("focusout", this.handleFocusOut.bind(this));
    this.addEventListeners();
  }
  /**
   * Add event listeners
   */
  addEventListeners() {
    for (const [event, handler] of this.boundHandlers) {
      document.addEventListener(event, handler, { passive: false });
    }
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    for (const [event, handler] of this.boundHandlers) {
      document.removeEventListener(event, handler);
    }
    this.boundHandlers.clear();
  }
  /**
   * Set up accessibility features
   */
  setupAccessibility() {
    if (this.settings.enableKeyboardNavigation) {
      this.accessibility.keyboardNavigation = true;
    }
    this.setupFocusManagement();
  }
  /**
   * Set up focus management
   */
  setupFocusManagement() {
    this.updateFocusableElements();
    this.updateTabOrder();
    this.setupSkipLinks();
  }
  /**
   * Update focusable elements
   */
  updateFocusableElements() {
    this.accessibility.focusableElements.clear();
    const focusableSelectors = [
      "button:not([disabled])",
      "input:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      "a[href]",
      '[tabindex]:not([tabindex="-1"])',
      '[role="button"]:not([disabled])',
      '[role="link"]',
      '[role="menuitem"]',
      '[role="tab"]',
      '[role="option"]'
    ];
    const elements = document.querySelectorAll(focusableSelectors.join(", "));
    elements.forEach((element) => {
      this.accessibility.focusableElements.add(element);
    });
  }
  /**
   * Update tab order
   */
  updateTabOrder() {
    this.accessibility.tabOrder = Array.from(
      this.accessibility.focusableElements
    ).sort((a, b) => {
      const aTabIndex = parseInt(a.getAttribute("tabindex") || "0");
      const bTabIndex = parseInt(b.getAttribute("tabindex") || "0");
      return aTabIndex - bTabIndex;
    });
  }
  /**
   * Set up skip links
   */
  setupSkipLinks() {
    const skipLinks = [
      { id: "skip-main", text: "Skip to main content", target: "main" },
      { id: "skip-nav", text: "Skip to navigation", target: "nav" },
      { id: "skip-content", text: "Skip to content", target: "content" }
    ];
    skipLinks.forEach((link) => {
      this.accessibility.skipLinks.set(link.id, link);
    });
  }
  /**
   * Set up mobile controls
   */
  setupMobileControls() {
    if (!this.settings.enableTouch || !this.settings.mobileControls.enabled) {
      return;
    }
    if (typeof window !== "undefined" && window.navigator && window.navigator.userAgent.includes("jsdom")) {
      this.logger.info("Skipping mobile controls setup in test environment");
      return;
    }
    this.detectMobileDevice();
    this.createMobileUI();
    this.setupOrientationHandling();
    this.setupGestureRecognition();
    this.logger.info("Mobile controls initialized");
  }
  /**
   * Detect mobile device
   */
  detectMobileDevice() {
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    this.isMobile = isMobile || isTouch;
    if (this.isMobile) {
      this.logger.info("Mobile device detected");
    }
  }
  /**
   * Create mobile UI elements
   */
  createMobileUI() {
    if (!this.isMobile) return;
    this.mobileControlsContainer = document.createElement("div");
    this.mobileControlsContainer.id = "mobile-controls";
    this.mobileControlsContainer.className = "mobile-controls";
    this.mobileControlsContainer.style.cssText = `
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 200px;
      pointer-events: none;
      z-index: 1000;
      display: ${this.settings.mobileControls.enabled ? "block" : "none"};
    `;
    if (!this.mobileControlsContainer.nodeType) {
      this.mobileControlsContainer = null;
      return;
    }
    if (this.settings.mobileUI.showVirtualJoystick) {
      this.createVirtualJoystick();
    }
    if (this.settings.mobileUI.showActionButtons) {
      this.createActionButtons();
    }
    if (this.settings.mobileUI.showMenuButton) {
      this.createMenuButton();
    }
    if (this.settings.mobileUI.showPauseButton) {
      this.createPauseButton();
    }
    if (document.body) {
      document.body.appendChild(this.mobileControlsContainer);
    }
  }
  /**
   * Create virtual joystick
   */
  createVirtualJoystick() {
    const joystickContainer = document.createElement("div");
    joystickContainer.className = "virtual-joystick";
    joystickContainer.style.cssText = `
      position: absolute;
      left: 20px;
      bottom: 20px;
      width: ${this.settings.mobileUI.joystickSize}px;
      height: ${this.settings.mobileUI.joystickSize}px;
      pointer-events: auto;
    `;
    const joystickBase = document.createElement("div");
    joystickBase.className = "joystick-base";
    joystickBase.style.cssText = `
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: rgba(255, 255, 255, ${this.settings.mobileUI.buttonOpacity});
      border: 2px solid rgba(0, 0, 0, 0.3);
      position: relative;
    `;
    const joystickKnob = document.createElement("div");
    joystickKnob.className = "joystick-knob";
    joystickKnob.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.5);
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
    `;
    joystickBase.appendChild(joystickKnob);
    joystickContainer.appendChild(joystickBase);
    if (this.mobileControlsContainer) {
      this.mobileControlsContainer.appendChild(joystickContainer);
    }
    this.mobileUI.virtualJoystick.element = joystickContainer;
    this.mobileUI.virtualJoystick.base = joystickBase;
    this.mobileUI.virtualJoystick.knob = joystickKnob;
    this.mobileUI.virtualJoystick.center = {
      x: this.settings.mobileUI.joystickSize / 2,
      y: this.settings.mobileUI.joystickSize / 2
    };
  }
  /**
   * Create action buttons
   */
  createActionButtons() {
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "action-buttons";
    buttonContainer.style.cssText = `
      position: absolute;
      right: 20px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: ${this.settings.mobileUI.buttonSpacing}px;
      pointer-events: auto;
    `;
    const buttons = [
      { id: "jump", label: "Jump", key: "Space" },
      { id: "interact", label: "Interact", key: "KeyE" },
      { id: "crouch", label: "Crouch", key: "KeyC" },
      { id: "run", label: "Run", key: "ShiftLeft" }
    ];
    buttons.forEach((button) => {
      const buttonElement = document.createElement("button");
      buttonElement.className = `action-button ${button.id}`;
      buttonElement.textContent = this.settings.mobileControls.showLabels ? button.label : "";
      buttonElement.style.cssText = `
        width: ${this.settings.mobileUI.buttonSize}px;
        height: ${this.settings.mobileUI.buttonSize}px;
        border-radius: 50%;
        background: rgba(255, 255, 255, ${this.settings.mobileUI.buttonOpacity});
        border: 2px solid rgba(0, 0, 0, 0.3);
        color: #000;
        font-size: 12px;
        font-weight: bold;
        cursor: pointer;
        user-select: none;
        transition: transform 0.1s ease;
      `;
      buttonElement.addEventListener("touchstart", (e) => {
        e.preventDefault();
        this.handleMobileButtonPress(button.id, button.key, "down");
        buttonElement.style.transform = `scale(${this.settings.mobileUI.buttonPressScale})`;
      });
      buttonElement.addEventListener("touchend", (e) => {
        e.preventDefault();
        this.handleMobileButtonPress(button.id, button.key, "up");
        buttonElement.style.transform = "scale(1)";
      });
      buttonContainer.appendChild(buttonElement);
      this.mobileUI.actionButtons.set(button.id, buttonElement);
    });
    if (this.mobileControlsContainer) {
      this.mobileControlsContainer.appendChild(buttonContainer);
    }
  }
  /**
   * Create menu button
   */
  createMenuButton() {
    const menuButton = document.createElement("button");
    menuButton.className = "menu-button";
    menuButton.innerHTML = "";
    menuButton.style.cssText = `
      position: absolute;
      top: 20px;
      right: 20px;
      width: ${this.settings.mobileUI.buttonSize}px;
      height: ${this.settings.mobileUI.buttonSize}px;
      border-radius: 50%;
      background: rgba(255, 255, 255, ${this.settings.mobileUI.buttonOpacity});
      border: 2px solid rgba(0, 0, 0, 0.3);
      color: #000;
      font-size: 20px;
      cursor: pointer;
      pointer-events: auto;
      user-select: none;
    `;
    menuButton.addEventListener("touchstart", (e) => {
      e.preventDefault();
      this.handleMobileButtonPress("menu", "KeyM", "down");
    });
    if (this.mobileControlsContainer) {
      this.mobileControlsContainer.appendChild(menuButton);
    }
  }
  /**
   * Create pause button
   */
  createPauseButton() {
    const pauseButton = document.createElement("button");
    pauseButton.className = "pause-button";
    pauseButton.innerHTML = "";
    pauseButton.style.cssText = `
      position: absolute;
      top: 20px;
      left: 20px;
      width: ${this.settings.mobileUI.buttonSize}px;
      height: ${this.settings.mobileUI.buttonSize}px;
      border-radius: 50%;
      background: rgba(255, 255, 255, ${this.settings.mobileUI.buttonOpacity});
      border: 2px solid rgba(0, 0, 0, 0.3);
      color: #000;
      font-size: 20px;
      cursor: pointer;
      pointer-events: auto;
      user-select: none;
    `;
    pauseButton.addEventListener("touchstart", (e) => {
      e.preventDefault();
      this.handleMobileButtonPress("pause", "Escape", "down");
    });
    if (this.mobileControlsContainer) {
      this.mobileControlsContainer.appendChild(pauseButton);
    }
  }
  /**
   * Set up orientation handling
   */
  setupOrientationHandling() {
    const updateOrientation = () => {
      const isPortrait = window.innerHeight > window.innerWidth;
      this.mobileUI.orientation = isPortrait ? "portrait" : "landscape";
      this.adjustMobileControlsForOrientation();
    };
    window.addEventListener("orientationchange", updateOrientation);
    window.addEventListener("resize", updateOrientation);
    updateOrientation();
  }
  /**
   * Adjust mobile controls for orientation
   */
  adjustMobileControlsForOrientation() {
    if (!this.mobileControlsContainer) return;
    if (this.mobileUI.orientation === "landscape") {
      this.mobileControlsContainer.style.height = "150px";
    } else {
      this.mobileControlsContainer.style.height = "200px";
    }
  }
  /**
   * Set up gesture recognition
   */
  setupGestureRecognition() {
    if (!this.settings.gestures.enableSwipe && !this.settings.gestures.enablePinch && !this.settings.gestures.enableRotate) {
      return;
    }
    this.setupBasicGestureDetection();
  }
  /**
   * Set up basic gesture detection
   */
  setupBasicGestureDetection() {
    let startTouches = [];
    let startDistance = 0;
    let startAngle = 0;
    const handleTouchStart = (e) => {
      startTouches = Array.from(e.touches);
      if (startTouches.length === 2) {
        startDistance = this.getDistance(startTouches[0], startTouches[1]);
        startAngle = this.getAngle(startTouches[0], startTouches[1]);
      }
    };
    const handleTouchMove = (e) => {
      if (e.touches.length === 2 && this.settings.gestures.enablePinch) {
        const currentDistance = this.getDistance(e.touches[0], e.touches[1]);
        const scale = currentDistance / startDistance;
        if (Math.abs(scale - 1) > this.settings.gestures.pinchThreshold) {
          this.handlePinchGesture(scale);
        }
      }
      if (e.touches.length === 2 && this.settings.gestures.enableRotate) {
        const currentAngle = this.getAngle(e.touches[0], e.touches[1]);
        const rotation = currentAngle - startAngle;
        if (Math.abs(rotation) > this.settings.gestures.rotateThreshold) {
          this.handleRotateGesture(rotation);
        }
      }
    };
    const handleTouchEnd = (e) => {
      if (e.touches.length === 0 && startTouches.length === 1) {
        this.checkForSwipe(startTouches[0], e.changedTouches[0]);
      }
    };
    document.addEventListener("touchstart", handleTouchStart, { passive: true });
    document.addEventListener("touchmove", handleTouchMove, { passive: true });
    document.addEventListener("touchend", handleTouchEnd, { passive: true });
  }
  /**
   * Handle keyboard down events
   */
  handleKeyDown(event) {
    if (!this.isEnabled) return;
    const key = event.code;
    const keyName = this.getKeyName(key);
    this.keys.set(key, {
      pressed: true,
      timestamp: Date.now(),
      repeat: this.keys.has(key)
    });
    if (this.accessibility.keyboardNavigation) {
      this.handleAccessibilityKeyDown(event);
    }
    this.eventBus.emit("input:keyDown", {
      key,
      keyName,
      code: event.code,
      keyCode: event.keyCode,
      repeat: this.keys.get(key).repeat,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      timestamp: Date.now()
    });
    this.handleMappedAction("keyboard", key, "down", event);
  }
  /**
   * Handle keyboard up events
   */
  handleKeyUp(event) {
    if (!this.isEnabled) return;
    const key = event.code;
    const keyName = this.getKeyName(key);
    this.keys.set(key, {
      pressed: false,
      timestamp: Date.now(),
      repeat: false
    });
    this.eventBus.emit("input:keyUp", {
      key,
      keyName,
      code: event.code,
      keyCode: event.keyCode,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      timestamp: Date.now()
    });
    this.handleMappedAction("keyboard", key, "up", event);
  }
  /**
   * Handle keyboard press events
   */
  handleKeyPress(event) {
    if (!this.isEnabled) return;
    const key = event.key;
    const charCode = event.charCode;
    this.eventBus.emit("input:keyPress", {
      key,
      charCode,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      timestamp: Date.now()
    });
  }
  /**
   * Handle mouse down events
   */
  handleMouseDown(event) {
    if (!this.isEnabled) return;
    const button = event.button;
    const buttonName = this.getMouseButtonName(button);
    this.mouse.buttons.set(button, {
      pressed: true,
      timestamp: Date.now()
    });
    this.mouse.x = event.clientX;
    this.mouse.y = event.clientY;
    this.eventBus.emit("input:mouseDown", {
      button,
      buttonName,
      x: event.clientX,
      y: event.clientY,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      timestamp: Date.now()
    });
    this.handleMappedAction("mouse", button, "down", event);
  }
  /**
   * Handle mouse up events
   */
  handleMouseUp(event) {
    if (!this.isEnabled) return;
    const button = event.button;
    const buttonName = this.getMouseButtonName(button);
    this.mouse.buttons.set(button, {
      pressed: false,
      timestamp: Date.now()
    });
    this.mouse.x = event.clientX;
    this.mouse.y = event.clientY;
    this.eventBus.emit("input:mouseUp", {
      button,
      buttonName,
      x: event.clientX,
      y: event.clientY,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      timestamp: Date.now()
    });
    this.handleMappedAction("mouse", button, "up", event);
  }
  /**
   * Handle mouse move events
   */
  handleMouseMove(event) {
    if (!this.isEnabled) return;
    const deltaX = event.clientX - this.mouse.x;
    const deltaY = event.clientY - this.mouse.y;
    this.mouse.x = event.clientX;
    this.mouse.y = event.clientY;
    const sensitivity = this.settings.mouseSensitivity;
    const adjustedDeltaX = deltaX * sensitivity;
    const adjustedDeltaY = this.settings.invertY ? -deltaY * sensitivity : deltaY * sensitivity;
    this.eventBus.emit("input:mouseMove", {
      x: event.clientX,
      y: event.clientY,
      deltaX: adjustedDeltaX,
      deltaY: adjustedDeltaY,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      timestamp: Date.now()
    });
  }
  /**
   * Handle wheel events
   */
  handleWheel(event) {
    if (!this.isEnabled) return;
    const deltaY = event.deltaY;
    const direction = deltaY > 0 ? "down" : "up";
    this.mouse.wheel = deltaY;
    this.eventBus.emit("input:wheel", {
      deltaY,
      direction,
      x: event.clientX,
      y: event.clientY,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      timestamp: Date.now()
    });
    this.handleMappedAction("mouse", direction, "wheel", event);
  }
  /**
   * Handle context menu events
   */
  handleContextMenu(event) {
    if (!this.isEnabled) return;
    if (this.isCaptured) {
      event.preventDefault();
    }
    this.eventBus.emit("input:contextMenu", {
      x: event.clientX,
      y: event.clientY,
      timestamp: Date.now()
    });
  }
  /**
   * Handle touch start events
   */
  handleTouchStart(event) {
    if (!this.isEnabled || !this.settings.enableTouch) return;
    event.preventDefault();
    for (const touch of event.changedTouches) {
      this.touch.touches.set(touch.identifier, {
        x: touch.clientX,
        y: touch.clientY,
        startX: touch.clientX,
        startY: touch.clientY,
        startTime: Date.now(),
        pressure: touch.force || 1
      });
      if (this.isMobile) {
        this.handleMobileTouchStart(touch, event);
      }
    }
    this.eventBus.emit("input:touchStart", {
      touches: Array.from(event.changedTouches).map((touch) => ({
        id: touch.identifier,
        x: touch.clientX,
        y: touch.clientY,
        pressure: touch.force || 1
      })),
      timestamp: Date.now()
    });
  }
  /**
   * Handle touch end events
   */
  handleTouchEnd(event) {
    if (!this.isEnabled || !this.settings.enableTouch) return;
    event.preventDefault();
    for (const touch of event.changedTouches) {
      if (this.isMobile) {
        this.handleMobileTouchEnd(touch, event);
      }
      this.touch.touches.delete(touch.identifier);
    }
    this.eventBus.emit("input:touchEnd", {
      touches: Array.from(event.changedTouches).map((touch) => ({
        id: touch.identifier,
        x: touch.clientX,
        y: touch.clientY
      })),
      timestamp: Date.now()
    });
  }
  /**
   * Handle touch move events
   */
  handleTouchMove(event) {
    if (!this.isEnabled || !this.settings.enableTouch) return;
    event.preventDefault();
    for (const touch of event.changedTouches) {
      if (this.touch.touches.has(touch.identifier)) {
        const touchData = this.touch.touches.get(touch.identifier);
        touchData.x = touch.clientX;
        touchData.y = touch.clientY;
        if (this.isMobile) {
          this.handleMobileTouchMove(touch, event);
        }
      }
    }
    this.eventBus.emit("input:touchMove", {
      touches: Array.from(event.changedTouches).map((touch) => ({
        id: touch.identifier,
        x: touch.clientX,
        y: touch.clientY,
        pressure: touch.force || 1
      })),
      timestamp: Date.now()
    });
  }
  /**
   * Handle touch cancel events
   */
  handleTouchCancel(event) {
    if (!this.isEnabled || !this.settings.enableTouch) return;
    for (const touch of event.changedTouches) {
      this.touch.touches.delete(touch.identifier);
    }
    this.eventBus.emit("input:touchCancel", {
      touches: Array.from(event.changedTouches).map((touch) => ({
        id: touch.identifier,
        x: touch.clientX,
        y: touch.clientY
      })),
      timestamp: Date.now()
    });
  }
  /**
   * Handle gamepad connected events
   */
  handleGamepadConnected(event) {
    if (!this.settings.enableGamepad) return;
    const gamepad = event.gamepad;
    this.gamepad.controllers.set(gamepad.index, {
      id: gamepad.id,
      index: gamepad.index,
      connected: true,
      buttons: /* @__PURE__ */ new Map(),
      axes: /* @__PURE__ */ new Map()
    });
    this.logger.info(`Gamepad connected: ${gamepad.id}`);
    this.eventBus.emit("input:gamepadConnected", {
      id: gamepad.id,
      index: gamepad.index,
      timestamp: Date.now()
    });
  }
  /**
   * Handle gamepad disconnected events
   */
  handleGamepadDisconnected(event) {
    const gamepad = event.gamepad;
    this.gamepad.controllers.delete(gamepad.index);
    this.logger.info(`Gamepad disconnected: ${gamepad.id}`);
    this.eventBus.emit("input:gamepadDisconnected", {
      id: gamepad.id,
      index: gamepad.index,
      timestamp: Date.now()
    });
  }
  /**
   * Handle focus in events
   */
  handleFocusIn(event) {
    if (!this.accessibility.focusManagement) return;
    const element = event.target;
    const index = this.accessibility.tabOrder.indexOf(element);
    if (index !== -1) {
      this.accessibility.currentFocusIndex = index;
    }
    this.eventBus.emit("input:focusIn", {
      element,
      index,
      timestamp: Date.now()
    });
  }
  /**
   * Handle focus out events
   */
  handleFocusOut(event) {
    if (!this.accessibility.focusManagement) return;
    const element = event.target;
    this.eventBus.emit("input:focusOut", {
      element,
      timestamp: Date.now()
    });
  }
  /**
   * Handle accessibility key down events
   */
  handleAccessibilityKeyDown(event) {
    const key = event.key;
    switch (key) {
      case "Tab":
        this.handleTabNavigation(event);
        break;
      case "Enter":
      case " ":
        this.handleActivation(event);
        break;
      case "Escape":
        this.handleEscape(event);
        break;
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
        this.handleArrowNavigation(event);
        break;
    }
  }
  /**
   * Handle tab navigation
   */
  handleTabNavigation(event) {
    if (this.accessibility.tabOrder.length === 0) return;
    const direction = event.shiftKey ? -1 : 1;
    const newIndex = (this.accessibility.currentFocusIndex + direction + this.accessibility.tabOrder.length) % this.accessibility.tabOrder.length;
    const nextElement = this.accessibility.tabOrder[newIndex];
    if (nextElement) {
      nextElement.focus();
      this.accessibility.currentFocusIndex = newIndex;
    }
  }
  /**
   * Handle activation
   */
  handleActivation(event) {
    const element = document.activeElement;
    if (element && element.click) {
      element.click();
    }
  }
  /**
   * Handle escape key
   */
  handleEscape(event) {
    this.eventBus.emit("input:escape", {
      timestamp: Date.now()
    });
  }
  /**
   * Handle arrow navigation
   */
  handleArrowNavigation(event) {
    this.eventBus.emit("input:arrowNavigation", {
      direction: event.key.replace("Arrow", "").toLowerCase(),
      timestamp: Date.now()
    });
  }
  /**
   * Update gamepad state
   */
  updateGamepadState() {
    if (!this.settings.enableGamepad) return;
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
      const gamepad = gamepads[i];
      if (!gamepad) continue;
      const controller = this.gamepad.controllers.get(i);
      if (!controller) continue;
      for (let j = 0; j < gamepad.buttons.length; j++) {
        const button = gamepad.buttons[j];
        const wasPressed = controller.buttons.get(j)?.pressed || false;
        const isPressed = button.pressed;
        if (isPressed !== wasPressed) {
          controller.buttons.set(j, {
            pressed: isPressed,
            value: button.value,
            timestamp: Date.now()
          });
          this.eventBus.emit("input:gamepadButton", {
            controller: i,
            button: j,
            pressed: isPressed,
            value: button.value,
            timestamp: Date.now()
          });
        }
      }
      for (let j = 0; j < gamepad.axes.length; j++) {
        const axis = gamepad.axes[j];
        const previousAxis = controller.axes.get(j) || 0;
        const deadzone = this.settings.deadzone;
        const adjustedAxis = Math.abs(axis) < deadzone ? 0 : axis;
        if (Math.abs(adjustedAxis - previousAxis) > 0.01) {
          controller.axes.set(j, adjustedAxis);
          this.eventBus.emit("input:gamepadAxis", {
            controller: i,
            axis: j,
            value: adjustedAxis,
            timestamp: Date.now()
          });
        }
      }
    }
  }
  /**
   * Update accessibility features
   */
  updateAccessibilityFeatures() {
    this.updateFocusableElements();
    this.updateTabOrder();
  }
  /**
   * Process input events
   */
  processInputEvents() {
  }
  /**
   * Handle mapped actions
   */
  handleMappedAction(inputType, input, action, event) {
    let mapping;
    switch (inputType) {
      case "keyboard":
        mapping = this.keyMappings;
        break;
      case "mouse":
        mapping = this.mouseMappings;
        break;
      case "gamepad":
        mapping = this.gamepadMappings;
        break;
      case "touch":
        mapping = this.touchMappings;
        break;
      default:
        return;
    }
    for (const [actionName, inputs] of mapping) {
      if (inputs.includes(input)) {
        this.eventBus.emit("input:action", {
          action: actionName,
          inputType,
          input,
          state: action,
          event,
          timestamp: Date.now()
        });
      }
    }
  }
  /**
   * Get key name from key code
   */
  getKeyName(keyCode) {
    const keyNames = {
      KeyA: "A",
      KeyB: "B",
      KeyC: "C",
      KeyD: "D",
      KeyE: "E",
      KeyF: "F",
      KeyG: "G",
      KeyH: "H",
      KeyI: "I",
      KeyJ: "J",
      KeyK: "K",
      KeyL: "L",
      KeyM: "M",
      KeyN: "N",
      KeyO: "O",
      KeyP: "P",
      KeyQ: "Q",
      KeyR: "R",
      KeyS: "S",
      KeyT: "T",
      KeyU: "U",
      KeyV: "V",
      KeyW: "W",
      KeyX: "X",
      KeyY: "Y",
      KeyZ: "Z",
      Digit0: "0",
      Digit1: "1",
      Digit2: "2",
      Digit3: "3",
      Digit4: "4",
      Digit5: "5",
      Digit6: "6",
      Digit7: "7",
      Digit8: "8",
      Digit9: "9",
      Space: "Space",
      Enter: "Enter",
      Escape: "Escape",
      Backspace: "Backspace",
      Tab: "Tab",
      ShiftLeft: "Left Shift",
      ShiftRight: "Right Shift",
      ControlLeft: "Left Ctrl",
      ControlRight: "Right Ctrl",
      AltLeft: "Left Alt",
      AltRight: "Right Alt",
      ArrowUp: "Up Arrow",
      ArrowDown: "Down Arrow",
      ArrowLeft: "Left Arrow",
      ArrowRight: "Right Arrow"
    };
    return keyNames[keyCode] || keyCode;
  }
  /**
   * Get mouse button name
   */
  getMouseButtonName(button) {
    const buttonNames = {
      0: "Left",
      1: "Middle",
      2: "Right",
      3: "Back",
      4: "Forward"
    };
    return buttonNames[button] || `Button ${button}`;
  }
  /**
   * Load settings from config
   */
  loadSettingsFromConfig() {
    if (!this.config) return;
    this.settings = {
      ...this.settings,
      mouseSensitivity: this.config.getConfigValue("input.mouseSensitivity") || this.settings.mouseSensitivity,
      keyboardLayout: this.config.getConfigValue("input.keyboardLayout") || this.settings.keyboardLayout,
      enableMouseLook: this.config.getConfigValue("input.enableMouseLook") ?? this.settings.enableMouseLook,
      enableKeyboardNavigation: this.config.getConfigValue("input.enableKeyboardNavigation") ?? this.settings.enableKeyboardNavigation,
      enableGamepad: this.config.getConfigValue("input.enableGamepad") ?? this.settings.enableGamepad,
      enableTouch: this.config.getConfigValue("input.enableTouch") ?? this.settings.enableTouch,
      invertY: this.config.getConfigValue("input.invertY") ?? this.settings.invertY,
      deadzone: this.config.getConfigValue("input.deadzone") || this.settings.deadzone
    };
  }
  /**
   * Enable input
   */
  enable() {
    this.isEnabled = true;
    this.logger.info("Input enabled");
  }
  /**
   * Disable input
   */
  disable() {
    this.isEnabled = false;
    this.logger.info("Input disabled");
  }
  /**
   * Capture input
   */
  capture() {
    this.isCaptured = true;
    document.body.style.cursor = "none";
    this.logger.info("Input captured");
  }
  /**
   * Release input
   */
  release() {
    this.isCaptured = false;
    document.body.style.cursor = "default";
    this.logger.info("Input released");
  }
  /**
   * Get input state
   */
  getInputState() {
    return {
      keyboard: Object.fromEntries(this.keys),
      mouse: this.mouse,
      touch: Object.fromEntries(this.touch.touches),
      gamepad: Object.fromEntries(this.gamepad.controllers),
      accessibility: this.accessibility
    };
  }
  /**
   * Set key mapping
   */
  setKeyMapping(action, keys) {
    this.keyMappings.set(action, keys);
  }
  /**
   * Get key mapping
   */
  getKeyMapping(action) {
    return this.keyMappings.get(action) || [];
  }
  /**
   * Check if key is pressed
   */
  isKeyPressed(key) {
    const keyState = this.keys.get(key);
    return keyState ? keyState.pressed : false;
  }
  /**
   * Check if mouse button is pressed
   */
  isMouseButtonPressed(button) {
    const buttonState = this.mouse.buttons.get(button);
    return buttonState ? buttonState.pressed : false;
  }
  /**
   * Get mouse position
   */
  getMousePosition() {
    return { x: this.mouse.x, y: this.mouse.y };
  }
  /**
   * Get gamepad state
   */
  getGamepadState(index) {
    return this.gamepad.controllers.get(index);
  }
  /**
   * Get all gamepads
   */
  getAllGamepads() {
    return Array.from(this.gamepad.controllers.values());
  }
  /**
   * Handle mobile touch start
   */
  handleMobileTouchStart(touch, event) {
    if (this.isTouchOnVirtualJoystick(touch)) {
      this.activateVirtualJoystick(touch);
      return;
    }
    const button = this.getTouchedButton(touch);
    if (button) {
      this.handleMobileButtonPress(button.id, button.key, "down");
      return;
    }
    this.handleGestureStart(touch, event);
  }
  /**
   * Handle mobile touch move
   */
  handleMobileTouchMove(touch, event) {
    if (this.mobileUI.virtualJoystick.active && this.mobileUI.virtualJoystick.touchId === touch.identifier) {
      this.updateVirtualJoystick(touch);
    }
    this.handleGestureMove(touch, event);
  }
  /**
   * Handle mobile touch end
   */
  handleMobileTouchEnd(touch, event) {
    if (this.mobileUI.virtualJoystick.active && this.mobileUI.virtualJoystick.touchId === touch.identifier) {
      this.deactivateVirtualJoystick();
    }
    this.handleGestureEnd(touch, event);
  }
  /**
   * Check if touch is on virtual joystick
   */
  isTouchOnVirtualJoystick(touch) {
    if (!this.mobileUI.virtualJoystick.element) return false;
    const rect = this.mobileUI.virtualJoystick.element.getBoundingClientRect();
    return touch.clientX >= rect.left && touch.clientX <= rect.right && touch.clientY >= rect.top && touch.clientY <= rect.bottom;
  }
  /**
   * Activate virtual joystick
   */
  activateVirtualJoystick(touch) {
    this.mobileUI.virtualJoystick.active = true;
    this.mobileUI.virtualJoystick.touchId = touch.identifier;
    const rect = this.mobileUI.virtualJoystick.element.getBoundingClientRect();
    this.mobileUI.virtualJoystick.center = {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2
    };
    this.logger.info("Virtual joystick activated");
  }
  /**
   * Update virtual joystick
   */
  updateVirtualJoystick(touch) {
    if (!this.mobileUI.virtualJoystick.active) return;
    const center = this.mobileUI.virtualJoystick.center;
    const deltaX = touch.clientX - center.x;
    const deltaY = touch.clientY - center.y;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const maxDistance = this.settings.mobileUI.joystickSize / 2;
    const clampedDistance = Math.min(distance, maxDistance);
    const angle = Math.atan2(deltaY, deltaX);
    const knobX = Math.cos(angle) * clampedDistance;
    const knobY = Math.sin(angle) * clampedDistance;
    if (this.mobileUI.virtualJoystick.knob) {
      this.mobileUI.virtualJoystick.knob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
    }
    const normalizedX = deltaX / maxDistance;
    const normalizedY = deltaY / maxDistance;
    const deadzone = this.settings.mobileUI.joystickDeadzone;
    const finalX = Math.abs(normalizedX) < deadzone ? 0 : normalizedX;
    const finalY = Math.abs(normalizedY) < deadzone ? 0 : normalizedY;
    this.eventBus.emit("input:joystickMove", {
      x: finalX,
      y: finalY,
      angle: angle * 180 / Math.PI,
      distance: clampedDistance / maxDistance,
      timestamp: Date.now()
    });
    this.mapJoystickToKeyboard(finalX, finalY);
  }
  /**
   * Deactivate virtual joystick
   */
  deactivateVirtualJoystick() {
    this.mobileUI.virtualJoystick.active = false;
    this.mobileUI.virtualJoystick.touchId = null;
    if (this.mobileUI.virtualJoystick.knob) {
      this.mobileUI.virtualJoystick.knob.style.transform = "translate(-50%, -50%)";
    }
    this.eventBus.emit("input:joystickRelease", {
      timestamp: Date.now()
    });
    this.logger.info("Virtual joystick deactivated");
  }
  /**
   * Map joystick movement to keyboard events
   */
  mapJoystickToKeyboard(x, y) {
    const threshold = 0.3;
    if (x > threshold) {
      this.handleMappedAction("keyboard", "KeyD", "down", { synthetic: true });
    } else if (x < -threshold) {
      this.handleMappedAction("keyboard", "KeyA", "down", { synthetic: true });
    }
    if (y > threshold) {
      this.handleMappedAction("keyboard", "KeyS", "down", { synthetic: true });
    } else if (y < -threshold) {
      this.handleMappedAction("keyboard", "KeyW", "down", { synthetic: true });
    }
  }
  /**
   * Get touched button
   */
  getTouchedButton(touch) {
    for (const [id, button] of this.mobileUI.actionButtons) {
      const rect = button.getBoundingClientRect();
      if (touch.clientX >= rect.left && touch.clientX <= rect.right && touch.clientY >= rect.top && touch.clientY <= rect.bottom) {
        return { id, key: this.getButtonKey(id) };
      }
    }
    return null;
  }
  /**
   * Get button key mapping
   */
  getButtonKey(buttonId) {
    const keyMap = {
      jump: "Space",
      interact: "KeyE",
      crouch: "KeyC",
      run: "ShiftLeft",
      menu: "KeyM",
      pause: "Escape"
    };
    return keyMap[buttonId] || null;
  }
  /**
   * Handle mobile button press
   */
  handleMobileButtonPress(buttonId, key, action) {
    if (this.settings.mobileControls.hapticFeedback && navigator.vibrate) {
      navigator.vibrate(50);
    }
    this.eventBus.emit("input:mobileButton", {
      buttonId,
      key,
      action,
      timestamp: Date.now()
    });
    if (key) {
      this.handleMappedAction("keyboard", key, action, { synthetic: true });
    }
    this.logger.info(`Mobile button ${action}: ${buttonId}`);
  }
  /**
   * Handle gesture start
   */
  handleGestureStart(touch, event) {
    const currentTime = Date.now();
    if (this.settings.gestures.enableDoubleTap) {
      const timeDiff = currentTime - this.touch.lastTapTime;
      const distance = this.getDistance(touch, this.touch.lastTapPosition);
      if (timeDiff < this.settings.mobileControls.doubleTapDelay && distance < 50) {
        this.handleDoubleTap(touch);
        return;
      }
    }
    if (this.settings.gestures.enableLongPress) {
      this.touch.longPressTimer = setTimeout(() => {
        this.handleLongPress(touch);
      }, this.settings.mobileControls.longPressDelay);
    }
    this.touch.lastTapTime = currentTime;
    this.touch.lastTapPosition = { x: touch.clientX, y: touch.clientY };
  }
  /**
   * Handle gesture move
   */
  handleGestureMove(touch, event) {
    if (this.touch.longPressTimer) {
      clearTimeout(this.touch.longPressTimer);
      this.touch.longPressTimer = null;
    }
  }
  /**
   * Handle gesture end
   */
  handleGestureEnd(touch, event) {
    if (this.touch.longPressTimer) {
      clearTimeout(this.touch.longPressTimer);
      this.touch.longPressTimer = null;
    }
    if (this.settings.gestures.enableSwipe) {
      this.checkForSwipe(touch, touch);
    }
  }
  /**
   * Check for swipe gesture
   */
  checkForSwipe(startTouch, endTouch) {
    const deltaX = endTouch.clientX - startTouch.startX;
    const deltaY = endTouch.clientY - startTouch.startY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    if (distance < this.settings.mobileControls.swipeThreshold) {
      return;
    }
    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
    let direction = "";
    if (angle > -45 && angle <= 45) {
      direction = "right";
    } else if (angle > 45 && angle <= 135) {
      direction = "down";
    } else if (angle > 135 || angle <= -135) {
      direction = "left";
    } else if (angle > -135 && angle <= -45) {
      direction = "up";
    }
    if (this.settings.gestures.swipeDirections.includes(direction)) {
      this.handleSwipeGesture(direction, distance);
    }
  }
  /**
   * Handle swipe gesture
   */
  handleSwipeGesture(direction, distance) {
    this.eventBus.emit("input:swipe", {
      direction,
      distance,
      timestamp: Date.now()
    });
    this.logger.info(`Swipe detected: ${direction}`);
  }
  /**
   * Handle pinch gesture
   */
  handlePinchGesture(scale) {
    this.eventBus.emit("input:pinch", {
      scale,
      timestamp: Date.now()
    });
    this.logger.info(`Pinch detected: ${scale.toFixed(2)}`);
  }
  /**
   * Handle rotate gesture
   */
  handleRotateGesture(rotation) {
    this.eventBus.emit("input:rotate", {
      rotation,
      timestamp: Date.now()
    });
    this.logger.info(`Rotate detected: ${rotation.toFixed(2)}`);
  }
  /**
   * Handle double tap
   */
  handleDoubleTap(touch) {
    this.eventBus.emit("input:doubleTap", {
      x: touch.clientX,
      y: touch.clientY,
      timestamp: Date.now()
    });
    this.logger.info("Double tap detected");
  }
  /**
   * Handle long press
   */
  handleLongPress(touch) {
    this.eventBus.emit("input:longPress", {
      x: touch.clientX,
      y: touch.clientY,
      timestamp: Date.now()
    });
    this.logger.info("Long press detected");
  }
  /**
   * Get distance between two touch points
   */
  getDistance(touch1, touch2) {
    const dx = touch1.clientX - touch2.clientX;
    const dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Get angle between two touch points
   */
  getAngle(touch1, touch2) {
    return Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX);
  }
  /**
   * Update mobile controls visibility
   */
  updateMobileControlsVisibility(visible) {
    this.mobileUI.isVisible = visible;
    if (this.mobileControlsContainer) {
      this.mobileControlsContainer.style.display = visible ? "block" : "none";
    }
  }
  /**
   * Update mobile controls settings
   */
  updateMobileSettings(newSettings) {
    this.settings.mobileControls = { ...this.settings.mobileControls, ...newSettings };
    this.settings.gestures = { ...this.settings.gestures, ...newSettings.gestures };
    this.settings.mobileUI = { ...this.settings.mobileUI, ...newSettings.mobileUI };
    if (this.mobileControlsContainer) {
      this.mobileControlsContainer.remove();
      this.createMobileUI();
    }
    this.logger.info("Mobile settings updated");
  }
  /**
   * Get mobile controls state
   */
  getMobileControlsState() {
    return {
      isMobile: this.isMobile,
      isVisible: this.mobileUI.isVisible,
      orientation: this.mobileUI.orientation,
      virtualJoystick: {
        active: this.mobileUI.virtualJoystick.active,
        position: this.mobileUI.virtualJoystick.position
      },
      settings: {
        mobileControls: this.settings.mobileControls,
        gestures: this.settings.gestures,
        mobileUI: this.settings.mobileUI
      }
    };
  }
};

// src/utils/MobileTesting.js
var MobileTesting = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.inputManager = dependencies.inputManager;
    this.performanceMonitor = dependencies.performanceMonitor;
    this.config = {
      enableAutoTesting: true,
      testInterval: 5e3,
      gestureTestTimeout: 2e3,
      performanceTestDuration: 1e4,
      enableAccessibilityTesting: true,
      enablePerformanceTesting: true,
      enableGestureTesting: true,
      enableControlTesting: true,
      ...dependencies.config
    };
    this.isTesting = false;
    this.testResults = {
      device: null,
      gestures: /* @__PURE__ */ new Map(),
      controls: /* @__PURE__ */ new Map(),
      performance: null,
      accessibility: null,
      overall: null
    };
    this.testListeners = /* @__PURE__ */ new Map();
    this.logger.info("MobileTesting initialized");
  }
  /**
   * Initialize the testing utility
   */
  async initialize() {
    this.logger.info("Initializing MobileTesting...");
    this.detectMobileDevice();
    this.setupTestListeners();
    if (this.config.enableAutoTesting) {
      this.startAutoTesting();
    }
    this.logger.info("MobileTesting initialized successfully");
  }
  /**
   * Cleanup the testing utility
   */
  cleanup() {
    this.logger.info("Cleaning up MobileTesting...");
    this.stopAutoTesting();
    this.removeTestListeners();
    this.logger.info("MobileTesting cleaned up");
  }
  /**
   * Detect mobile device and capabilities
   */
  detectMobileDevice() {
    const userAgent = navigator.userAgent;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    const isTablet = /iPad|Android/i.test(userAgent) && "ontouchstart" in window;
    this.testResults.device = {
      isMobile,
      isTouch,
      isTablet,
      userAgent,
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      viewportWidth: window.innerWidth,
      viewportHeight: window.innerHeight,
      pixelRatio: window.devicePixelRatio || 1,
      orientation: window.innerHeight > window.innerWidth ? "portrait" : "landscape",
      maxTouchPoints: navigator.maxTouchPoints || 0,
      hasVibration: "vibrate" in navigator,
      hasHaptics: "vibrate" in navigator,
      hasGeolocation: "geolocation" in navigator,
      hasCamera: "mediaDevices" in navigator && "getUserMedia" in navigator.mediaDevices,
      hasAccelerometer: "DeviceMotionEvent" in window,
      hasGyroscope: "DeviceOrientationEvent" in window
    };
    this.logger.info("Mobile device detected:", this.testResults.device);
  }
  /**
   * Set up test listeners
   */
  setupTestListeners() {
    if (this.config.enableGestureTesting) {
      this.setupGestureTestListeners();
    }
    if (this.config.enableControlTesting) {
      this.setupControlTestListeners();
    }
    if (this.config.enablePerformanceTesting) {
      this.setupPerformanceTestListeners();
    }
    if (this.config.enableAccessibilityTesting) {
      this.setupAccessibilityTestListeners();
    }
  }
  /**
   * Set up gesture test listeners
   */
  setupGestureTestListeners() {
    const gestureTests = [
      { name: "tap", test: this.testTapGesture.bind(this) },
      { name: "doubleTap", test: this.testDoubleTapGesture.bind(this) },
      { name: "longPress", test: this.testLongPressGesture.bind(this) },
      { name: "swipe", test: this.testSwipeGesture.bind(this) },
      { name: "pinch", test: this.testPinchGesture.bind(this) },
      { name: "rotate", test: this.testRotateGesture.bind(this) }
    ];
    gestureTests.forEach(({ name, test }) => {
      this.testListeners.set(`gesture:${name}`, test);
    });
  }
  /**
   * Set up control test listeners
   */
  setupControlTestListeners() {
    const controlTests = [
      { name: "virtualJoystick", test: this.testVirtualJoystick.bind(this) },
      { name: "actionButtons", test: this.testActionButtons.bind(this) },
      { name: "menuButton", test: this.testMenuButton.bind(this) },
      { name: "pauseButton", test: this.testPauseButton.bind(this) }
    ];
    controlTests.forEach(({ name, test }) => {
      this.testListeners.set(`control:${name}`, test);
    });
  }
  /**
   * Set up performance test listeners
   */
  setupPerformanceTestListeners() {
    this.testListeners.set("performance:test", this.testPerformance.bind(this));
  }
  /**
   * Set up accessibility test listeners
   */
  setupAccessibilityTestListeners() {
    this.testListeners.set("accessibility:test", this.testAccessibility.bind(this));
  }
  /**
   * Remove test listeners
   */
  removeTestListeners() {
    this.testListeners.clear();
  }
  /**
   * Start auto-testing
   */
  startAutoTesting() {
    if (this.isTesting) return;
    this.isTesting = true;
    this.autoTestInterval = setInterval(() => {
      this.runAllTests();
    }, this.config.testInterval);
    this.logger.info("Auto-testing started");
  }
  /**
   * Stop auto-testing
   */
  stopAutoTesting() {
    if (!this.isTesting) return;
    this.isTesting = false;
    if (this.autoTestInterval) {
      clearInterval(this.autoTestInterval);
      this.autoTestInterval = null;
    }
    this.logger.info("Auto-testing stopped");
  }
  /**
   * Run all tests
   */
  async runAllTests() {
    this.logger.info("Running mobile tests...");
    try {
      if (this.config.enableGestureTesting) {
        await this.testAllGestures();
      }
      if (this.config.enableControlTesting) {
        await this.testAllControls();
      }
      if (this.config.enablePerformanceTesting) {
        await this.testPerformance();
      }
      if (this.config.enableAccessibilityTesting) {
        await this.testAccessibility();
      }
      this.calculateOverallScore();
      this.eventBus.emit("mobileTesting:results", this.testResults);
      this.logger.info("Mobile tests completed");
    } catch (error) {
      this.logger.error("Error running mobile tests:", error);
    }
  }
  /**
   * Test all gestures
   */
  async testAllGestures() {
    const gestureNames = ["tap", "doubleTap", "longPress", "swipe", "pinch", "rotate"];
    for (const gestureName of gestureNames) {
      try {
        const result = await this.testGesture(gestureName);
        this.testResults.gestures.set(gestureName, result);
      } catch (error) {
        this.logger.error(`Error testing gesture ${gestureName}:`, error);
        this.testResults.gestures.set(gestureName, { success: false, error: error.message });
      }
    }
  }
  /**
   * Test a specific gesture
   */
  async testGesture(gestureName) {
    const testFunction = this.testListeners.get(`gesture:${gestureName}`);
    if (!testFunction) {
      throw new Error(`No test function found for gesture: ${gestureName}`);
    }
    return await testFunction();
  }
  /**
   * Test tap gesture
   */
  async testTapGesture() {
    return new Promise((resolve) => {
      let tapDetected = false;
      let startTime = Date.now();
      const handleTap = () => {
        tapDetected = true;
        const responseTime = Date.now() - startTime;
        document.removeEventListener("touchstart", handleTap);
        resolve({
          success: true,
          responseTime,
          timestamp: Date.now()
        });
      };
      document.addEventListener("touchstart", handleTap, { once: true });
      setTimeout(() => {
        if (!tapDetected) {
          document.removeEventListener("touchstart", handleTap);
          resolve({
            success: false,
            error: "Timeout",
            timestamp: Date.now()
          });
        }
      }, this.config.gestureTestTimeout);
    });
  }
  /**
   * Test double tap gesture
   */
  async testDoubleTapGesture() {
    return new Promise((resolve) => {
      let tapCount = 0;
      let lastTapTime = 0;
      let startTime = Date.now();
      const handleTap = () => {
        const currentTime = Date.now();
        tapCount++;
        if (tapCount === 1) {
          lastTapTime = currentTime;
        } else if (tapCount === 2) {
          const timeDiff = currentTime - lastTapTime;
          const success = timeDiff < 500;
          document.removeEventListener("touchstart", handleTap);
          resolve({
            success,
            timeDiff,
            timestamp: Date.now()
          });
        }
      };
      document.addEventListener("touchstart", handleTap);
      setTimeout(() => {
        document.removeEventListener("touchstart", handleTap);
        resolve({
          success: false,
          error: "Timeout",
          timestamp: Date.now()
        });
      }, this.config.gestureTestTimeout);
    });
  }
  /**
   * Test long press gesture
   */
  async testLongPressGesture() {
    return new Promise((resolve) => {
      let longPressDetected = false;
      let startTime = Date.now();
      const handleTouchStart = () => {
        startTime = Date.now();
      };
      const handleTouchEnd = () => {
        const duration = Date.now() - startTime;
        const success = duration >= 500;
        if (success) {
          longPressDetected = true;
          resolve({
            success: true,
            duration,
            timestamp: Date.now()
          });
        }
      };
      document.addEventListener("touchstart", handleTouchStart);
      document.addEventListener("touchend", handleTouchEnd);
      setTimeout(() => {
        document.removeEventListener("touchstart", handleTouchStart);
        document.removeEventListener("touchend", handleTouchEnd);
        if (!longPressDetected) {
          resolve({
            success: false,
            error: "Timeout",
            timestamp: Date.now()
          });
        }
      }, this.config.gestureTestTimeout);
    });
  }
  /**
   * Test swipe gesture
   */
  async testSwipeGesture() {
    return new Promise((resolve) => {
      let swipeDetected = false;
      let startTouch = null;
      const handleTouchStart = (e) => {
        startTouch = e.touches[0];
      };
      const handleTouchEnd = (e) => {
        if (!startTouch) return;
        const endTouch = e.changedTouches[0];
        const deltaX = endTouch.clientX - startTouch.clientX;
        const deltaY = endTouch.clientY - startTouch.clientY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const success = distance >= 50;
        if (success) {
          swipeDetected = true;
          resolve({
            success: true,
            distance,
            direction: Math.atan2(deltaY, deltaX) * 180 / Math.PI,
            timestamp: Date.now()
          });
        }
      };
      document.addEventListener("touchstart", handleTouchStart);
      document.addEventListener("touchend", handleTouchEnd);
      setTimeout(() => {
        document.removeEventListener("touchstart", handleTouchStart);
        document.removeEventListener("touchend", handleTouchEnd);
        if (!swipeDetected) {
          resolve({
            success: false,
            error: "Timeout",
            timestamp: Date.now()
          });
        }
      }, this.config.gestureTestTimeout);
    });
  }
  /**
   * Test pinch gesture
   */
  async testPinchGesture() {
    return new Promise((resolve) => {
      let pinchDetected = false;
      let startTouches = [];
      const handleTouchStart = (e) => {
        if (e.touches.length === 2) {
          startTouches = Array.from(e.touches);
        }
      };
      const handleTouchMove = (e) => {
        if (e.touches.length === 2 && startTouches.length === 2) {
          const currentTouches = Array.from(e.touches);
          const startDistance = this.getDistance(startTouches[0], startTouches[1]);
          const currentDistance = this.getDistance(currentTouches[0], currentTouches[1]);
          const scale = currentDistance / startDistance;
          if (Math.abs(scale - 1) > 0.1) {
            pinchDetected = true;
            resolve({
              success: true,
              scale,
              timestamp: Date.now()
            });
          }
        }
      };
      document.addEventListener("touchstart", handleTouchStart);
      document.addEventListener("touchmove", handleTouchMove);
      setTimeout(() => {
        document.removeEventListener("touchstart", handleTouchStart);
        document.removeEventListener("touchmove", handleTouchMove);
        if (!pinchDetected) {
          resolve({
            success: false,
            error: "Timeout",
            timestamp: Date.now()
          });
        }
      }, this.config.gestureTestTimeout);
    });
  }
  /**
   * Test rotate gesture
   */
  async testRotateGesture() {
    return new Promise((resolve) => {
      let rotateDetected = false;
      let startTouches = [];
      const handleTouchStart = (e) => {
        if (e.touches.length === 2) {
          startTouches = Array.from(e.touches);
        }
      };
      const handleTouchMove = (e) => {
        if (e.touches.length === 2 && startTouches.length === 2) {
          const currentTouches = Array.from(e.touches);
          const startAngle = this.getAngle(startTouches[0], startTouches[1]);
          const currentAngle = this.getAngle(currentTouches[0], currentTouches[1]);
          const rotation = currentAngle - startAngle;
          if (Math.abs(rotation) > 0.1) {
            rotateDetected = true;
            resolve({
              success: true,
              rotation: rotation * 180 / Math.PI,
              timestamp: Date.now()
            });
          }
        }
      };
      document.addEventListener("touchstart", handleTouchStart);
      document.addEventListener("touchmove", handleTouchMove);
      setTimeout(() => {
        document.removeEventListener("touchstart", handleTouchStart);
        document.removeEventListener("touchmove", handleTouchMove);
        if (!rotateDetected) {
          resolve({
            success: false,
            error: "Timeout",
            timestamp: Date.now()
          });
        }
      }, this.config.gestureTestTimeout);
    });
  }
  /**
   * Test all controls
   */
  async testAllControls() {
    const controlNames = ["virtualJoystick", "actionButtons", "menuButton", "pauseButton"];
    for (const controlName of controlNames) {
      try {
        const result = await this.testControl(controlName);
        this.testResults.controls.set(controlName, result);
      } catch (error) {
        this.logger.error(`Error testing control ${controlName}:`, error);
        this.testResults.controls.set(controlName, { success: false, error: error.message });
      }
    }
  }
  /**
   * Test a specific control
   */
  async testControl(controlName) {
    const testFunction = this.testListeners.get(`control:${controlName}`);
    if (!testFunction) {
      throw new Error(`No test function found for control: ${controlName}`);
    }
    return await testFunction();
  }
  /**
   * Test virtual joystick
   */
  async testVirtualJoystick() {
    if (!this.inputManager || !this.inputManager.mobileUI.virtualJoystick.element) {
      return {
        success: false,
        error: "Virtual joystick not available",
        timestamp: Date.now()
      };
    }
    const joystick = this.inputManager.mobileUI.virtualJoystick;
    const rect = joystick.element.getBoundingClientRect();
    return {
      success: true,
      position: {
        x: rect.left,
        y: rect.top,
        width: rect.width,
        height: rect.height
      },
      active: joystick.active,
      timestamp: Date.now()
    };
  }
  /**
   * Test action buttons
   */
  async testActionButtons() {
    if (!this.inputManager || !this.inputManager.mobileUI.actionButtons) {
      return {
        success: false,
        error: "Action buttons not available",
        timestamp: Date.now()
      };
    }
    const buttons = Array.from(this.inputManager.mobileUI.actionButtons.entries()).map(([id, button]) => {
      const rect = button.getBoundingClientRect();
      return {
        id,
        position: {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height
        },
        visible: button.offsetParent !== null
      };
    });
    return {
      success: true,
      buttons,
      count: buttons.length,
      timestamp: Date.now()
    };
  }
  /**
   * Test menu button
   */
  async testMenuButton() {
    const menuButton = document.querySelector(".menu-button");
    if (!menuButton) {
      return {
        success: false,
        error: "Menu button not found",
        timestamp: Date.now()
      };
    }
    const rect = menuButton.getBoundingClientRect();
    return {
      success: true,
      position: {
        x: rect.left,
        y: rect.top,
        width: rect.width,
        height: rect.height
      },
      visible: menuButton.offsetParent !== null,
      timestamp: Date.now()
    };
  }
  /**
   * Test pause button
   */
  async testPauseButton() {
    const pauseButton = document.querySelector(".pause-button");
    if (!pauseButton) {
      return {
        success: false,
        error: "Pause button not found",
        timestamp: Date.now()
      };
    }
    const rect = pauseButton.getBoundingClientRect();
    return {
      success: true,
      position: {
        x: rect.left,
        y: rect.top,
        width: rect.width,
        height: rect.height
      },
      visible: pauseButton.offsetParent !== null,
      timestamp: Date.now()
    };
  }
  /**
   * Test performance
   */
  async testPerformance() {
    if (!this.performanceMonitor) {
      return {
        success: false,
        error: "Performance monitor not available",
        timestamp: Date.now()
      };
    }
    const metrics = this.performanceMonitor.getMetrics();
    const score = this.performanceMonitor.getPerformanceScore();
    this.testResults.performance = {
      success: true,
      score,
      metrics: {
        fps: metrics.fps.current,
        frameTime: metrics.frameTime.current,
        memory: metrics.memory.used,
        audio: metrics.audio.contextState
      },
      timestamp: Date.now()
    };
    return this.testResults.performance;
  }
  /**
   * Test accessibility
   */
  async testAccessibility() {
    const accessibilityTests = [
      this.testScreenReaderSupport(),
      this.testKeyboardNavigation(),
      this.testHighContrast(),
      this.testTextScaling()
    ];
    const results = await Promise.all(accessibilityTests);
    this.testResults.accessibility = {
      success: true,
      tests: results,
      overallScore: results.reduce((sum, test) => sum + (test.success ? 1 : 0), 0) / results.length,
      timestamp: Date.now()
    };
    return this.testResults.accessibility;
  }
  /**
   * Test screen reader support
   */
  async testScreenReaderSupport() {
    const hasScreenReader = "speechSynthesis" in window;
    const hasAriaSupport = document.querySelector("[aria-label]") !== null;
    return {
      name: "screenReader",
      success: hasScreenReader && hasAriaSupport,
      details: {
        hasScreenReader,
        hasAriaSupport
      }
    };
  }
  /**
   * Test keyboard navigation
   */
  async testKeyboardNavigation() {
    const focusableElements = document.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    return {
      name: "keyboardNavigation",
      success: focusableElements.length > 0,
      details: {
        focusableElements: focusableElements.length
      }
    };
  }
  /**
   * Test high contrast
   */
  async testHighContrast() {
    const hasHighContrast = document.documentElement.classList.contains("high-contrast");
    return {
      name: "highContrast",
      success: true,
      // Always available
      details: {
        enabled: hasHighContrast
      }
    };
  }
  /**
   * Test text scaling
   */
  async testTextScaling() {
    const textScale = getComputedStyle(document.documentElement).getPropertyValue("--text-scale") || "1";
    return {
      name: "textScaling",
      success: true,
      // Always available
      details: {
        scale: parseFloat(textScale)
      }
    };
  }
  /**
   * Calculate overall score
   */
  calculateOverallScore() {
    let totalScore = 0;
    let testCount = 0;
    if (this.testResults.device?.isMobile) {
      totalScore += 1;
      testCount += 1;
    }
    for (const [name, result] of this.testResults.gestures) {
      totalScore += result.success ? 1 : 0;
      testCount += 1;
    }
    for (const [name, result] of this.testResults.controls) {
      totalScore += result.success ? 1 : 0;
      testCount += 1;
    }
    if (this.testResults.performance) {
      totalScore += this.testResults.performance.score / 100;
      testCount += 1;
    }
    if (this.testResults.accessibility) {
      totalScore += this.testResults.accessibility.overallScore;
      testCount += 1;
    }
    this.testResults.overall = {
      score: testCount > 0 ? totalScore / testCount : 0,
      totalTests: testCount,
      passedTests: Math.round(totalScore),
      timestamp: Date.now()
    };
  }
  /**
   * Get distance between two touch points
   */
  getDistance(touch1, touch2) {
    const dx = touch1.clientX - touch2.clientX;
    const dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Get angle between two touch points
   */
  getAngle(touch1, touch2) {
    return Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX);
  }
  /**
   * Get test results
   */
  getTestResults() {
    return this.testResults;
  }
  /**
   * Get test report
   */
  getTestReport() {
    return {
      device: this.testResults.device,
      gestures: Object.fromEntries(this.testResults.gestures),
      controls: Object.fromEntries(this.testResults.controls),
      performance: this.testResults.performance,
      accessibility: this.testResults.accessibility,
      overall: this.testResults.overall,
      timestamp: Date.now()
    };
  }
  /**
   * Export test results
   */
  exportTestResults() {
    return JSON.stringify(this.getTestReport(), null, 2);
  }
  /**
   * Update test configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }
};

// src/ui/SettingsUI.js
var SettingsUI = class {
  constructor(config = {}) {
    if (!config.eventBus || !(config.eventBus instanceof EventBus)) {
      throw new Error("SettingsUI: eventBus is required and must be an EventBus instance");
    }
    if (!config.logger || !(config.logger instanceof Logger)) {
      throw new Error("SettingsUI: logger is required and must be a Logger instance");
    }
    this.eventBus = config.eventBus;
    this.logger = config.logger;
    this.container = config.container || document.body;
    this.isVisible = false;
    this.settings = this.getDefaultSettings();
    this.show = this.show.bind(this);
    this.hide = this.hide.bind(this);
    this.toggle = this.toggle.bind(this);
    this.updateSetting = this.updateSetting.bind(this);
    this.resetToDefaults = this.resetToDefaults.bind(this);
    this.saveSettings = this.saveSettings.bind(this);
    this.loadSettings = this.loadSettings.bind(this);
    this.initializeUI();
    this.setupEventListeners();
    this.loadSettings();
    this.logger.info("SettingsUI initialized");
  }
  /**
   * Get default settings configuration
   */
  getDefaultSettings() {
    return {
      // Audio settings
      audio: {
        masterVolume: 1,
        musicVolume: 0.8,
        sfxVolume: 0.9,
        muteAll: false,
        muteMusic: false,
        muteSfx: false
      },
      // Graphics settings
      graphics: {
        quality: "high",
        // low, medium, high, ultra
        fullscreen: false,
        vsync: true,
        particleEffects: true,
        shadows: true,
        antiAliasing: true
      },
      // Gameplay settings
      gameplay: {
        difficulty: "normal",
        // easy, normal, hard, expert
        autoSave: true,
        autoPause: true,
        showFPS: false,
        showDebugInfo: false,
        tutorialEnabled: true
      },
      // Accessibility settings
      accessibility: {
        highContrast: false,
        largeText: false,
        screenReader: false,
        colorBlindMode: "none",
        // none, protanopia, deuteranopia, tritanopia
        reducedMotion: false,
        keyboardNavigation: true
      },
      // Controls settings
      controls: {
        keyBindings: this.getDefaultKeyBindings(),
        mouseSensitivity: 1,
        invertY: false,
        autoAim: false
      }
    };
  }
  /**
   * Get default key bindings
   */
  getDefaultKeyBindings() {
    return {
      moveUp: "KeyW",
      moveDown: "KeyS",
      moveLeft: "KeyA",
      moveRight: "KeyD",
      jump: "Space",
      action: "KeyE",
      pause: "Escape",
      inventory: "KeyI",
      map: "KeyM",
      chat: "KeyT"
    };
  }
  /**
   * Initialize the settings UI DOM structure
   */
  initializeUI() {
    this.settingsContainer = document.createElement("div");
    this.settingsContainer.className = "settings-container";
    this.settingsContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      z-index: 1000;
      overflow-y: auto;
    `;
    this.settingsPanel = document.createElement("div");
    this.settingsPanel.className = "settings-panel";
    this.settingsPanel.style.cssText = `
      position: relative;
      max-width: 800px;
      margin: 2rem auto;
      background: #1a1a1a;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    `;
    this.createHeader();
    this.createAudioSection();
    this.createGraphicsSection();
    this.createGameplaySection();
    this.createAccessibilitySection();
    this.createControlsSection();
    this.createFooter();
    this.settingsContainer.appendChild(this.settingsPanel);
    this.container.appendChild(this.settingsContainer);
  }
  /**
   * Create settings header
   */
  createHeader() {
    const header = document.createElement("div");
    header.className = "settings-header";
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #333;
    `;
    const title = document.createElement("h2");
    title.textContent = "Game Settings";
    title.style.cssText = `
      color: #fff;
      margin: 0;
      font-size: 1.5rem;
    `;
    const closeButton = document.createElement("button");
    closeButton.textContent = "";
    closeButton.className = "settings-close";
    closeButton.style.cssText = `
      background: none;
      border: none;
      color: #fff;
      font-size: 2rem;
      cursor: pointer;
      padding: 0;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    `;
    closeButton.addEventListener("click", this.hide);
    header.appendChild(title);
    header.appendChild(closeButton);
    this.settingsPanel.appendChild(header);
  }
  /**
   * Create audio settings section
   */
  createAudioSection() {
    const section = this.createSection("Audio Settings", "audio");
    this.createSliderControl(section, "Master Volume", "audio.masterVolume", 0, 1, 0.1);
    this.createSliderControl(section, "Music Volume", "audio.musicVolume", 0, 1, 0.1);
    this.createSliderControl(section, "SFX Volume", "audio.sfxVolume", 0, 1, 0.1);
    this.createCheckboxControl(section, "Mute All", "audio.muteAll");
    this.createCheckboxControl(section, "Mute Music", "audio.muteMusic");
    this.createCheckboxControl(section, "Mute SFX", "audio.muteSfx");
  }
  /**
   * Create graphics settings section
   */
  createGraphicsSection() {
    const section = this.createSection("Graphics Settings", "graphics");
    this.createSelectControl(section, "Quality Preset", "graphics.quality", [
      { value: "low", label: "Low" },
      { value: "medium", label: "Medium" },
      { value: "high", label: "High" },
      { value: "ultra", label: "Ultra" }
    ]);
    this.createCheckboxControl(section, "Fullscreen", "graphics.fullscreen");
    this.createCheckboxControl(section, "VSync", "graphics.vsync");
    this.createCheckboxControl(section, "Particle Effects", "graphics.particleEffects");
    this.createCheckboxControl(section, "Shadows", "graphics.shadows");
    this.createCheckboxControl(section, "Anti-Aliasing", "graphics.antiAliasing");
  }
  /**
   * Create gameplay settings section
   */
  createGameplaySection() {
    const section = this.createSection("Gameplay Settings", "gameplay");
    this.createSelectControl(section, "Difficulty", "gameplay.difficulty", [
      { value: "easy", label: "Easy" },
      { value: "normal", label: "Normal" },
      { value: "hard", label: "Hard" },
      { value: "expert", label: "Expert" }
    ]);
    this.createCheckboxControl(section, "Auto Save", "gameplay.autoSave");
    this.createCheckboxControl(section, "Auto Pause", "gameplay.autoPause");
    this.createCheckboxControl(section, "Show FPS", "gameplay.showFPS");
    this.createCheckboxControl(section, "Show Debug Info", "gameplay.showDebugInfo");
    this.createCheckboxControl(section, "Tutorial Enabled", "gameplay.tutorialEnabled");
  }
  /**
   * Create accessibility settings section
   */
  createAccessibilitySection() {
    const section = this.createSection("Accessibility Settings", "accessibility");
    this.createCheckboxControl(section, "High Contrast", "accessibility.highContrast");
    this.createCheckboxControl(section, "Large Text", "accessibility.largeText");
    this.createCheckboxControl(section, "Screen Reader Support", "accessibility.screenReader");
    this.createCheckboxControl(section, "Reduced Motion", "accessibility.reducedMotion");
    this.createCheckboxControl(section, "Keyboard Navigation", "accessibility.keyboardNavigation");
    this.createSelectControl(section, "Color Blind Mode", "accessibility.colorBlindMode", [
      { value: "none", label: "None" },
      { value: "protanopia", label: "Protanopia" },
      { value: "deuteranopia", label: "Deuteranopia" },
      { value: "tritanopia", label: "Tritanopia" }
    ]);
  }
  /**
   * Create controls settings section
   */
  createControlsSection() {
    const section = this.createSection("Controls Settings", "controls");
    this.createSliderControl(section, "Mouse Sensitivity", "controls.mouseSensitivity", 0.1, 3, 0.1);
    this.createCheckboxControl(section, "Invert Y Axis", "controls.invertY");
    this.createCheckboxControl(section, "Auto Aim", "controls.autoAim");
    const keyBindingsDiv = document.createElement("div");
    keyBindingsDiv.innerHTML = "<h4>Key Bindings</h4><p>Key binding customization coming soon...</p>";
    section.appendChild(keyBindingsDiv);
  }
  /**
   * Create a settings section container
   */
  createSection(title, id) {
    const section = document.createElement("div");
    section.className = `settings-section settings-section-${id}`;
    section.style.cssText = `
      margin-bottom: 2rem;
      padding: 1rem;
      background: #2a2a2a;
      border-radius: 4px;
    `;
    const sectionTitle = document.createElement("h3");
    sectionTitle.textContent = title;
    sectionTitle.style.cssText = `
      color: #fff;
      margin: 0 0 1rem 0;
      font-size: 1.2rem;
    `;
    section.appendChild(sectionTitle);
    this.settingsPanel.appendChild(section);
    return section;
  }
  /**
   * Create a slider control
   */
  createSliderControl(container, label, settingPath, min, max, step) {
    const controlDiv = document.createElement("div");
    controlDiv.className = "settings-control";
    controlDiv.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    `;
    const labelEl = document.createElement("label");
    labelEl.textContent = label;
    labelEl.style.cssText = `
      color: #fff;
      margin-right: 1rem;
      min-width: 150px;
    `;
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = min;
    slider.max = max;
    slider.step = step;
    slider.value = this.getSettingValue(settingPath);
    slider.style.cssText = `
      flex: 1;
      margin-right: 1rem;
    `;
    const valueDisplay = document.createElement("span");
    valueDisplay.textContent = slider.value;
    valueDisplay.style.cssText = `
      color: #fff;
      min-width: 50px;
      text-align: right;
    `;
    slider.addEventListener("input", (e) => {
      valueDisplay.textContent = e.target.value;
      this.updateSetting(settingPath, parseFloat(e.target.value));
    });
    controlDiv.appendChild(labelEl);
    controlDiv.appendChild(slider);
    controlDiv.appendChild(valueDisplay);
    container.appendChild(controlDiv);
  }
  /**
   * Create a checkbox control
   */
  createCheckboxControl(container, label, settingPath) {
    const controlDiv = document.createElement("div");
    controlDiv.className = "settings-control";
    controlDiv.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    `;
    const labelEl = document.createElement("label");
    labelEl.textContent = label;
    labelEl.style.cssText = `
      color: #fff;
      margin-right: 1rem;
      flex: 1;
    `;
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = this.getSettingValue(settingPath);
    checkbox.style.cssText = `
      width: 20px;
      height: 20px;
    `;
    checkbox.addEventListener("change", (e) => {
      this.updateSetting(settingPath, e.target.checked);
    });
    controlDiv.appendChild(labelEl);
    controlDiv.appendChild(checkbox);
    container.appendChild(controlDiv);
  }
  /**
   * Create a select control
   */
  createSelectControl(container, label, settingPath, options) {
    const controlDiv = document.createElement("div");
    controlDiv.className = "settings-control";
    controlDiv.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    `;
    const labelEl = document.createElement("label");
    labelEl.textContent = label;
    labelEl.style.cssText = `
      color: #fff;
      margin-right: 1rem;
      min-width: 150px;
    `;
    const select = document.createElement("select");
    select.value = this.getSettingValue(settingPath);
    select.style.cssText = `
      flex: 1;
      padding: 0.5rem;
      background: #333;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
    `;
    options.forEach((option) => {
      const optionEl = document.createElement("option");
      optionEl.value = option.value;
      optionEl.textContent = option.label;
      select.appendChild(optionEl);
    });
    select.addEventListener("change", (e) => {
      this.updateSetting(settingPath, e.target.value);
    });
    controlDiv.appendChild(labelEl);
    controlDiv.appendChild(select);
    container.appendChild(controlDiv);
  }
  /**
   * Create footer with action buttons
   */
  createFooter() {
    const footer = document.createElement("div");
    footer.className = "settings-footer";
    footer.style.cssText = `
      display: flex;
      justify-content: space-between;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid #333;
    `;
    const resetButton = document.createElement("button");
    resetButton.textContent = "Reset to Defaults";
    resetButton.className = "settings-reset";
    resetButton.style.cssText = `
      background: #666;
      color: #fff;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      cursor: pointer;
    `;
    resetButton.addEventListener("click", this.resetToDefaults);
    const buttonGroup = document.createElement("div");
    buttonGroup.style.cssText = `
      display: flex;
      gap: 1rem;
    `;
    const cancelButton = document.createElement("button");
    cancelButton.textContent = "Cancel";
    cancelButton.className = "settings-cancel";
    cancelButton.style.cssText = `
      background: #666;
      color: #fff;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      cursor: pointer;
    `;
    cancelButton.addEventListener("click", this.hide);
    const saveButton = document.createElement("button");
    saveButton.textContent = "Save Settings";
    saveButton.className = "settings-save";
    saveButton.style.cssText = `
      background: #4CAF50;
      color: #fff;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      cursor: pointer;
    `;
    saveButton.addEventListener("click", this.saveSettings);
    buttonGroup.appendChild(cancelButton);
    buttonGroup.appendChild(saveButton);
    footer.appendChild(resetButton);
    footer.appendChild(buttonGroup);
    this.settingsPanel.appendChild(footer);
  }
  /**
   * Set up event listeners
   */
  setupEventListeners() {
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.isVisible) {
        this.hide();
      }
    });
    this.settingsContainer.addEventListener("click", (e) => {
      if (e.target === this.settingsContainer) {
        this.hide();
      }
    });
  }
  /**
   * Get setting value by path
   */
  getSettingValue(path) {
    if (!path || typeof path !== "string") {
      return void 0;
    }
    const keys = path.split(".");
    let value = this.settings;
    for (const key of keys) {
      if (value && typeof value === "object" && key in value) {
        value = value[key];
      } else {
        return void 0;
      }
    }
    return value;
  }
  /**
   * Update setting value by path
   */
  updateSetting(path, value) {
    const keys = path.split(".");
    let target = this.settings;
    for (let i = 0; i < keys.length - 1; i++) {
      target = target[keys[i]];
    }
    target[keys[keys.length - 1]] = value;
    this.eventBus.emit("settings:changed", {
      path,
      value,
      settings: this.settings
    });
    this.logger.debug(`Setting updated: ${path} = ${value}`);
  }
  /**
   * Show settings UI
   */
  show() {
    this.settingsContainer.style.display = "block";
    this.isVisible = true;
    this.eventBus.emit("settings:opened");
    this.logger.info("Settings UI opened");
  }
  /**
   * Hide settings UI
   */
  hide() {
    this.settingsContainer.style.display = "none";
    this.isVisible = false;
    this.eventBus.emit("settings:closed");
    this.logger.info("Settings UI closed");
  }
  /**
   * Toggle settings UI visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * Reset all settings to defaults
   */
  resetToDefaults() {
    this.settings = this.getDefaultSettings();
    this.loadSettings();
    this.eventBus.emit("settings:reset");
    this.logger.info("Settings reset to defaults");
  }
  /**
   * Save settings to localStorage
   */
  saveSettings() {
    try {
      localStorage.setItem("gameSettings", JSON.stringify(this.settings));
      this.eventBus.emit("settings:saved", this.settings);
      this.logger.info("Settings saved successfully");
      this.hide();
    } catch (error) {
      this.logger.error("Failed to save settings:", error);
      this.eventBus.emit("settings:saveError", error);
    }
  }
  /**
   * Load settings from localStorage
   */
  loadSettings() {
    try {
      const saved = localStorage.getItem("gameSettings");
      if (saved) {
        const parsedSettings = JSON.parse(saved);
        this.settings = this.mergeSettings(this.settings, parsedSettings);
        this.eventBus.emit("settings:loaded", this.settings);
        this.logger.info("Settings loaded successfully");
      }
    } catch (error) {
      this.logger.error("Failed to load settings:", error);
      this.eventBus.emit("settings:loadError", error);
    }
  }
  /**
   * Merge settings objects
   */
  mergeSettings(defaults, saved) {
    const merged = { ...defaults };
    for (const key in saved) {
      if (typeof saved[key] === "object" && !Array.isArray(saved[key])) {
        merged[key] = this.mergeSettings(defaults[key] || {}, saved[key]);
      } else {
        merged[key] = saved[key];
      }
    }
    return merged;
  }
  /**
   * Get current settings
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Update settings programmatically
   */
  setSettings(newSettings) {
    this.settings = this.mergeSettings(this.settings, newSettings);
    this.eventBus.emit("settings:updated", this.settings);
    this.logger.info("Settings updated programmatically");
  }
  /**
   * Cleanup resources
   */
  cleanup() {
    if (this.settingsContainer && this.settingsContainer.parentNode) {
      this.settingsContainer.parentNode.removeChild(this.settingsContainer);
    }
    this.eventBus.emit("settings:cleanup");
    this.logger.info("SettingsUI cleaned up");
  }
};

// src/systems/AudioSystem.js
var AudioSystem = class {
  constructor(config = {}) {
    if (!config.eventBus || !(config.eventBus instanceof EventBus)) {
      throw new Error("AudioSystem: eventBus is required and must be an EventBus instance");
    }
    if (!config.logger || !(config.logger instanceof Logger)) {
      throw new Error("AudioSystem: logger is required and must be a Logger instance");
    }
    this.eventBus = config.eventBus;
    this.logger = config.logger;
    this.audioContext = null;
    this.sounds = /* @__PURE__ */ new Map();
    this.music = /* @__PURE__ */ new Map();
    this.audioSettings = {
      masterVolume: 1,
      musicVolume: 0.8,
      sfxVolume: 0.9,
      muteAll: false,
      muteMusic: false,
      muteSfx: false
    };
    this.currentMusic = null;
    this.isInitialized = false;
    this.initialize = this.initialize.bind(this);
    this.loadSound = this.loadSound.bind(this);
    this.loadMusic = this.loadMusic.bind(this);
    this.playSound = this.playSound.bind(this);
    this.playMusic = this.playMusic.bind(this);
    this.stopMusic = this.stopMusic.bind(this);
    this.pauseMusic = this.pauseMusic.bind(this);
    this.resumeMusic = this.resumeMusic.bind(this);
    this.setMasterVolume = this.setMasterVolume.bind(this);
    this.setMusicVolume = this.setMusicVolume.bind(this);
    this.setSfxVolume = this.setSfxVolume.bind(this);
    this.muteAll = this.muteAll.bind(this);
    this.unmuteAll = this.unmuteAll.bind(this);
    this.muteMusic = this.muteMusic.bind(this);
    this.unmuteMusic = this.unmuteMusic.bind(this);
    this.muteSfx = this.muteSfx.bind(this);
    this.unmuteSfx = this.unmuteSfx.bind(this);
    this.cleanup = this.cleanup.bind(this);
    this.logger.info("AudioSystem initialized");
  }
  /**
   * Initialize the audio system
   */
  async initialize() {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (this.audioContext.state === "suspended") {
        await this.audioContext.resume();
      }
      this.setupEventListeners();
      await this.loadDefaultAssets();
      this.isInitialized = true;
      this.eventBus.emit("audio:initialized");
      this.logger.info("AudioSystem initialized successfully");
    } catch (error) {
      this.logger.error("Failed to initialize AudioSystem:", error);
      this.eventBus.emit("audio:initializationError", error);
      throw error;
    }
  }
  /**
   * Set up event listeners for audio-related events
   */
  setupEventListeners() {
    this.eventBus.on("settings:changed", (data) => {
      this.handleSettingsChange(data);
    });
    this.eventBus.on("player:jump", () => {
      this.playSound("jump");
    });
    this.eventBus.on("player:collect", (data) => {
      this.playSound("collect");
    });
    this.eventBus.on("player:damage", () => {
      this.playSound("damage");
    });
    this.eventBus.on("player:death", () => {
      this.playSound("death");
    });
    this.eventBus.on("game:levelComplete", () => {
      this.playSound("levelComplete");
    });
    this.eventBus.on("game:gameOver", () => {
      this.playSound("gameOver");
    });
    this.eventBus.on("achievement:unlocked", () => {
      this.playSound("achievement");
    });
    window.addEventListener("beforeunload", this.cleanup);
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        this.pauseMusic();
      } else {
        this.resumeMusic();
      }
    });
  }
  /**
   * Handle settings changes
   */
  handleSettingsChange(data) {
    const { path, value } = data;
    switch (path) {
      case "audio.masterVolume":
        this.setMasterVolume(value);
        break;
      case "audio.musicVolume":
        this.setMusicVolume(value);
        break;
      case "audio.sfxVolume":
        this.setSfxVolume(value);
        break;
      case "audio.muteAll":
        if (value) {
          this.muteAll();
        } else {
          this.unmuteAll();
        }
        break;
      case "audio.muteMusic":
        if (value) {
          this.muteMusic();
        } else {
          this.unmuteMusic();
        }
        break;
      case "audio.muteSfx":
        if (value) {
          this.muteSfx();
        } else {
          this.unmuteSfx();
        }
        break;
    }
  }
  /**
   * Load default audio assets
   */
  async loadDefaultAssets() {
    const defaultSounds = [
      "jump",
      "collect",
      "damage",
      "death",
      "levelComplete",
      "gameOver",
      "achievement",
      "buttonClick",
      "buttonHover",
      "error"
    ];
    const defaultMusic = [
      "mainTheme",
      "menuTheme",
      "gameplayTheme",
      "victoryTheme"
    ];
    for (const soundName of defaultSounds) {
      await this.loadSound(soundName, this.generatePlaceholderAudio(soundName));
    }
    for (const musicName of defaultMusic) {
      await this.loadMusic(musicName, this.generatePlaceholderAudio(musicName, true));
    }
    this.logger.info("Default audio assets loaded");
  }
  /**
   * Generate placeholder audio data URL for demo purposes
   */
  generatePlaceholderAudio(name, isMusic = false) {
    const duration = isMusic ? 30 : 1;
    const sampleRate = 44100;
    const samples = sampleRate * duration;
    const buffer = new ArrayBuffer(44 + samples * 2);
    const view = new DataView(buffer);
    const writeString = (offset, string) => {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    };
    writeString(0, "RIFF");
    view.setUint32(4, 36 + samples * 2, true);
    writeString(8, "WAVE");
    writeString(12, "fmt ");
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(36, "data");
    view.setUint32(40, samples * 2, true);
    for (let i = 0; i < samples; i++) {
      const sample = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.1;
      view.setInt16(44 + i * 2, sample * 32767, true);
    }
    const blob = new Blob([buffer], { type: "audio/wav" });
    return URL.createObjectURL(blob);
  }
  /**
   * Load a sound effect
   */
  async loadSound(name, url) {
    try {
      const audio = new Audio(url);
      audio.preload = "auto";
      audio.volume = this.audioSettings.sfxVolume * this.audioSettings.masterVolume;
      await new Promise((resolve, reject) => {
        audio.addEventListener("canplaythrough", resolve);
        audio.addEventListener("error", reject);
      });
      this.sounds.set(name, audio);
      this.logger.debug(`Sound loaded: ${name}`);
    } catch (error) {
      this.logger.error(`Failed to load sound ${name}:`, error);
      throw error;
    }
  }
  /**
   * Load background music
   */
  async loadMusic(name, url) {
    try {
      const audio = new Audio(url);
      audio.preload = "auto";
      audio.loop = true;
      audio.volume = this.audioSettings.musicVolume * this.audioSettings.masterVolume;
      await new Promise((resolve, reject) => {
        audio.addEventListener("canplaythrough", resolve);
        audio.addEventListener("error", reject);
      });
      this.music.set(name, audio);
      this.logger.debug(`Music loaded: ${name}`);
    } catch (error) {
      this.logger.error(`Failed to load music ${name}:`, error);
      throw error;
    }
  }
  /**
   * Play a sound effect
   */
  playSound(name, volume = 1) {
    if (!this.isInitialized) {
      this.logger.warn("AudioSystem not initialized, cannot play sound");
      return;
    }
    if (this.audioSettings.muteAll || this.audioSettings.muteSfx) {
      return;
    }
    const sound = this.sounds.get(name);
    if (!sound) {
      this.logger.warn(`Sound not found: ${name}`);
      return;
    }
    try {
      const soundClone = sound.cloneNode();
      soundClone.volume = sound.volume * volume;
      soundClone.play();
      this.eventBus.emit("audio:soundPlayed", { name, volume });
      this.logger.debug(`Playing sound: ${name}`);
    } catch (error) {
      this.logger.error(`Failed to play sound ${name}:`, error);
    }
  }
  /**
   * Play background music
   */
  playMusic(name, fadeIn = true) {
    if (!this.isInitialized) {
      this.logger.warn("AudioSystem not initialized, cannot play music");
      return;
    }
    if (this.audioSettings.muteAll || this.audioSettings.muteMusic) {
      return;
    }
    const music = this.music.get(name);
    if (!music) {
      this.logger.warn(`Music not found: ${name}`);
      return;
    }
    try {
      if (this.currentMusic && this.currentMusic !== music) {
        this.stopMusic();
      }
      this.currentMusic = music;
      if (fadeIn) {
        music.volume = 0;
        music.play();
        this.fadeIn(music);
      } else {
        music.play();
      }
      this.eventBus.emit("audio:musicStarted", { name });
      this.logger.debug(`Playing music: ${name}`);
    } catch (error) {
      this.logger.error(`Failed to play music ${name}:`, error);
    }
  }
  /**
   * Stop current music
   */
  stopMusic() {
    if (this.currentMusic) {
      this.currentMusic.pause();
      this.currentMusic.currentTime = 0;
      this.eventBus.emit("audio:musicStopped");
      this.logger.debug("Music stopped");
    }
  }
  /**
   * Pause current music
   */
  pauseMusic() {
    if (this.currentMusic && !this.currentMusic.paused) {
      this.currentMusic.pause();
      this.eventBus.emit("audio:musicPaused");
      this.logger.debug("Music paused");
    }
  }
  /**
   * Resume current music
   */
  resumeMusic() {
    if (this.currentMusic && this.currentMusic.paused) {
      this.currentMusic.play();
      this.eventBus.emit("audio:musicResumed");
      this.logger.debug("Music resumed");
    }
  }
  /**
   * Fade in audio
   */
  fadeIn(audio, duration = 2e3) {
    const startTime = Date.now();
    const startVolume = audio.volume;
    const targetVolume = this.audioSettings.musicVolume * this.audioSettings.masterVolume;
    const fade = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      audio.volume = startVolume + (targetVolume - startVolume) * progress;
      if (progress < 1) {
        requestAnimationFrame(fade);
      }
    };
    fade();
  }
  /**
   * Fade out audio
   */
  fadeOut(audio, duration = 2e3) {
    const startTime = Date.now();
    const startVolume = audio.volume;
    const fade = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      audio.volume = startVolume * (1 - progress);
      if (progress < 1) {
        requestAnimationFrame(fade);
      } else {
        audio.pause();
        audio.currentTime = 0;
      }
    };
    fade();
  }
  /**
   * Set master volume
   */
  setMasterVolume(volume) {
    this.audioSettings.masterVolume = Math.max(0, Math.min(1, volume));
    this.updateAllVolumes();
    this.eventBus.emit("audio:masterVolumeChanged", this.audioSettings.masterVolume);
    this.logger.debug(`Master volume set to: ${this.audioSettings.masterVolume}`);
  }
  /**
   * Set music volume
   */
  setMusicVolume(volume) {
    this.audioSettings.musicVolume = Math.max(0, Math.min(1, volume));
    this.updateMusicVolumes();
    this.eventBus.emit("audio:musicVolumeChanged", this.audioSettings.musicVolume);
    this.logger.debug(`Music volume set to: ${this.audioSettings.musicVolume}`);
  }
  /**
   * Set SFX volume
   */
  setSfxVolume(volume) {
    this.audioSettings.sfxVolume = Math.max(0, Math.min(1, volume));
    this.updateSfxVolumes();
    this.eventBus.emit("audio:sfxVolumeChanged", this.audioSettings.sfxVolume);
    this.logger.debug(`SFX volume set to: ${this.audioSettings.sfxVolume}`);
  }
  /**
   * Update all audio volumes
   */
  updateAllVolumes() {
    this.updateMusicVolumes();
    this.updateSfxVolumes();
  }
  /**
   * Update music volumes
   */
  updateMusicVolumes() {
    const volume = this.audioSettings.musicVolume * this.audioSettings.masterVolume;
    for (const music of this.music.values()) {
      music.volume = volume;
    }
  }
  /**
   * Update SFX volumes
   */
  updateSfxVolumes() {
    const volume = this.audioSettings.sfxVolume * this.audioSettings.masterVolume;
    for (const sound of this.sounds.values()) {
      sound.volume = volume;
    }
  }
  /**
   * Mute all audio
   */
  muteAll() {
    this.audioSettings.muteAll = true;
    this.updateAllVolumes();
    this.eventBus.emit("audio:muted", { type: "all" });
    this.logger.debug("All audio muted");
  }
  /**
   * Unmute all audio
   */
  unmuteAll() {
    this.audioSettings.muteAll = false;
    this.updateAllVolumes();
    this.eventBus.emit("audio:unmuted", { type: "all" });
    this.logger.debug("All audio unmuted");
  }
  /**
   * Mute music only
   */
  muteMusic() {
    this.audioSettings.muteMusic = true;
    this.updateMusicVolumes();
    this.eventBus.emit("audio:muted", { type: "music" });
    this.logger.debug("Music muted");
  }
  /**
   * Unmute music only
   */
  unmuteMusic() {
    this.audioSettings.muteMusic = false;
    this.updateMusicVolumes();
    this.eventBus.emit("audio:unmuted", { type: "music" });
    this.logger.debug("Music unmuted");
  }
  /**
   * Mute SFX only
   */
  muteSfx() {
    this.audioSettings.muteSfx = true;
    this.updateSfxVolumes();
    this.eventBus.emit("audio:muted", { type: "sfx" });
    this.logger.debug("SFX muted");
  }
  /**
   * Unmute SFX only
   */
  unmuteSfx() {
    this.audioSettings.muteSfx = false;
    this.updateSfxVolumes();
    this.eventBus.emit("audio:unmuted", { type: "sfx" });
    this.logger.debug("SFX unmuted");
  }
  /**
   * Get current audio settings
   */
  getAudioSettings() {
    return { ...this.audioSettings };
  }
  /**
   * Set audio settings
   */
  setAudioSettings(settings) {
    this.audioSettings = { ...this.audioSettings, ...settings };
    this.updateAllVolumes();
    this.eventBus.emit("audio:settingsChanged", this.audioSettings);
    this.logger.debug("Audio settings updated");
  }
  /**
   * Get list of loaded sounds
   */
  getLoadedSounds() {
    return Array.from(this.sounds.keys());
  }
  /**
   * Get list of loaded music
   */
  getLoadedMusic() {
    return Array.from(this.music.keys());
  }
  /**
   * Check if audio is playing
   */
  isPlaying(name, type = "sound") {
    const audio = type === "music" ? this.music.get(name) : this.sounds.get(name);
    return audio && !audio.paused;
  }
  /**
   * Cleanup resources
   */
  cleanup() {
    this.stopMusic();
    if (this.audioContext) {
      this.audioContext.close();
    }
    this.sounds.clear();
    this.music.clear();
    this.eventBus.emit("audio:cleanup");
    this.logger.info("AudioSystem cleaned up");
  }
};

// src/GameRefactored.js
var GameRefactored = class {
  constructor(config = {}) {
    this.config = this.validateConfig({
      debug: false,
      enableAchievements: true,
      enableDailyChallenges: true,
      enableAccessibility: true,
      ...config
    });
    if (typeof this.config.debug !== "boolean") {
      throw new Error("GameRefactored: config.debug must be a boolean");
    }
    if (typeof this.config.enableAchievements !== "boolean") {
      throw new Error(
        "GameRefactored: config.enableAchievements must be a boolean"
      );
    }
    if (typeof this.config.enableDailyChallenges !== "boolean") {
      throw new Error(
        "GameRefactored: config.enableDailyChallenges must be a boolean"
      );
    }
    if (typeof this.config.enableAccessibility !== "boolean") {
      throw new Error(
        "GameRefactored: config.enableAccessibility must be a boolean"
      );
    }
    this.eventBus = new EventBus();
    if (!this.eventBus || typeof this.eventBus.emit !== "function") {
      throw new Error("GameRefactored: EventBus initialization failed");
    }
    this.logger = new Logger(this.config.debug);
    if (!this.logger || typeof this.logger.info !== "function") {
      throw new Error("GameRefactored: Logger initialization failed");
    }
    this.gameState = {
      isRunning: false,
      isPaused: false,
      currentLevel: 1,
      score: 0,
      player: null,
      gameObjects: [],
      startTime: null,
      lastUpdateTime: null,
      activePowerUps: /* @__PURE__ */ new Map()
      // Track active power-ups
    };
    if (typeof this.gameState.isRunning !== "boolean") {
      throw new Error("GameRefactored: gameState.isRunning must be a boolean");
    }
    if (typeof this.gameState.currentLevel !== "number" || this.gameState.currentLevel < 1) {
      throw new Error(
        "GameRefactored: gameState.currentLevel must be a positive number"
      );
    }
    if (typeof this.gameState.score !== "number" || this.gameState.score < 0) {
      throw new Error(
        "GameRefactored: gameState.score must be a non-negative number"
      );
    }
    if (!Array.isArray(this.gameState.gameObjects)) {
      throw new Error("GameRefactored: gameState.gameObjects must be an array");
    }
    this.managers = {};
    this.initializeManagers();
    this.performanceMonitor = new PerformanceMonitor({
      eventBus: this.eventBus,
      logger: this.logger,
      config: this.config
    });
    this.inputManager = new InputManager({
      eventBus: this.eventBus,
      logger: this.logger,
      config: this.config
    });
    this.mobileTesting = new MobileTesting({
      eventBus: this.eventBus,
      logger: this.logger,
      inputManager: this.inputManager,
      performanceMonitor: this.performanceMonitor,
      config: this.config
    });
    this.ui = {};
    this.systems = {};
    this.initializeUISystems();
    if (!this.managers.game) {
      throw new Error("GameRefactored: GameManager initialization failed");
    }
    if (this.config.enableAchievements && !this.managers.achievements) {
      throw new Error(
        "GameRefactored: AchievementManager initialization failed when enabled"
      );
    }
    if (this.config.enableDailyChallenges && !this.managers.dailyChallenges) {
      throw new Error(
        "GameRefactored: DailyChallengeManager initialization failed when enabled"
      );
    }
    if (this.config.enableAccessibility && !this.managers.accessibility) {
      throw new Error(
        "GameRefactored: AccessibilityManager initialization failed when enabled"
      );
    }
    if (!this.ui.settings) {
      throw new Error("GameRefactored: SettingsUI initialization failed");
    }
    if (!this.systems.audio) {
      throw new Error("GameRefactored: AudioSystem initialization failed");
    }
    this.update = this.update.bind(this);
    this.render = this.render.bind(this);
    this.handleInput = this.handleInput.bind(this);
    if (typeof this.update !== "function") {
      throw new Error("GameRefactored: update method binding failed");
    }
    if (typeof this.render !== "function") {
      throw new Error("GameRefactored: render method binding failed");
    }
    if (typeof this.handleInput !== "function") {
      throw new Error("GameRefactored: handleInput method binding failed");
    }
    this.logger.info("GameRefactored initialized");
  }
  /**
   * Validate and normalize configuration
   */
  validateConfig(config) {
    const validatedConfig = { ...config };
    validatedConfig.debug = Boolean(validatedConfig.debug);
    validatedConfig.enableAchievements = Boolean(
      validatedConfig.enableAchievements
    );
    validatedConfig.enableDailyChallenges = Boolean(
      validatedConfig.enableDailyChallenges
    );
    validatedConfig.enableAccessibility = Boolean(
      validatedConfig.enableAccessibility
    );
    return validatedConfig;
  }
  /**
   * Initialize all game managers with dependency injection
   */
  initializeManagers() {
    this.managers.game = new GameManager({
      eventBus: this.eventBus,
      logger: this.logger,
      config: this.config
    });
    if (this.config.enableAchievements) {
      this.managers.achievements = new AchievementManager({
        eventBus: this.eventBus,
        logger: this.logger,
        gameState: () => this.gameState
      });
    }
    if (this.config.enableDailyChallenges) {
      this.managers.dailyChallenges = new DailyChallengeManager({
        eventBus: this.eventBus,
        logger: this.logger,
        gameState: () => this.gameState
      });
    }
    if (this.config.enableAccessibility) {
      this.managers.accessibility = new AccessibilityManager({
        eventBus: this.eventBus,
        logger: this.logger,
        gameState: () => this.gameState
      });
    }
    this.setupManagerCommunication();
  }
  /**
   * Initialize UI and Audio systems
   */
  initializeUISystems() {
    this.ui.settings = new SettingsUI({
      eventBus: this.eventBus,
      logger: this.logger,
      container: document.body
    });
    this.systems.audio = new AudioSystem({
      eventBus: this.eventBus,
      logger: this.logger
    });
    this.setupUIIntegration();
  }
  /**
   * Set up UI and audio integration
   */
  setupUIIntegration() {
    this.eventBus.on("settings:changed", (data) => {
      if (data.path.startsWith("audio.")) {
        this.logger.debug(`Audio setting changed: ${data.path} = ${data.value}`);
      }
    });
    this.eventBus.on("game:stateChanged", (data) => {
      if (this.ui.settings) {
        this.logger.debug(`Game state changed: ${JSON.stringify(data)}`);
      }
    });
  }
  /**
   * Set up communication between managers
   */
  setupManagerCommunication() {
    this.eventBus.on("player:scoreChanged", (data) => {
      if (this.managers.achievements) {
        this.managers.achievements.checkScoreAchievements(data.score);
      }
      this.updateUI("score", data.score);
    });
    this.eventBus.on("player:levelCompleted", (data) => {
      if (this.managers.achievements) {
        this.managers.achievements.checkLevelAchievements(data.level);
      }
      if (this.managers.dailyChallenges) {
        this.managers.dailyChallenges.checkLevelChallenge(data.level);
      }
      this.updateUI("level", data.level);
    });
    this.eventBus.on("player:itemCollected", (data) => {
      if (this.managers.achievements) {
        this.managers.achievements.checkCollectionAchievements(data.itemType);
      }
      if (this.managers.dailyChallenges) {
        this.managers.dailyChallenges.checkCollectionChallenge(data.itemType);
      }
      this.updateUI("item", data.itemType);
    });
    this.eventBus.on("game:stateChanged", (data) => {
      if (this.managers.accessibility) {
        this.managers.accessibility.announceStateChange(data);
      }
    });
    this.eventBus.on("achievement:unlocked", (data) => {
      this.logger.info(`Achievement unlocked: ${data.name}`);
      if (this.managers.game) {
        this.managers.game.handleAchievementUnlock(data);
      }
      this.updateUI("achievement", data);
    });
    this.eventBus.on("dailyChallenge:completed", (data) => {
      this.logger.info(`Daily challenge completed: ${data.name}`);
      if (this.managers.game) {
        this.managers.game.handleDailyChallengeCompletion(data);
      }
      this.updateUI("challenge", data);
    });
    this.eventBus.on("powerup:activated", (data) => {
      this.gameState.activePowerUps.set(data.type, {
        ...data,
        startTime: Date.now(),
        duration: data.duration || 1e4
        // 10 seconds default
      });
      this.updateUI("powerup", data);
    });
    this.eventBus.on("powerup:expired", (data) => {
      this.gameState.activePowerUps.delete(data.type);
      this.updateUI("powerupExpired", data);
    });
    this.eventBus.on("console:command", (data) => {
      this.handleConsoleCommand(data);
    });
    this.eventBus.on("play:action", (data) => {
      this.handlePlayAction(data);
    });
  }
  /**
   * Update UI with game state changes
   */
  updateUI(type, data) {
    this.eventBus.emit("ui:update", {
      type,
      data,
      timestamp: Date.now()
    });
  }
  /**
   * Handle console commands for debugging and testing
   */
  handleConsoleCommand(data) {
    const { command, args } = data;
    switch (command) {
      case "setScore":
        this.gameState.score = parseInt(args[0]) || 0;
        this.eventBus.emit("player:scoreChanged", { score: this.gameState.score });
        this.logger.info(`Console: Score set to ${this.gameState.score}`);
        break;
      case "setLevel":
        this.gameState.currentLevel = parseInt(args[0]) || 1;
        this.eventBus.emit("player:levelCompleted", { level: this.gameState.currentLevel });
        this.logger.info(`Console: Level set to ${this.gameState.currentLevel}`);
        break;
      case "addPowerUp":
        const powerUpType = args[0] || "speed";
        this.eventBus.emit("powerup:activated", {
          type: powerUpType,
          duration: 1e4
        });
        this.logger.info(`Console: Power-up ${powerUpType} added`);
        break;
      case "unlockAchievement":
        const achievementName = args[0] || "test";
        this.eventBus.emit("achievement:unlocked", {
          name: achievementName,
          description: "Console unlocked achievement"
        });
        this.logger.info(`Console: Achievement ${achievementName} unlocked`);
        break;
      case "toggleSettings":
        if (this.ui.settings) {
          this.ui.settings.toggle();
        }
        break;
      case "muteAudio":
        if (this.systems.audio) {
          this.systems.audio.muteAll();
        }
        break;
      case "unmuteAudio":
        if (this.systems.audio) {
          this.systems.audio.unmuteAll();
        }
        break;
      default:
        this.logger.warn(`Console: Unknown command: ${command}`);
    }
  }
  /**
   * Handle play actions for game interaction
   */
  handlePlayAction(data) {
    const { action, params } = data;
    switch (action) {
      case "jump":
        this.eventBus.emit("player:jump", params);
        break;
      case "collect":
        this.eventBus.emit("player:collect", params);
        break;
      case "damage":
        this.eventBus.emit("player:damage", params);
        break;
      case "pause":
        this.pause();
        break;
      case "resume":
        this.resume();
        break;
      case "restart":
        this.stop();
        this.start();
        break;
      default:
        this.logger.warn(`Play: Unknown action: ${action}`);
    }
  }
  /**
   * Start the game
   */
  async start() {
    try {
      this.logger.info("Starting game...");
      for (const [name, manager] of Object.entries(this.managers)) {
        if (manager.initialize) {
          await manager.initialize();
        }
      }
      if (this.performanceMonitor.initialize) {
        await this.performanceMonitor.initialize();
      }
      if (this.inputManager.initialize) {
        await this.inputManager.initialize();
      }
      if (this.mobileTesting.initialize) {
        await this.mobileTesting.initialize();
      }
      if (this.systems.audio && this.systems.audio.initialize) {
        await this.systems.audio.initialize();
      }
      this.gameState.isRunning = true;
      this.gameState.startTime = Date.now();
      this.gameState.lastUpdateTime = performance.now();
      this.gameLoopId = requestAnimationFrame(this.update);
      this.eventBus.emit("game:started", {
        timestamp: this.gameState.startTime,
        config: this.config
      });
      if (this.systems.audio) {
        this.systems.audio.playMusic("mainTheme");
      }
      this.logger.info("Game started successfully");
    } catch (error) {
      this.logger.error("Failed to start game:", error);
      throw error;
    }
  }
  /**
   * Pause the game
   */
  pause() {
    if (this.gameState.isRunning && !this.gameState.isPaused) {
      this.gameState.isPaused = true;
      cancelAnimationFrame(this.gameLoopId);
      this.eventBus.emit("game:paused", {
        timestamp: Date.now(),
        pauseTime: this.gameState.startTime
      });
      this.logger.info("Game paused");
    }
  }
  /**
   * Resume the game
   */
  resume() {
    if (this.gameState.isRunning && this.gameState.isPaused) {
      this.gameState.isPaused = false;
      this.gameState.lastUpdateTime = performance.now();
      this.gameLoopId = requestAnimationFrame(this.update);
      this.eventBus.emit("game:resumed", {
        timestamp: Date.now()
      });
      this.logger.info("Game resumed");
    }
  }
  /**
   * Stop the game
   */
  stop() {
    this.gameState.isRunning = false;
    this.gameState.isPaused = false;
    if (this.gameLoopId) {
      cancelAnimationFrame(this.gameLoopId);
    }
    for (const [name, manager] of Object.entries(this.managers)) {
      if (manager.cleanup) {
        manager.cleanup();
      }
    }
    if (this.performanceMonitor.cleanup) {
      this.performanceMonitor.cleanup();
    }
    if (this.inputManager.cleanup) {
      this.inputManager.cleanup();
    }
    if (this.mobileTesting.cleanup) {
      this.mobileTesting.cleanup();
    }
    this.eventBus.emit("game:stopped", {
      timestamp: Date.now(),
      finalScore: this.gameState.score,
      finalLevel: this.gameState.currentLevel
    });
    this.logger.info("Game stopped");
  }
  /**
   * Main game update loop
   */
  update(currentTime) {
    if (!this.gameState.isRunning || this.gameState.isPaused) {
      return;
    }
    const deltaTime = currentTime - this.gameState.lastUpdateTime;
    this.gameState.lastUpdateTime = currentTime;
    try {
      for (const [name, manager] of Object.entries(this.managers)) {
        if (manager.update) {
          manager.update(deltaTime, this.gameState);
        }
      }
      if (this.performanceMonitor.update) {
        this.performanceMonitor.update(deltaTime);
      }
      if (this.inputManager.update) {
        this.inputManager.update(deltaTime);
      }
      this.updateGameObjects(deltaTime);
      this.gameLoopId = requestAnimationFrame(this.update);
    } catch (error) {
      this.logger.error("Error in game update loop:", error);
      this.stop();
    }
  }
  /**
   * Update all game objects
   */
  updateGameObjects(deltaTime) {
    if (this.gameState.player && this.gameState.player.update) {
      this.gameState.player.update(deltaTime);
    }
    this.gameState.gameObjects.forEach((obj) => {
      if (obj.update) {
        obj.update(deltaTime);
      }
    });
    this.gameState.gameObjects = this.gameState.gameObjects.filter(
      (obj) => !obj.destroyed
    );
  }
  /**
   * Render the game
   */
  render() {
    this.eventBus.emit("game:render", {
      gameState: this.gameState,
      timestamp: performance.now()
    });
  }
  /**
   * Handle input events
   */
  handleInput(inputType, data) {
    if (!this.gameState.isRunning) {
      return;
    }
    this.eventBus.emit("game:input", {
      type: inputType,
      data,
      timestamp: Date.now()
    });
    if (this.gameState.player && this.gameState.player.handleInput) {
      this.gameState.player.handleInput(inputType, data);
    }
  }
  /**
   * Add a game object to the game
   */
  addGameObject(gameObject) {
    this.gameState.gameObjects.push(gameObject);
    this.eventBus.emit("game:objectAdded", {
      object: gameObject,
      timestamp: Date.now()
    });
  }
  /**
   * Remove a game object from the game
   */
  removeGameObject(gameObjectId) {
    const index = this.gameState.gameObjects.findIndex(
      (obj) => obj.id === gameObjectId
    );
    if (index !== -1) {
      const removedObject = this.gameState.gameObjects.splice(index, 1)[0];
      this.eventBus.emit("game:objectRemoved", {
        object: removedObject,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Get current game state (for external access)
   */
  getGameState() {
    return { ...this.gameState };
  }
  /**
   * Get manager by name
   */
  getManager(name) {
    return this.managers[name];
  }
  /**
   * Get performance monitor
   */
  getPerformanceMonitor() {
    return this.performanceMonitor;
  }
  /**
   * Get input manager
   */
  getInputManager() {
    return this.inputManager;
  }
  /**
   * Get mobile testing utility
   */
  getMobileTesting() {
    return this.mobileTesting;
  }
  /**
   * Get performance report
   */
  getPerformanceReport() {
    return this.performanceMonitor ? this.performanceMonitor.getPerformanceReport() : null;
  }
  /**
   * Get mobile controls state
   */
  getMobileControlsState() {
    return this.inputManager ? this.inputManager.getMobileControlsState() : null;
  }
  /**
   * Get mobile test results
   */
  getMobileTestResults() {
    return this.mobileTesting ? this.mobileTesting.getTestResults() : null;
  }
  /**
   * Get UI system by name
   */
  getUI(name) {
    return this.ui[name];
  }
  /**
   * Get system by name
   */
  getSystem(name) {
    return this.systems[name];
  }
  /**
   * Get all active power-ups
   */
  getActivePowerUps() {
    const now = Date.now();
    const active = [];
    for (const [type, powerUp] of this.gameState.activePowerUps) {
      if (now - powerUp.startTime < powerUp.duration) {
        active.push({
          type,
          ...powerUp,
          remainingTime: powerUp.duration - (now - powerUp.startTime)
        });
      } else {
        this.gameState.activePowerUps.delete(type);
        this.eventBus.emit("powerup:expired", { type });
      }
    }
    return active;
  }
  /**
   * Execute console command (for external access)
   */
  executeConsoleCommand(command, ...args) {
    this.eventBus.emit("console:command", { command, args });
  }
  /**
   * Execute play action (for external access)
   */
  executePlayAction(action, params = {}) {
    this.eventBus.emit("play:action", { action, params });
  }
  /**
   * Get game statistics
   */
  getGameStats() {
    return {
      score: this.gameState.score,
      level: this.gameState.currentLevel,
      isRunning: this.gameState.isRunning,
      isPaused: this.gameState.isPaused,
      gameTime: this.gameState.startTime ? Date.now() - this.gameState.startTime : 0,
      activePowerUps: this.getActivePowerUps(),
      achievements: this.managers.achievements ? this.managers.achievements.getAllAchievements() : [],
      challenges: this.managers.dailyChallenges ? this.managers.dailyChallenges.getActiveChallenges() : []
    };
  }
  /**
   * Update game configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    this.eventBus.emit("game:configChanged", {
      config: this.config,
      timestamp: Date.now()
    });
  }
  /**
   * Cleanup and destroy the game instance
   */
  destroy() {
    this.stop();
    if (this.ui.settings) {
      this.ui.settings.cleanup();
    }
    if (this.systems.audio) {
      this.systems.audio.cleanup();
    }
    this.eventBus.removeAllListeners();
    this.gameState = null;
    this.managers = null;
    this.ui = null;
    this.systems = null;
    this.logger.info("GameRefactored destroyed");
  }
};
var GameRefactored_default = GameRefactored;
export {
  GameRefactored,
  GameRefactored_default as default
};
//# sourceMappingURL=src_GameRefactored__js.js.map
