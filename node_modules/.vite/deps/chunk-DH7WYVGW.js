// src/core/EventBus.js
var EventBus = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.eventHistory = [];
    this.maxHistorySize = 1e3;
    this.debug = false;
    this.performanceMetrics = {
      totalEvents: 0,
      averageProcessingTime: 0,
      slowestEvent: null,
      eventCounts: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Add event listener
   */
  on(event, callback, options = {}) {
    if (typeof callback !== "function") {
      throw new Error("Callback must be a function");
    }
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    const listener = {
      callback,
      once: options.once || false,
      priority: options.priority || 0,
      id: options.id || null,
      context: options.context || null
    };
    this.listeners.get(event).push(listener);
    this.listeners.get(event).sort((a, b) => b.priority - a.priority);
    this.log(`Added listener for event: ${event}`);
  }
  /**
   * Add one-time event listener
   */
  once(event, callback, options = {}) {
    this.on(event, callback, { ...options, once: true });
  }
  /**
   * Remove event listener
   */
  off(event, callback) {
    if (!this.listeners.has(event)) {
      return;
    }
    const eventListeners = this.listeners.get(event);
    const index = eventListeners.findIndex(
      (listener) => listener.callback === callback
    );
    if (index !== -1) {
      eventListeners.splice(index, 1);
      this.log(`Removed listener for event: ${event}`);
    }
  }
  /**
   * Remove all listeners for an event
   */
  removeAllListeners(event) {
    if (event) {
      this.listeners.delete(event);
      this.log(`Removed all listeners for event: ${event}`);
    } else {
      this.listeners.clear();
      this.log("Removed all listeners");
    }
  }
  /**
   * Alias for off method for backward compatibility
   */
  removeListener(event, callback) {
    return this.off(event, callback);
  }
  /**
   * Emit an event
   */
  emit(event, data = {}) {
    const startTime = performance.now();
    if (!this.listeners.has(event)) {
      this.log(`No listeners for event: ${event}`);
      return;
    }
    const eventListeners = this.listeners.get(event);
    const eventData = {
      event,
      data,
      timestamp: Date.now(),
      id: this.generateEventId()
    };
    this.addToHistory(eventData);
    this.updatePerformanceMetrics(event, startTime);
    const listenersToRemove = [];
    for (let i = 0; i < eventListeners.length; i++) {
      const listener = eventListeners[i];
      try {
        if (listener.context) {
          listener.callback.call(listener.context, eventData.data, eventData);
        } else {
          listener.callback(eventData.data, eventData);
        }
        if (listener.once) {
          listenersToRemove.push(i);
        }
      } catch (error) {
        console.error(`Error in event listener for ${event}:`, error);
      }
    }
    for (let i = listenersToRemove.length - 1; i >= 0; i--) {
      eventListeners.splice(listenersToRemove[i], 1);
    }
    this.log(`Emitted event: ${event}`, eventData);
  }
  /**
   * Emit event asynchronously
   */
  async emitAsync(event, data = {}) {
    return new Promise((resolve, reject) => {
      try {
        this.emit(event, data);
        resolve();
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * Wait for an event
   */
  waitFor(event, timeout = 5e3) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        this.off(event, handler);
        reject(new Error(`Timeout waiting for event: ${event}`));
      }, timeout);
      const handler = (data, eventData) => {
        clearTimeout(timeoutId);
        this.off(event, handler);
        resolve({ data, eventData });
      };
      this.on(event, handler);
    });
  }
  /**
   * Add event to history
   */
  addToHistory(eventData) {
    this.eventHistory.push(eventData);
    if (this.eventHistory.length > this.maxHistorySize) {
      this.eventHistory.shift();
    }
  }
  /**
   * Update performance metrics
   */
  updatePerformanceMetrics(event, startTime) {
    const processingTime = performance.now() - startTime;
    this.performanceMetrics.totalEvents++;
    const totalTime = this.performanceMetrics.averageProcessingTime * (this.performanceMetrics.totalEvents - 1);
    this.performanceMetrics.averageProcessingTime = (totalTime + processingTime) / this.performanceMetrics.totalEvents;
    if (!this.performanceMetrics.slowestEvent || processingTime > this.performanceMetrics.slowestEvent.time) {
      this.performanceMetrics.slowestEvent = {
        event,
        time: processingTime,
        timestamp: Date.now()
      };
    }
    const count = this.performanceMetrics.eventCounts.get(event) || 0;
    this.performanceMetrics.eventCounts.set(event, count + 1);
  }
  /**
   * Generate unique event ID
   */
  generateEventId() {
    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Get event history
   */
  getHistory(filter = {}) {
    let history = [...this.eventHistory];
    if (filter.event) {
      history = history.filter((item) => item.event === filter.event);
    }
    if (filter.since) {
      history = history.filter((item) => item.timestamp >= filter.since);
    }
    if (filter.until) {
      history = history.filter((item) => item.timestamp <= filter.until);
    }
    if (filter.limit) {
      history = history.slice(-filter.limit);
    }
    return history;
  }
  /**
   * Get performance metrics
   */
  getPerformanceMetrics() {
    return {
      ...this.performanceMetrics,
      eventCounts: Object.fromEntries(this.performanceMetrics.eventCounts)
    };
  }
  /**
   * Clear event history
   */
  clearHistory() {
    this.eventHistory = [];
    this.log("Event history cleared");
  }
  /**
   * Reset performance metrics
   */
  resetMetrics() {
    this.performanceMetrics = {
      totalEvents: 0,
      averageProcessingTime: 0,
      slowestEvent: null,
      eventCounts: /* @__PURE__ */ new Map()
    };
    this.log("Performance metrics reset");
  }
  /**
   * Enable debug mode
   */
  enableDebug() {
    this.debug = true;
    this.log("Debug mode enabled");
  }
  /**
   * Disable debug mode
   */
  disableDebug() {
    this.debug = false;
  }
  /**
   * Log debug message
   */
  log(message, data = null) {
    if (this.debug) {
      if (data) {
        console.log(`[EventBus] ${message}`, data);
      } else {
        console.log(`[EventBus] ${message}`);
      }
    }
  }
  /**
   * Get listener count for an event
   */
  getListenerCount(event) {
    return this.listeners.has(event) ? this.listeners.get(event).length : 0;
  }
  /**
   * Get all registered events
   */
  getRegisteredEvents() {
    return Array.from(this.listeners.keys());
  }
  /**
   * Check if event has listeners
   */
  hasListeners(event) {
    return this.listeners.has(event) && this.listeners.get(event).length > 0;
  }
  /**
   * Create event filter
   */
  createFilter(event, condition) {
    return (data, eventData) => {
      if (condition(data, eventData)) {
        this.emit(event, data);
      }
    };
  }
  /**
   * Create event transformer
   */
  createTransformer(event, transform) {
    return (data, eventData) => {
      const transformedData = transform(data, eventData);
      this.emit(event, transformedData);
    };
  }
  /**
   * Destroy the event bus
   */
  destroy() {
    this.listeners.clear();
    this.eventHistory = [];
    this.performanceMetrics = {
      totalEvents: 0,
      averageProcessingTime: 0,
      slowestEvent: null,
      eventCounts: /* @__PURE__ */ new Map()
    };
    this.log("EventBus destroyed");
  }
};

// src/utils/Logger.js
var Logger = class _Logger {
  constructor(debug = false) {
    this.debug = debug;
    this.logLevel = debug ? "debug" : "info";
    this.logHistory = [];
    this.maxHistorySize = 1e3;
    this.performanceMetrics = {
      totalLogs: 0,
      logsByLevel: /* @__PURE__ */ new Map(),
      averageLogTime: 0
    };
    this.levels = {
      error: 0,
      warn: 1,
      info: 2,
      debug: 3,
      trace: 4
    };
    this.startTime = Date.now();
  }
  /**
   * Set log level
   */
  setLevel(level) {
    if (Object.prototype.hasOwnProperty.call(this.levels, level)) {
      this.logLevel = level;
    } else {
      this.warn(`Invalid log level: ${level}`);
    }
  }
  /**
   * Enable debug mode
   */
  enableDebug() {
    this.debug = true;
    this.setLevel("debug");
  }
  /**
   * Disable debug mode
   */
  disableDebug() {
    this.debug = false;
    this.setLevel("info");
  }
  /**
   * Check if log level should be processed
   */
  shouldLog(level) {
    return this.levels[level] <= this.levels[this.logLevel];
  }
  /**
   * Log a message
   */
  log(level, message, data = null, context = null) {
    if (!this.shouldLog(level)) {
      return;
    }
    const timestamp = Date.now();
    const logEntry = {
      level,
      message,
      data,
      context,
      timestamp,
      id: this.generateLogId()
    };
    this.addToHistory(logEntry);
    this.updatePerformanceMetrics(level);
    this.outputLog(logEntry);
  }
  /**
   * Add log entry to history
   */
  addToHistory(logEntry) {
    this.logHistory.push(logEntry);
    if (this.logHistory.length > this.maxHistorySize) {
      this.logHistory.shift();
    }
  }
  /**
   * Update performance metrics
   */
  updatePerformanceMetrics(level) {
    this.performanceMetrics.totalLogs++;
    const count = this.performanceMetrics.logsByLevel.get(level) || 0;
    this.performanceMetrics.logsByLevel.set(level, count + 1);
    const totalTime = this.performanceMetrics.averageLogTime * (this.performanceMetrics.totalLogs - 1);
    this.performanceMetrics.averageLogTime = (totalTime + 1) / this.performanceMetrics.totalLogs;
  }
  /**
   * Output log to console
   */
  outputLog(logEntry) {
    const { level, message, data, context, timestamp } = logEntry;
    const timeString = new Date(timestamp).toISOString();
    const contextString = context ? `[${context}]` : "";
    const prefix = `[${timeString}] ${level.toUpperCase()}${contextString}`;
    switch (level) {
      case "error":
        console.error(prefix, message, data || "");
        break;
      case "warn":
        console.warn(prefix, message, data || "");
        break;
      case "info":
        console.info(prefix, message, data || "");
        break;
      case "debug":
        console.debug(prefix, message, data || "");
        break;
      case "trace":
        console.trace(prefix, message, data || "");
        break;
      default:
        console.log(prefix, message, data || "");
    }
  }
  /**
   * Generate unique log ID
   */
  generateLogId() {
    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Error level logging
   */
  error(message, data = null, context = null) {
    this.log("error", message, data, context);
  }
  /**
   * Warning level logging
   */
  warn(message, data = null, context = null) {
    this.log("warn", message, data, context);
  }
  /**
   * Info level logging
   */
  info(message, data = null, context = null) {
    this.log("info", message, data, context);
  }
  /**
   * Debug level logging
   */
  debug(message, data = null, context = null) {
    this.log("debug", message, data, context);
  }
  /**
   * Trace level logging
   */
  trace(message, data = null, context = null) {
    this.log("trace", message, data, context);
  }
  /**
   * Log performance metrics
   */
  performance(operation, startTime, endTime = null) {
    const duration = (endTime || performance.now()) - startTime;
    this.debug(`Performance: ${operation} took ${duration.toFixed(2)}ms`);
    return duration;
  }
  /**
   * Log memory usage
   */
  memory() {
    if (performance.memory) {
      const memory = performance.memory;
      this.debug("Memory usage:", {
        used: `${Math.round(memory.usedJSHeapSize / 1024 / 1024)}MB`,
        total: `${Math.round(memory.totalJSHeapSize / 1024 / 1024)}MB`,
        limit: `${Math.round(memory.jsHeapSizeLimit / 1024 / 1024)}MB`
      });
    }
  }
  /**
   * Log function execution
   */
  function(name, fn, context = null) {
    const startTime = performance.now();
    this.debug(`Function started: ${name}`, null, context);
    try {
      const result = fn();
      const duration = this.performance(name, startTime);
      this.debug(`Function completed: ${name}`, { duration }, context);
      return result;
    } catch (error) {
      const duration = this.performance(name, startTime);
      this.error(
        `Function failed: ${name}`,
        { error: error.message, duration },
        context
      );
      throw error;
    }
  }
  /**
   * Log async function execution
   */
  async functionAsync(name, fn, context = null) {
    const startTime = performance.now();
    this.debug(`Async function started: ${name}`, null, context);
    try {
      const result = await fn();
      const duration = this.performance(name, startTime);
      this.debug(`Async function completed: ${name}`, { duration }, context);
      return result;
    } catch (error) {
      const duration = this.performance(name, startTime);
      this.error(
        `Async function failed: ${name}`,
        { error: error.message, duration },
        context
      );
      throw error;
    }
  }
  /**
   * Log event
   */
  event(eventName, data = null, context = null) {
    this.debug(`Event: ${eventName}`, data, context);
  }
  /**
   * Log state change
   */
  stateChange(from, to, data = null, context = null) {
    this.info(`State changed: ${from} -> ${to}`, data, context);
  }
  /**
   * Log user action
   */
  userAction(action, data = null, context = null) {
    this.info(`User action: ${action}`, data, context);
  }
  /**
   * Log API call
   */
  apiCall(method, url, data = null, context = null) {
    this.debug(`API call: ${method} ${url}`, data, context);
  }
  /**
   * Log API response
   */
  apiResponse(method, url, status, data = null, context = null) {
    const level = status >= 400 ? "error" : "debug";
    this.log(
      level,
      `API response: ${method} ${url} - ${status}`,
      data,
      context
    );
  }
  /**
   * Log error with stack trace
   */
  errorWithStack(message, error, context = null) {
    this.error(
      message,
      {
        error: error.message,
        stack: error.stack
      },
      context
    );
  }
  /**
   * Log group of related messages
   */
  group(name, fn, context = null) {
    const startTime = performance.now();
    this.debug(`Group started: ${name}`, null, context);
    try {
      const result = fn();
      const duration = this.performance(name, startTime);
      this.debug(`Group completed: ${name}`, { duration }, context);
      return result;
    } catch (error) {
      const duration = this.performance(name, startTime);
      this.error(
        `Group failed: ${name}`,
        { error: error.message, duration },
        context
      );
      throw error;
    }
  }
  /**
   * Log async group of related messages
   */
  async groupAsync(name, fn, context = null) {
    const startTime = performance.now();
    this.debug(`Async group started: ${name}`, null, context);
    try {
      const result = await fn();
      const duration = this.performance(name, startTime);
      this.debug(`Async group completed: ${name}`, { duration }, context);
      return result;
    } catch (error) {
      const duration = this.performance(name, startTime);
      this.error(
        `Async group failed: ${name}`,
        { error: error.message, duration },
        context
      );
      throw error;
    }
  }
  /**
   * Get log history
   */
  getHistory(filter = {}) {
    let history = [...this.logHistory];
    if (filter.level) {
      history = history.filter((entry) => entry.level === filter.level);
    }
    if (filter.context) {
      history = history.filter((entry) => entry.context === filter.context);
    }
    if (filter.since) {
      history = history.filter((entry) => entry.timestamp >= filter.since);
    }
    if (filter.until) {
      history = history.filter((entry) => entry.timestamp <= filter.until);
    }
    if (filter.limit) {
      history = history.slice(-filter.limit);
    }
    return history;
  }
  /**
   * Get performance metrics
   */
  getPerformanceMetrics() {
    return {
      ...this.performanceMetrics,
      logsByLevel: Object.fromEntries(this.performanceMetrics.logsByLevel),
      uptime: Date.now() - this.startTime
    };
  }
  /**
   * Clear log history
   */
  clearHistory() {
    this.logHistory = [];
    this.debug("Log history cleared");
  }
  /**
   * Reset performance metrics
   */
  resetMetrics() {
    this.performanceMetrics = {
      totalLogs: 0,
      logsByLevel: /* @__PURE__ */ new Map(),
      averageLogTime: 0
    };
    this.startTime = Date.now();
    this.debug("Performance metrics reset");
  }
  /**
   * Export logs to JSON
   */
  exportLogs(filter = {}) {
    const history = this.getHistory(filter);
    return JSON.stringify(history, null, 2);
  }
  /**
   * Import logs from JSON
   */
  importLogs(jsonString) {
    try {
      const logs = JSON.parse(jsonString);
      if (Array.isArray(logs)) {
        this.logHistory = logs;
        this.debug(`Imported ${logs.length} log entries`);
      }
    } catch (error) {
      this.error("Failed to import logs:", error);
    }
  }
  /**
   * Create a child logger with context
   */
  child(context) {
    const childLogger = new _Logger(this.debug);
    childLogger.logLevel = this.logLevel;
    childLogger.context = context;
    return childLogger;
  }
};

export {
  EventBus,
  Logger
};
//# sourceMappingURL=chunk-DH7WYVGW.js.map
