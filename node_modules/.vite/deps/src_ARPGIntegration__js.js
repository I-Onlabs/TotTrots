import {
  EventBus,
  Logger
} from "./chunk-DH7WYVGW.js";

// src/systems/ARPGUISystem.js
var ARPGUISystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("ARPGUISystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("ARPGUISystem requires logger dependency");
    }
    this.uiState = {
      isOpen: false,
      currentTab: "character",
      skillTreeOpen: false,
      inventoryOpen: false,
      tradingOpen: false,
      gemSocketingOpen: false,
      selectedItem: null,
      selectedGem: null
    };
    this.character = {
      level: 1,
      experience: 0,
      experienceToNext: 100,
      skillPoints: 0,
      attributePoints: 0,
      attributes: {
        strength: 10,
        dexterity: 10,
        intelligence: 10,
        vitality: 10,
        wisdom: 10,
        charisma: 10
      },
      stats: {
        health: 100,
        maxHealth: 100,
        mana: 50,
        maxMana: 50,
        damage: 10,
        armor: 0,
        criticalChance: 0.05,
        criticalMultiplier: 1.5,
        attackSpeed: 1,
        movementSpeed: 1,
        manaRegen: 1,
        healthRegen: 0.5
      },
      skills: /* @__PURE__ */ new Map(),
      equippedItems: /* @__PURE__ */ new Map(),
      inventory: [],
      gems: []
    };
    this.skillTree = this.initializeSkillTree();
    this.skillGems = this.initializeSkillGems();
    this.socketingSystem = this.initializeSocketingSystem();
    this.tradingSystem = this.initializeTradingSystem();
    this.uiElements = /* @__PURE__ */ new Map();
    this.setupEventHandlers();
    this.logger.info("ARPGUISystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing ARPGUISystem...");
    this.createUIElements();
    this.setupUIEventListeners();
    await this.loadCharacterData();
    this.logger.info("ARPGUISystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up ARPGUISystem...");
    this.saveCharacterData();
    this.removeEventHandlers();
    this.clearUIElements();
    this.logger.info("ARPGUISystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updateCharacterStats();
    this.updateUIAnimations(deltaTime);
    this.updateSkillCooldowns(deltaTime);
  }
  /**
   * Initialize the passive skill tree with 100+ nodes
   */
  initializeSkillTree() {
    return {
      // Combat tree (30 nodes)
      combat: {
        name: "Combat Mastery",
        description: "Enhance your combat abilities",
        nodes: [
          // Basic combat nodes
          { id: "basic_attack", name: "Basic Attack", description: "Increases basic attack damage by 10%", cost: 1, maxLevel: 5, level: 0, prerequisites: [] },
          { id: "weapon_mastery", name: "Weapon Mastery", description: "Increases weapon damage by 15%", cost: 2, maxLevel: 3, level: 0, prerequisites: ["basic_attack"] },
          { id: "critical_strike", name: "Critical Strike", description: "Increases critical hit chance by 5%", cost: 2, maxLevel: 5, level: 0, prerequisites: ["basic_attack"] },
          { id: "critical_damage", name: "Critical Damage", description: "Increases critical hit damage by 25%", cost: 3, maxLevel: 3, level: 0, prerequisites: ["critical_strike"] },
          { id: "attack_speed", name: "Attack Speed", description: "Increases attack speed by 10%", cost: 2, maxLevel: 5, level: 0, prerequisites: ["weapon_mastery"] },
          { id: "dual_wield", name: "Dual Wield", description: "Allows dual wielding weapons", cost: 5, maxLevel: 1, level: 0, prerequisites: ["weapon_mastery", "attack_speed"] },
          { id: "berserker", name: "Berserker", description: "Damage increases as health decreases", cost: 4, maxLevel: 3, level: 0, prerequisites: ["critical_damage"] },
          { id: "executioner", name: "Executioner", description: "Deal 50% more damage to enemies below 25% health", cost: 5, maxLevel: 1, level: 0, prerequisites: ["berserker"] },
          { id: "combo_master", name: "Combo Master", description: "Each consecutive hit increases damage by 10%", cost: 3, maxLevel: 5, level: 0, prerequisites: ["attack_speed"] },
          { id: "finisher", name: "Finisher", description: "Final hit in combo deals 200% damage", cost: 4, maxLevel: 1, level: 0, prerequisites: ["combo_master"] },
          // Advanced combat nodes
          { id: "weapon_specialization", name: "Weapon Specialization", description: "Choose a weapon type for 25% damage bonus", cost: 6, maxLevel: 1, level: 0, prerequisites: ["dual_wield"] },
          { id: "battle_fury", name: "Battle Fury", description: "Kills grant 20% attack speed for 5 seconds", cost: 4, maxLevel: 3, level: 0, prerequisites: ["executioner"] },
          { id: "bloodthirst", name: "Bloodthirst", description: "Heal for 10% of damage dealt", cost: 5, maxLevel: 3, level: 0, prerequisites: ["battle_fury"] },
          { id: "devastating_blow", name: "Devastating Blow", description: "10% chance to deal 300% damage", cost: 6, maxLevel: 2, level: 0, prerequisites: ["finisher"] },
          { id: "whirlwind", name: "Whirlwind", description: "Attack all enemies in radius", cost: 8, maxLevel: 1, level: 0, prerequisites: ["devastating_blow"] },
          { id: "lethal_precision", name: "Lethal Precision", description: "Critical hits have 25% chance to instantly kill", cost: 10, maxLevel: 1, level: 0, prerequisites: ["whirlwind"] },
          // Mastery nodes
          { id: "combat_mastery", name: "Combat Mastery", description: "All combat skills gain +1 level", cost: 15, maxLevel: 1, level: 0, prerequisites: ["lethal_precision"] },
          { id: "weapon_legend", name: "Weapon Legend", description: "Weapon damage increased by 50%", cost: 12, maxLevel: 1, level: 0, prerequisites: ["weapon_specialization", "combat_mastery"] },
          { id: "death_dealer", name: "Death Dealer", description: "Killing an enemy grants 50% damage for 10 seconds", cost: 15, maxLevel: 1, level: 0, prerequisites: ["bloodthirst", "combat_mastery"] },
          { id: "unstoppable_force", name: "Unstoppable Force", description: "Cannot be stunned, immune to crowd control", cost: 20, maxLevel: 1, level: 0, prerequisites: ["weapon_legend", "death_dealer"] },
          // Additional combat nodes to reach 30
          { id: "quick_strike", name: "Quick Strike", description: "First attack in combat deals 150% damage", cost: 2, maxLevel: 3, level: 0, prerequisites: ["basic_attack"] },
          { id: "power_attack", name: "Power Attack", description: "Slower but more powerful attacks", cost: 3, maxLevel: 3, level: 0, prerequisites: ["weapon_mastery"] },
          { id: "counter_attack", name: "Counter Attack", description: "Blocking an attack allows instant counter", cost: 4, maxLevel: 2, level: 0, prerequisites: ["power_attack"] },
          { id: "riposte", name: "Riposte", description: "Counter attacks deal 200% damage", cost: 5, maxLevel: 1, level: 0, prerequisites: ["counter_attack"] },
          { id: "flurry", name: "Flurry", description: "Rapid attacks with reduced damage", cost: 3, maxLevel: 4, level: 0, prerequisites: ["attack_speed"] },
          { id: "momentum", name: "Momentum", description: "Each hit increases next attack speed", cost: 4, maxLevel: 3, level: 0, prerequisites: ["flurry"] },
          { id: "crescendo", name: "Crescendo", name: "Final attack in momentum chain deals 500% damage", cost: 6, maxLevel: 1, level: 0, prerequisites: ["momentum"] },
          { id: "savage_roar", name: "Savage Roar", description: "Intimidate enemies, reducing their damage", cost: 5, maxLevel: 2, level: 0, prerequisites: ["berserker"] },
          { id: "battle_cry", name: "Battle Cry", description: "Allies gain 25% damage for 10 seconds", cost: 6, maxLevel: 1, level: 0, prerequisites: ["savage_roar"] },
          { id: "war_cry", name: "War Cry", description: "Enemies take 50% more damage for 15 seconds", cost: 8, maxLevel: 1, level: 0, prerequisites: ["battle_cry"] }
        ]
      },
      // Defense tree (25 nodes)
      defense: {
        name: "Defense Mastery",
        description: "Enhance your defensive capabilities",
        nodes: [
          // Basic defense nodes
          { id: "armor_mastery", name: "Armor Mastery", description: "Increases armor by 20%", cost: 1, maxLevel: 5, level: 0, prerequisites: [] },
          { id: "shield_block", name: "Shield Block", description: "25% chance to block incoming attacks", cost: 2, maxLevel: 3, level: 0, prerequisites: ["armor_mastery"] },
          { id: "damage_reduction", name: "Damage Reduction", description: "Reduces all damage by 5%", cost: 2, maxLevel: 5, level: 0, prerequisites: ["armor_mastery"] },
          { id: "health_boost", name: "Health Boost", description: "Increases maximum health by 15%", cost: 2, maxLevel: 5, level: 0, prerequisites: [] },
          { id: "regeneration", name: "Regeneration", description: "Regenerate 2% health per second", cost: 3, maxLevel: 3, level: 0, prerequisites: ["health_boost"] },
          { id: "tough_skin", name: "Tough Skin", description: "Reduces physical damage by 10%", cost: 3, maxLevel: 3, level: 0, prerequisites: ["damage_reduction"] },
          { id: "magic_resistance", name: "Magic Resistance", description: "Reduces magical damage by 15%", cost: 3, maxLevel: 3, level: 0, prerequisites: ["damage_reduction"] },
          { id: "evasion", name: "Evasion", description: "10% chance to completely avoid attacks", cost: 4, maxLevel: 3, level: 0, prerequisites: ["shield_block"] },
          { id: "dodge_master", name: "Dodge Master", description: "Evasion chance increased by 15%", cost: 5, maxLevel: 2, level: 0, prerequisites: ["evasion"] },
          { id: "perfect_dodge", name: "Perfect Dodge", description: "Dodging grants 50% damage for 3 seconds", cost: 6, maxLevel: 1, level: 0, prerequisites: ["dodge_master"] },
          // Advanced defense nodes
          { id: "fortress", name: "Fortress", description: "Standing still increases armor by 100%", cost: 5, maxLevel: 2, level: 0, prerequisites: ["tough_skin"] },
          { id: "immovable", name: "Immovable", description: "Cannot be knocked back or stunned", cost: 6, maxLevel: 1, level: 0, prerequisites: ["fortress"] },
          { id: "damage_reflection", name: "Damage Reflection", description: "Reflect 25% of damage taken back to attacker", cost: 7, maxLevel: 2, level: 0, prerequisites: ["magic_resistance"] },
          { id: "thorns", name: "Thorns", description: "Melee attackers take 50 damage", cost: 4, maxLevel: 3, level: 0, prerequisites: ["damage_reflection"] },
          { id: "retaliation", name: "Retaliation", description: "Taking damage increases next attack by 100%", cost: 5, maxLevel: 2, level: 0, prerequisites: ["thorns"] },
          { id: "last_stand", name: "Last Stand", description: "At 25% health, gain 200% damage and 100% armor", cost: 8, maxLevel: 1, level: 0, prerequisites: ["retaliation"] },
          { id: "guardian", name: "Guardian", description: "Nearby allies take 25% less damage", cost: 6, maxLevel: 2, level: 0, prerequisites: ["immovable"] },
          { id: "protector", name: "Protector", description: "Allies gain 50% of your armor", cost: 7, maxLevel: 1, level: 0, prerequisites: ["guardian"] },
          { id: "defensive_mastery", name: "Defensive Mastery", description: "All defense skills gain +1 level", cost: 15, maxLevel: 1, level: 0, prerequisites: ["last_stand", "protector"] },
          // Additional defense nodes to reach 25
          { id: "endurance", name: "Endurance", description: "Reduces stamina cost of abilities by 20%", cost: 2, maxLevel: 3, level: 0, prerequisites: ["health_boost"] },
          { id: "iron_will", name: "Iron Will", description: "Immune to fear and charm effects", cost: 4, maxLevel: 1, level: 0, prerequisites: ["endurance"] },
          { id: "unbreakable", name: "Unbreakable", description: "Cannot be killed by a single attack", cost: 8, maxLevel: 1, level: 0, prerequisites: ["iron_will"] },
          { id: "resilience", name: "Resilience", description: "Status effects last 50% less time", cost: 3, maxLevel: 3, level: 0, prerequisites: ["magic_resistance"] },
          { id: "adaptation", name: "Adaptation", description: "Gain resistance to damage types you take", cost: 5, maxLevel: 2, level: 0, prerequisites: ["resilience"] },
          { id: "immunity", name: "Immunity", description: "Become immune to the most common damage type", cost: 10, maxLevel: 1, level: 0, prerequisites: ["adaptation"] }
        ]
      },
      // Utility tree (25 nodes)
      utility: {
        name: "Utility Mastery",
        description: "Enhance your utility and support abilities",
        nodes: [
          // Basic utility nodes
          { id: "movement_speed", name: "Movement Speed", description: "Increases movement speed by 10%", cost: 1, maxLevel: 5, level: 0, prerequisites: [] },
          { id: "jump_height", name: "Jump Height", description: "Increases jump height by 20%", cost: 1, maxLevel: 3, level: 0, prerequisites: ["movement_speed"] },
          { id: "climbing", name: "Climbing", description: "Can climb walls and obstacles", cost: 3, maxLevel: 1, level: 0, prerequisites: ["jump_height"] },
          { id: "swimming", name: "Swimming", description: "Move faster in water", cost: 2, maxLevel: 3, level: 0, prerequisites: ["movement_speed"] },
          { id: "stealth", name: "Stealth", description: "Become invisible for 5 seconds", cost: 4, maxLevel: 3, level: 0, prerequisites: [] },
          { id: "detection", name: "Detection", description: "See hidden enemies and traps", cost: 3, maxLevel: 2, level: 0, prerequisites: ["stealth"] },
          { id: "lockpicking", name: "Lockpicking", description: "Open locked chests and doors", cost: 2, maxLevel: 3, level: 0, prerequisites: [] },
          { id: "treasure_hunter", name: "Treasure Hunter", description: "Find more valuable loot", cost: 3, maxLevel: 3, level: 0, prerequisites: ["lockpicking"] },
          { id: "bargaining", name: "Bargaining", description: "Buy items for 20% less, sell for 20% more", cost: 2, maxLevel: 3, level: 0, prerequisites: [] },
          { id: "charisma", name: "Charisma", description: "NPCs are more friendly and helpful", cost: 3, maxLevel: 2, level: 0, prerequisites: ["bargaining"] },
          // Advanced utility nodes
          { id: "teleport", name: "Teleport", description: "Instantly move to any visited location", cost: 8, maxLevel: 1, level: 0, prerequisites: ["climbing", "swimming"] },
          { id: "time_dilation", name: "Time Dilation", description: "Slow down time for 10 seconds", cost: 10, maxLevel: 1, level: 0, prerequisites: ["detection"] },
          { id: "phase_shift", name: "Phase Shift", description: "Become intangible for 3 seconds", cost: 6, maxLevel: 2, level: 0, prerequisites: ["stealth"] },
          { id: "shadow_step", name: "Shadow Step", description: "Teleport behind the nearest enemy", cost: 7, maxLevel: 1, level: 0, prerequisites: ["phase_shift"] },
          { id: "utility_mastery", name: "Utility Mastery", description: "All utility skills gain +1 level", cost: 15, maxLevel: 1, level: 0, prerequisites: ["teleport", "time_dilation", "shadow_step"] },
          // Additional utility nodes to reach 25
          { id: "night_vision", name: "Night Vision", description: "See clearly in darkness", cost: 2, maxLevel: 2, level: 0, prerequisites: ["detection"] },
          { id: "eagle_eye", name: "Eagle Eye", description: "See enemies from much farther away", cost: 4, maxLevel: 1, level: 0, prerequisites: ["night_vision"] },
          { id: "quick_hands", name: "Quick Hands", description: "Use items and abilities 50% faster", cost: 3, maxLevel: 3, level: 0, prerequisites: ["movement_speed"] },
          { id: "nimble_fingers", name: "Nimble Fingers", description: "Pickpocket and disarm traps", cost: 4, maxLevel: 2, level: 0, prerequisites: ["quick_hands"] },
          { id: "master_thief", name: "Master Thief", description: "Steal from enemies without being detected", cost: 6, maxLevel: 1, level: 0, prerequisites: ["nimble_fingers"] },
          { id: "diplomat", name: "Diplomat", description: "Resolve conflicts without fighting", cost: 5, maxLevel: 2, level: 0, prerequisites: ["charisma"] },
          { id: "peacemaker", name: "Peacemaker", description: "Stop combat between NPCs", cost: 7, maxLevel: 1, level: 0, prerequisites: ["diplomat"] },
          { id: "survivalist", name: "Survivalist", description: "Find food and water in wilderness", cost: 3, maxLevel: 2, level: 0, prerequisites: ["treasure_hunter"] },
          { id: "tracker", name: "Tracker", description: "Follow enemy tracks and trails", cost: 4, maxLevel: 2, level: 0, prerequisites: ["survivalist"] },
          { id: "beast_master", name: "Beast Master", description: "Tame and command animals", cost: 8, maxLevel: 1, level: 0, prerequisites: ["tracker"] }
        ]
      },
      // Specialization trees (20 nodes each)
      warrior: {
        name: "Warrior Specialization",
        description: "Master the art of melee combat",
        nodes: [
          { id: "berserker_rage", name: "Berserker Rage", description: "Enter rage mode, increasing damage and speed", cost: 5, maxLevel: 3, level: 0, prerequisites: [] },
          { id: "battle_cry", name: "Battle Cry", description: "Intimidate enemies and boost allies", cost: 4, maxLevel: 2, level: 0, prerequisites: ["berserker_rage"] },
          { id: "weapon_expertise", name: "Weapon Expertise", description: "Master specific weapon types", cost: 6, maxLevel: 1, level: 0, prerequisites: ["battle_cry"] },
          { id: "tactical_mind", name: "Tactical Mind", description: "Plan attacks for maximum effectiveness", cost: 5, maxLevel: 2, level: 0, prerequisites: ["weapon_expertise"] },
          { id: "war_master", name: "War Master", description: "Ultimate warrior abilities", cost: 10, maxLevel: 1, level: 0, prerequisites: ["tactical_mind"] }
          // Additional warrior nodes...
        ]
      },
      mage: {
        name: "Mage Specialization",
        description: "Master the arcane arts",
        nodes: [
          { id: "spell_casting", name: "Spell Casting", description: "Cast powerful magical spells", cost: 5, maxLevel: 3, level: 0, prerequisites: [] },
          { id: "mana_mastery", name: "Mana Mastery", description: "Efficient mana usage and regeneration", cost: 4, maxLevel: 2, level: 0, prerequisites: ["spell_casting"] },
          { id: "elemental_mastery", name: "Elemental Mastery", description: "Control fire, ice, and lightning", cost: 6, maxLevel: 1, level: 0, prerequisites: ["mana_mastery"] },
          { id: "arcane_knowledge", name: "Arcane Knowledge", description: "Learn ancient magical secrets", cost: 5, maxLevel: 2, level: 0, prerequisites: ["elemental_mastery"] },
          { id: "archmage", name: "Archmage", description: "Ultimate magical abilities", cost: 10, maxLevel: 1, level: 0, prerequisites: ["arcane_knowledge"] }
          // Additional mage nodes...
        ]
      },
      rogue: {
        name: "Rogue Specialization",
        description: "Master stealth and precision",
        nodes: [
          { id: "stealth_mastery", name: "Stealth Mastery", description: "Advanced stealth techniques", cost: 5, maxLevel: 3, level: 0, prerequisites: [] },
          { id: "assassination", name: "Assassination", description: "Deadly precision strikes", cost: 4, maxLevel: 2, level: 0, prerequisites: ["stealth_mastery"] },
          { id: "poison_mastery", name: "Poison Mastery", description: "Craft and apply deadly poisons", cost: 6, maxLevel: 1, level: 0, prerequisites: ["assassination"] },
          { id: "shadow_arts", name: "Shadow Arts", description: "Manipulate shadows and darkness", cost: 5, maxLevel: 2, level: 0, prerequisites: ["poison_mastery"] },
          { id: "shadow_master", name: "Shadow Master", description: "Ultimate rogue abilities", cost: 10, maxLevel: 1, level: 0, prerequisites: ["shadow_arts"] }
          // Additional rogue nodes...
        ]
      }
    };
  }
  /**
   * Initialize skill gem system
   */
  initializeSkillGems() {
    return {
      // Basic gems
      basic: [
        { id: "fire_ball", name: "Fire Ball", description: "Launch a fireball at enemies", type: "offensive", level: 1, rarity: "common", effects: { damage: 50, element: "fire" } },
        { id: "heal", name: "Heal", description: "Restore health over time", type: "support", level: 1, rarity: "common", effects: { healing: 25, duration: 5 } },
        { id: "shield", name: "Shield", description: "Create a protective barrier", type: "defensive", level: 1, rarity: "common", effects: { absorption: 100, duration: 10 } },
        { id: "speed_boost", name: "Speed Boost", description: "Increase movement speed", type: "utility", level: 1, rarity: "common", effects: { speed: 1.5, duration: 8 } }
      ],
      // Advanced gems
      advanced: [
        { id: "meteor", name: "Meteor", description: "Summon a meteor from the sky", type: "offensive", level: 3, rarity: "rare", effects: { damage: 200, area: 100, element: "fire" } },
        { id: "regeneration", name: "Regeneration", description: "Continuous health regeneration", type: "support", level: 3, rarity: "rare", effects: { healing: 10, duration: 30 } },
        { id: "barrier", name: "Barrier", description: "Absorb all damage for a short time", type: "defensive", level: 3, rarity: "rare", effects: { absorption: 500, duration: 5 } },
        { id: "teleport", name: "Teleport", description: "Instantly move to target location", type: "utility", level: 3, rarity: "rare", effects: { range: 200 } }
      ],
      // Legendary gems
      legendary: [
        { id: "apocalypse", name: "Apocalypse", description: "Devastating area damage spell", type: "offensive", level: 5, rarity: "legendary", effects: { damage: 1e3, area: 300, element: "all" } },
        { id: "immortality", name: "Immortality", description: "Become invulnerable for a short time", type: "defensive", level: 5, rarity: "legendary", effects: { invulnerability: true, duration: 10 } },
        { id: "time_stop", name: "Time Stop", description: "Stop time for all enemies", type: "utility", level: 5, rarity: "legendary", effects: { duration: 15 } }
      ]
    };
  }
  /**
   * Initialize socketing system
   */
  initializeSocketingSystem() {
    return {
      socketTypes: ["weapon", "armor", "accessory", "gem"],
      maxSockets: {
        weapon: 6,
        armor: 4,
        accessory: 2,
        gem: 1
      },
      socketRules: {
        weapon: ["offensive", "utility"],
        armor: ["defensive", "support"],
        accessory: ["utility", "support"],
        gem: ["all"]
      }
    };
  }
  /**
   * Initialize trading system
   */
  initializeTradingSystem() {
    return {
      isEnabled: true,
      tradeChannels: ["global", "guild", "whisper"],
      maxTradeValue: 1e6,
      tradeTax: 0.05,
      // 5% tax on trades
      reputation: {
        level: 0,
        points: 0,
        benefits: []
      }
    };
  }
  /**
   * Create UI elements
   */
  createUIElements() {
    const mainContainer = document.createElement("div");
    mainContainer.id = "arpg-ui-container";
    mainContainer.className = "arpg-ui-container";
    mainContainer.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      z-index: 1000;
    `;
    const characterPanel = this.createCharacterPanel();
    mainContainer.appendChild(characterPanel);
    const skillTreePanel = this.createSkillTreePanel();
    mainContainer.appendChild(skillTreePanel);
    const inventoryPanel = this.createInventoryPanel();
    mainContainer.appendChild(inventoryPanel);
    const tradingPanel = this.createTradingPanel();
    mainContainer.appendChild(tradingPanel);
    const socketingPanel = this.createSocketingPanel();
    mainContainer.appendChild(socketingPanel);
    document.body.appendChild(mainContainer);
    this.uiElements.set("mainContainer", mainContainer);
  }
  /**
   * Create character panel
   */
  createCharacterPanel() {
    const panel = document.createElement("div");
    panel.id = "character-panel";
    panel.className = "character-panel";
    panel.style.cssText = `
      position: absolute;
      top: 50px;
      left: 50px;
      width: 400px;
      height: 600px;
      background: linear-gradient(135deg, #2c3e50, #34495e);
      border: 2px solid #3498db;
      border-radius: 10px;
      padding: 20px;
      color: white;
      font-family: 'Arial', sans-serif;
    `;
    const statsHTML = `
      <div class="character-header">
        <h2>Character</h2>
        <div class="level-display">
          <span>Level: <span id="character-level">${this.character.level}</span></span>
          <div class="exp-bar">
            <div class="exp-fill" style="width: ${this.character.experience / this.character.experienceToNext * 100}%"></div>
          </div>
          <span>XP: <span id="character-exp">${this.character.experience}</span>/<span id="character-exp-max">${this.character.experienceToNext}</span></span>
        </div>
      </div>
      
      <div class="attributes-section">
        <h3>Attributes</h3>
        <div class="attribute-list">
          ${Object.entries(this.character.attributes).map(([attr, value]) => `
            <div class="attribute-item">
              <span class="attr-name">${attr.charAt(0).toUpperCase() + attr.slice(1)}:</span>
              <span class="attr-value">${value}</span>
              <button class="attr-increase" data-attr="${attr}">+</button>
            </div>
          `).join("")}
        </div>
        <div class="attribute-points">
          Available Points: <span id="attr-points">${this.character.attributePoints}</span>
        </div>
      </div>
      
      <div class="stats-section">
        <h3>Stats</h3>
        <div class="stat-list">
          ${Object.entries(this.character.stats).map(([stat, value]) => `
            <div class="stat-item">
              <span class="stat-name">${stat.charAt(0).toUpperCase() + stat.slice(1)}:</span>
              <span class="stat-value">${value}</span>
            </div>
          `).join("")}
        </div>
      </div>
      
      <div class="equipment-section">
        <h3>Equipment</h3>
        <div class="equipment-grid">
          <div class="equipment-slot" data-slot="helmet">Helmet</div>
          <div class="equipment-slot" data-slot="weapon">Weapon</div>
          <div class="equipment-slot" data-slot="armor">Armor</div>
          <div class="equipment-slot" data-slot="gloves">Gloves</div>
          <div class="equipment-slot" data-slot="boots">Boots</div>
          <div class="equipment-slot" data-slot="ring1">Ring 1</div>
          <div class="equipment-slot" data-slot="ring2">Ring 2</div>
          <div class="equipment-slot" data-slot="amulet">Amulet</div>
        </div>
      </div>
    `;
    panel.innerHTML = statsHTML;
    return panel;
  }
  /**
   * Create skill tree panel
   */
  createSkillTreePanel() {
    const panel = document.createElement("div");
    panel.id = "skill-tree-panel";
    panel.className = "skill-tree-panel";
    panel.style.cssText = `
      position: absolute;
      top: 50px;
      left: 500px;
      width: 800px;
      height: 600px;
      background: linear-gradient(135deg, #2c3e50, #34495e);
      border: 2px solid #e74c3c;
      border-radius: 10px;
      padding: 20px;
      color: white;
      font-family: 'Arial', sans-serif;
      display: none;
    `;
    const tabsHTML = `
      <div class="skill-tree-tabs">
        ${Object.keys(this.skillTree).map((treeName) => `
          <button class="skill-tree-tab ${treeName === "combat" ? "active" : ""}" data-tree="${treeName}">
            ${this.skillTree[treeName].name}
          </button>
        `).join("")}
      </div>
      
      <div class="skill-tree-content">
        <div class="skill-tree-header">
          <h3 id="current-tree-name">Combat Mastery</h3>
          <p id="current-tree-desc">Enhance your combat abilities</p>
          <div class="skill-points">
            Available Points: <span id="skill-points">${this.character.skillPoints}</span>
          </div>
        </div>
        
        <div class="skill-tree-nodes" id="skill-tree-nodes">
          <!-- Nodes will be dynamically generated -->
        </div>
      </div>
    `;
    panel.innerHTML = tabsHTML;
    return panel;
  }
  /**
   * Create inventory panel
   */
  createInventoryPanel() {
    const panel = document.createElement("div");
    panel.id = "inventory-panel";
    panel.className = "inventory-panel";
    panel.style.cssText = `
      position: absolute;
      top: 50px;
      right: 50px;
      width: 400px;
      height: 600px;
      background: linear-gradient(135deg, #2c3e50, #34495e);
      border: 2px solid #f39c12;
      border-radius: 10px;
      padding: 20px;
      color: white;
      font-family: 'Arial', sans-serif;
      display: none;
    `;
    const inventoryHTML = `
      <div class="inventory-header">
        <h3>Inventory</h3>
        <div class="inventory-tabs">
          <button class="inv-tab active" data-tab="items">Items</button>
          <button class="inv-tab" data-tab="gems">Gems</button>
          <button class="inv-tab" data-tab="materials">Materials</button>
        </div>
      </div>
      
      <div class="inventory-grid" id="inventory-grid">
        <!-- Inventory slots will be dynamically generated -->
      </div>
      
      <div class="inventory-info">
        <div class="item-details" id="item-details">
          <!-- Item details will be shown here -->
        </div>
      </div>
    `;
    panel.innerHTML = inventoryHTML;
    return panel;
  }
  /**
   * Create trading panel
   */
  createTradingPanel() {
    const panel = document.createElement("div");
    panel.id = "trading-panel";
    panel.className = "trading-panel";
    panel.style.cssText = `
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 600px;
      height: 500px;
      background: linear-gradient(135deg, #2c3e50, #34495e);
      border: 2px solid #9b59b6;
      border-radius: 10px;
      padding: 20px;
      color: white;
      font-family: 'Arial', sans-serif;
      display: none;
    `;
    const tradingHTML = `
      <div class="trading-header">
        <h3>Player Trading</h3>
        <button class="close-trading">×</button>
      </div>
      
      <div class="trading-content">
        <div class="trade-channels">
          <button class="channel-btn active" data-channel="global">Global</button>
          <button class="channel-btn" data-channel="guild">Guild</button>
          <button class="channel-btn" data-channel="whisper">Whisper</button>
        </div>
        
        <div class="trade-offers" id="trade-offers">
          <!-- Trade offers will be listed here -->
        </div>
        
        <div class="create-trade">
          <h4>Create Trade Offer</h4>
          <div class="trade-form">
            <input type="text" placeholder="Item to trade" id="trade-item">
            <input type="text" placeholder="Item wanted" id="trade-wanted">
            <button id="create-trade-btn">Create Offer</button>
          </div>
        </div>
      </div>
    `;
    panel.innerHTML = tradingHTML;
    return panel;
  }
  /**
   * Create socketing panel
   */
  createSocketingPanel() {
    const panel = document.createElement("div");
    panel.id = "socketing-panel";
    panel.className = "socketing-panel";
    panel.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      height: 400px;
      background: linear-gradient(135deg, #2c3e50, #34495e);
      border: 2px solid #1abc9c;
      border-radius: 10px;
      padding: 20px;
      color: white;
      font-family: 'Arial', sans-serif;
      display: none;
    `;
    const socketingHTML = `
      <div class="socketing-header">
        <h3>Gem Socketing</h3>
        <button class="close-socketing">×</button>
      </div>
      
      <div class="socketing-content">
        <div class="item-sockets">
          <h4>Item Sockets</h4>
          <div class="socket-grid" id="socket-grid">
            <!-- Sockets will be dynamically generated -->
          </div>
        </div>
        
        <div class="available-gems">
          <h4>Available Gems</h4>
          <div class="gem-list" id="gem-list">
            <!-- Gems will be dynamically generated -->
          </div>
        </div>
        
        <div class="socketing-actions">
          <button id="socket-gem" disabled>Socket Gem</button>
          <button id="remove-gem">Remove Gem</button>
        </div>
      </div>
    `;
    panel.innerHTML = socketingHTML;
    return panel;
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("character:levelUp", this.handleLevelUp.bind(this));
    this.eventBus.on("character:attributeChanged", this.handleAttributeChange.bind(this));
    this.eventBus.on("character:skillLearned", this.handleSkillLearned.bind(this));
    this.eventBus.on("item:equipped", this.handleItemEquipped.bind(this));
    this.eventBus.on("item:unequipped", this.handleItemUnequipped.bind(this));
    this.eventBus.on("item:gemSocketed", this.handleGemSocketed.bind(this));
    this.eventBus.on("trade:offerCreated", this.handleTradeOfferCreated.bind(this));
    this.eventBus.on("trade:offerAccepted", this.handleTradeOfferAccepted.bind(this));
    this.eventBus.on("ui:openARPG", this.openARPGUI.bind(this));
    this.eventBus.on("ui:closeARPG", this.closeARPGUI.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("character:levelUp", this.handleLevelUp.bind(this));
    this.eventBus.removeListener("character:attributeChanged", this.handleAttributeChange.bind(this));
    this.eventBus.removeListener("character:skillLearned", this.handleSkillLearned.bind(this));
    this.eventBus.removeListener("item:equipped", this.handleItemEquipped.bind(this));
    this.eventBus.removeListener("item:unequipped", this.handleItemUnequipped.bind(this));
    this.eventBus.removeListener("item:gemSocketed", this.handleGemSocketed.bind(this));
    this.eventBus.removeListener("trade:offerCreated", this.handleTradeOfferCreated.bind(this));
    this.eventBus.removeListener("trade:offerAccepted", this.handleTradeOfferAccepted.bind(this));
    this.eventBus.removeListener("ui:openARPG", this.openARPGUI.bind(this));
    this.eventBus.removeListener("ui:closeARPG", this.closeARPGUI.bind(this));
  }
  /**
   * Set up UI event listeners
   */
  setupUIEventListeners() {
    const mainContainer = this.uiElements.get("mainContainer");
    if (mainContainer) {
      mainContainer.addEventListener("click", (e) => {
        if (e.target === mainContainer) {
          this.closeARPGUI();
        }
      });
    }
    this.setupTabSwitching();
    this.setupSkillTreeInteractions();
    this.setupInventoryInteractions();
    this.setupTradingInteractions();
    this.setupSocketingInteractions();
  }
  /**
   * Set up tab switching
   */
  setupTabSwitching() {
    const characterPanel = document.getElementById("character-panel");
    if (characterPanel) {
      const tabHTML = `
        <div class="character-tabs">
          <button class="char-tab active" data-tab="stats">Stats</button>
          <button class="char-tab" data-tab="skills">Skills</button>
          <button class="char-tab" data-tab="equipment">Equipment</button>
        </div>
      `;
      characterPanel.insertAdjacentHTML("afterbegin", tabHTML);
    }
  }
  /**
   * Set up skill tree interactions
   */
  setupSkillTreeInteractions() {
    const skillTreeTabs = document.querySelectorAll(".skill-tree-tab");
    skillTreeTabs.forEach((tab) => {
      tab.addEventListener("click", (e) => {
        const treeName = e.target.dataset.tree;
        this.switchSkillTree(treeName);
      });
    });
    this.generateSkillTreeNodes();
  }
  /**
   * Set up inventory interactions
   */
  setupInventoryInteractions() {
    const inventoryTabs = document.querySelectorAll(".inv-tab");
    inventoryTabs.forEach((tab) => {
      tab.addEventListener("click", (e) => {
        const tabName = e.target.dataset.tab;
        this.switchInventoryTab(tabName);
      });
    });
    this.generateInventoryGrid();
  }
  /**
   * Set up trading interactions
   */
  setupTradingInteractions() {
    const channelBtns = document.querySelectorAll(".channel-btn");
    channelBtns.forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const channel = e.target.dataset.channel;
        this.switchTradeChannel(channel);
      });
    });
    const createTradeBtn = document.getElementById("create-trade-btn");
    if (createTradeBtn) {
      createTradeBtn.addEventListener("click", this.createTradeOffer.bind(this));
    }
    const closeTrading = document.querySelector(".close-trading");
    if (closeTrading) {
      closeTrading.addEventListener("click", this.closeTradingPanel.bind(this));
    }
  }
  /**
   * Set up socketing interactions
   */
  setupSocketingInteractions() {
    const socketGemBtn = document.getElementById("socket-gem");
    if (socketGemBtn) {
      socketGemBtn.addEventListener("click", this.socketGem.bind(this));
    }
    const removeGemBtn = document.getElementById("remove-gem");
    if (removeGemBtn) {
      removeGemBtn.addEventListener("click", this.removeGem.bind(this));
    }
    const closeSocketing = document.querySelector(".close-socketing");
    if (closeSocketing) {
      closeSocketing.addEventListener("click", this.closeSocketingPanel.bind(this));
    }
  }
  /**
   * Generate skill tree nodes
   */
  generateSkillTreeNodes() {
    const nodesContainer = document.getElementById("skill-tree-nodes");
    if (!nodesContainer) return;
    const currentTree = this.getCurrentSkillTree();
    if (!currentTree) return;
    nodesContainer.innerHTML = "";
    currentTree.nodes.forEach((node) => {
      const nodeElement = document.createElement("div");
      nodeElement.className = `skill-node ${node.level > 0 ? "learned" : ""} ${this.canLearnSkill(node) ? "available" : "locked"}`;
      nodeElement.dataset.nodeId = node.id;
      nodeElement.innerHTML = `
        <div class="node-icon">${node.name.charAt(0)}</div>
        <div class="node-info">
          <div class="node-name">${node.name}</div>
          <div class="node-level">${node.level}/${node.maxLevel}</div>
        </div>
        <div class="node-cost">${node.cost}</div>
      `;
      nodeElement.addEventListener("click", () => this.learnSkill(node.id));
      nodesContainer.appendChild(nodeElement);
    });
  }
  /**
   * Generate inventory grid
   */
  generateInventoryGrid() {
    const grid = document.getElementById("inventory-grid");
    if (!grid) return;
    grid.innerHTML = "";
    for (let i = 0; i < 40; i++) {
      const slot = document.createElement("div");
      slot.className = "inventory-slot";
      slot.dataset.slot = i;
      const item = this.character.inventory[i];
      if (item) {
        slot.innerHTML = `
          <div class="item-icon" style="background-color: ${this.getItemRarityColor(item.rarity)}">
            ${item.name.charAt(0)}
          </div>
          <div class="item-count">${item.count || 1}</div>
        `;
        slot.addEventListener("click", () => this.selectItem(item, i));
      }
      grid.appendChild(slot);
    }
  }
  /**
   * Open ARPG UI
   */
  openARPGUI() {
    const container = this.uiElements.get("mainContainer");
    if (container) {
      container.style.display = "block";
      this.uiState.isOpen = true;
      this.updateCharacterDisplay();
    }
  }
  /**
   * Close ARPG UI
   */
  closeARPGUI() {
    const container = this.uiElements.get("mainContainer");
    if (container) {
      container.style.display = "none";
      this.uiState.isOpen = false;
    }
  }
  /**
   * Switch skill tree
   */
  switchSkillTree(treeName) {
    document.querySelectorAll(".skill-tree-tab").forEach((tab) => {
      tab.classList.remove("active");
    });
    document.querySelector(`[data-tree="${treeName}"]`).classList.add("active");
    const tree = this.skillTree[treeName];
    document.getElementById("current-tree-name").textContent = tree.name;
    document.getElementById("current-tree-desc").textContent = tree.description;
    this.generateSkillTreeNodes();
  }
  /**
   * Switch inventory tab
   */
  switchInventoryTab(tabName) {
    document.querySelectorAll(".inv-tab").forEach((tab) => {
      tab.classList.remove("active");
    });
    document.querySelector(`[data-tab="${tabName}"]`).classList.add("active");
    this.updateInventoryContent(tabName);
  }
  /**
   * Switch trade channel
   */
  switchTradeChannel(channel) {
    document.querySelectorAll(".channel-btn").forEach((btn) => {
      btn.classList.remove("active");
    });
    document.querySelector(`[data-channel="${channel}"]`).classList.add("active");
    this.loadTradeOffers(channel);
  }
  /**
   * Learn a skill
   */
  learnSkill(skillId) {
    const currentTree = this.getCurrentSkillTree();
    const skill = currentTree.nodes.find((n) => n.id === skillId);
    if (!skill || !this.canLearnSkill(skill)) {
      this.logger.warn(`Cannot learn skill: ${skillId}`);
      return;
    }
    if (this.character.skillPoints < skill.cost) {
      this.logger.warn("Not enough skill points");
      return;
    }
    skill.level++;
    this.character.skillPoints -= skill.cost;
    this.applySkillEffects(skill);
    this.updateCharacterDisplay();
    this.generateSkillTreeNodes();
    this.eventBus.emit("character:skillLearned", {
      skillId,
      skill,
      character: this.character
    });
    this.logger.info(`Learned skill: ${skill.name}`);
  }
  /**
   * Check if skill can be learned
   */
  canLearnSkill(skill) {
    if (skill.level >= skill.maxLevel) return false;
    if (this.character.skillPoints < skill.cost) return false;
    for (const prereq of skill.prerequisites) {
      const prereqSkill = this.findSkillById(prereq);
      if (!prereqSkill || prereqSkill.level === 0) return false;
    }
    return true;
  }
  /**
   * Find skill by ID across all trees
   */
  findSkillById(skillId) {
    for (const tree of Object.values(this.skillTree)) {
      const skill = tree.nodes.find((n) => n.id === skillId);
      if (skill) return skill;
    }
    return null;
  }
  /**
   * Apply skill effects
   */
  applySkillEffects(skill) {
    this.logger.info(`Applied effects for skill: ${skill.name}`);
  }
  /**
   * Get current skill tree
   */
  getCurrentSkillTree() {
    const activeTab = document.querySelector(".skill-tree-tab.active");
    if (!activeTab) return this.skillTree.combat;
    const treeName = activeTab.dataset.tree;
    return this.skillTree[treeName];
  }
  /**
   * Update character display
   */
  updateCharacterDisplay() {
    document.getElementById("character-level").textContent = this.character.level;
    document.getElementById("character-exp").textContent = this.character.experience;
    document.getElementById("character-exp-max").textContent = this.character.experienceToNext;
    const expBar = document.querySelector(".exp-fill");
    if (expBar) {
      expBar.style.width = `${this.character.experience / this.character.experienceToNext * 100}%`;
    }
    document.getElementById("skill-points").textContent = this.character.skillPoints;
    document.getElementById("attr-points").textContent = this.character.attributePoints;
    Object.entries(this.character.attributes).forEach(([attr, value]) => {
      const attrElement = document.querySelector(`[data-attr="${attr}"]`);
      if (attrElement) {
        attrElement.previousElementSibling.textContent = value;
      }
    });
    Object.entries(this.character.stats).forEach(([stat, value]) => {
      const statElement = document.querySelector(`[data-stat="${stat}"]`);
      if (statElement) {
        statElement.textContent = value;
      }
    });
  }
  /**
   * Update character stats based on attributes
   */
  updateCharacterStats() {
    this.character.stats.maxHealth = 100 + this.character.attributes.vitality * 10;
    this.character.stats.maxMana = 50 + this.character.attributes.intelligence * 5;
    this.character.stats.damage = 10 + this.character.attributes.strength * 2;
    this.character.stats.armor = this.character.attributes.vitality * 0.5;
    this.character.stats.criticalChance = 0.05 + this.character.attributes.dexterity * 0.01;
    this.character.stats.attackSpeed = 1 + this.character.attributes.dexterity * 0.02;
    this.character.stats.movementSpeed = 1 + this.character.attributes.strength * 0.01;
  }
  /**
   * Update UI animations
   */
  updateUIAnimations(deltaTime) {
  }
  /**
   * Update skill cooldowns
   */
  updateSkillCooldowns(deltaTime) {
  }
  /**
   * Handle level up
   */
  handleLevelUp(data) {
    this.character.level++;
    this.character.skillPoints += 2;
    this.character.attributePoints += 5;
    this.character.experienceToNext = Math.floor(this.character.experienceToNext * 1.2);
    this.updateCharacterDisplay();
    this.logger.info(`Character leveled up to level ${this.character.level}`);
  }
  /**
   * Handle attribute change
   */
  handleAttributeChange(data) {
    this.character.attributes[data.attribute] += data.change;
    this.character.attributePoints -= data.cost;
    this.updateCharacterStats();
    this.updateCharacterDisplay();
    this.logger.info(`Attribute ${data.attribute} changed by ${data.change}`);
  }
  /**
   * Handle skill learned
   */
  handleSkillLearned(data) {
    this.logger.info(`Skill learned: ${data.skill.name}`);
  }
  /**
   * Handle item equipped
   */
  handleItemEquipped(data) {
    this.character.equippedItems.set(data.slot, data.item);
    this.updateCharacterDisplay();
    this.logger.info(`Item equipped: ${data.item.name}`);
  }
  /**
   * Handle item unequipped
   */
  handleItemUnequipped(data) {
    this.character.equippedItems.delete(data.slot);
    this.updateCharacterDisplay();
    this.logger.info(`Item unequipped: ${data.item.name}`);
  }
  /**
   * Handle gem socketed
   */
  handleGemSocketed(data) {
    this.logger.info(`Gem socketed: ${data.gem.name}`);
  }
  /**
   * Handle trade offer created
   */
  handleTradeOfferCreated(data) {
    this.logger.info(`Trade offer created: ${data.offer.item} for ${data.offer.wanted}`);
  }
  /**
   * Handle trade offer accepted
   */
  handleTradeOfferAccepted(data) {
    this.logger.info(`Trade offer accepted: ${data.offer.id}`);
  }
  /**
   * Create trade offer
   */
  createTradeOffer() {
    const itemInput = document.getElementById("trade-item");
    const wantedInput = document.getElementById("trade-wanted");
    if (!itemInput.value || !wantedInput.value) {
      this.logger.warn("Please fill in both item fields");
      return;
    }
    const offer = {
      id: Date.now(),
      item: itemInput.value,
      wanted: wantedInput.value,
      timestamp: Date.now()
    };
    this.eventBus.emit("trade:offerCreated", { offer });
    itemInput.value = "";
    wantedInput.value = "";
  }
  /**
   * Load trade offers
   */
  loadTradeOffers(channel) {
    this.logger.info(`Loading trade offers for channel: ${channel}`);
  }
  /**
   * Socket gem
   */
  socketGem() {
    if (!this.uiState.selectedItem || !this.uiState.selectedGem) {
      this.logger.warn("Please select an item and gem to socket");
      return;
    }
    this.eventBus.emit("item:gemSocketed", {
      item: this.uiState.selectedItem,
      gem: this.uiState.selectedGem
    });
    this.closeSocketingPanel();
  }
  /**
   * Remove gem
   */
  removeGem() {
    if (!this.uiState.selectedItem) {
      this.logger.warn("Please select an item to remove gem from");
      return;
    }
    this.logger.info("Gem removed from item");
  }
  /**
   * Close trading panel
   */
  closeTradingPanel() {
    document.getElementById("trading-panel").style.display = "none";
  }
  /**
   * Close socketing panel
   */
  closeSocketingPanel() {
    document.getElementById("socketing-panel").style.display = "none";
  }
  /**
   * Select item
   */
  selectItem(item, slotIndex) {
    this.uiState.selectedItem = { ...item, slotIndex };
    this.updateItemDetails(item);
  }
  /**
   * Update item details
   */
  updateItemDetails(item) {
    const detailsContainer = document.getElementById("item-details");
    if (!detailsContainer) return;
    detailsContainer.innerHTML = `
      <h4>${item.name}</h4>
      <p>Type: ${item.type}</p>
      <p>Rarity: ${item.rarity}</p>
      <p>Level: ${item.level}</p>
      <p>Description: ${item.description}</p>
      ${item.effects ? `<p>Effects: ${JSON.stringify(item.effects)}</p>` : ""}
    `;
  }
  /**
   * Update inventory content
   */
  updateInventoryContent(tabName) {
    this.logger.info(`Switched to inventory tab: ${tabName}`);
  }
  /**
   * Get item rarity color
   */
  getItemRarityColor(rarity) {
    const colors = {
      common: "#ffffff",
      uncommon: "#1eff00",
      rare: "#0070dd",
      epic: "#a335ee",
      legendary: "#ff8000"
    };
    return colors[rarity] || colors.common;
  }
  /**
   * Load character data
   */
  async loadCharacterData() {
    try {
      const savedData = localStorage.getItem("arpgCharacter");
      if (savedData) {
        const data = JSON.parse(savedData);
        this.character = { ...this.character, ...data };
        this.logger.info("Character data loaded");
      }
    } catch (error) {
      this.logger.error("Failed to load character data:", error);
    }
  }
  /**
   * Save character data
   */
  saveCharacterData() {
    try {
      localStorage.setItem("arpgCharacter", JSON.stringify(this.character));
      this.logger.info("Character data saved");
    } catch (error) {
      this.logger.error("Failed to save character data:", error);
    }
  }
  /**
   * Clear UI elements
   */
  clearUIElements() {
    const mainContainer = this.uiElements.get("mainContainer");
    if (mainContainer && mainContainer.parentNode) {
      mainContainer.parentNode.removeChild(mainContainer);
    }
    this.uiElements.clear();
  }
  /**
   * Get character data
   */
  getCharacter() {
    return { ...this.character };
  }
  /**
   * Get skill tree data
   */
  getSkillTree() {
    return { ...this.skillTree };
  }
  /**
   * Get skill gems
   */
  getSkillGems() {
    return { ...this.skillGems };
  }
};

// src/systems/CombatSystem.js
var CombatSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("CombatSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("CombatSystem requires logger dependency");
    }
    this.combatState = {
      isInCombat: false,
      combatStartTime: null,
      enemies: /* @__PURE__ */ new Map(),
      projectiles: /* @__PURE__ */ new Map(),
      effects: /* @__PURE__ */ new Map(),
      combos: /* @__PURE__ */ new Map(),
      lastAttackTime: 0,
      attackCooldown: 100
      // ms
    };
    this.combatConfig = {
      maxEnemies: 50,
      enemySpawnRate: 2e3,
      // ms
      projectileSpeed: 300,
      // pixels per second
      effectDuration: 1e3,
      // ms
      comboWindow: 2e3,
      // ms
      criticalHitChance: 0.05,
      criticalHitMultiplier: 1.5,
      damageTypes: ["physical", "magical", "fire", "ice", "lightning", "poison"],
      statusEffects: ["burning", "frozen", "shocked", "poisoned", "stunned", "slowed"]
    };
    this.enemyTypes = this.initializeEnemyTypes();
    this.abilities = this.initializeAbilities();
    this.damageCalculator = this.initializeDamageCalculator();
    this.setupEventHandlers();
    this.logger.info("CombatSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing CombatSystem...");
    this.setupCombatAreas();
    this.initializeEnemySpawner();
    this.logger.info("CombatSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up CombatSystem...");
    this.clearAllCombatEntities();
    this.removeEventHandlers();
    this.logger.info("CombatSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    if (!this.combatState.isInCombat) return;
    this.updateEnemies(deltaTime);
    this.updateProjectiles(deltaTime);
    this.updateEffects(deltaTime);
    this.updateCombos(deltaTime);
    this.checkCombatEnd();
    this.spawnEnemies(deltaTime);
  }
  /**
   * Initialize enemy types
   */
  initializeEnemyTypes() {
    return {
      // Basic enemies
      goblin: {
        name: "Goblin",
        health: 50,
        maxHealth: 50,
        damage: 10,
        speed: 80,
        size: { width: 24, height: 24 },
        ai: "aggressive",
        loot: { gold: [1, 5], items: ["goblin_ear"] },
        abilities: ["basic_attack"],
        resistances: { physical: 0.1 },
        weaknesses: { fire: 0.2 }
      },
      orc: {
        name: "Orc",
        health: 120,
        maxHealth: 120,
        damage: 25,
        speed: 60,
        size: { width: 32, height: 32 },
        ai: "aggressive",
        loot: { gold: [5, 15], items: ["orc_tusk"] },
        abilities: ["heavy_attack", "charge"],
        resistances: { physical: 0.2 },
        weaknesses: { magical: 0.15 }
      },
      skeleton: {
        name: "Skeleton",
        health: 80,
        maxHealth: 80,
        damage: 15,
        speed: 70,
        size: { width: 28, height: 28 },
        ai: "defensive",
        loot: { gold: [3, 10], items: ["bone_fragment"] },
        abilities: ["bone_throw", "skeleton_rise"],
        resistances: { physical: 0.3, magical: 0.1 },
        weaknesses: { fire: 0.5 }
      },
      // Elite enemies
      troll: {
        name: "Troll",
        health: 300,
        maxHealth: 300,
        damage: 40,
        speed: 40,
        size: { width: 48, height: 48 },
        ai: "aggressive",
        loot: { gold: [20, 50], items: ["troll_blood", "troll_claw"] },
        abilities: ["regeneration", "ground_slam", "berserker_rage"],
        resistances: { physical: 0.4, magical: 0.2 },
        weaknesses: { fire: 0.3 }
      },
      dragon: {
        name: "Dragon",
        health: 1e3,
        maxHealth: 1e3,
        damage: 80,
        speed: 100,
        size: { width: 64, height: 64 },
        ai: "boss",
        loot: { gold: [100, 200], items: ["dragon_scale", "dragon_heart"] },
        abilities: ["fire_breath", "wing_beat", "dragon_roar", "flight"],
        resistances: { physical: 0.6, magical: 0.4, fire: 0.8 },
        weaknesses: { ice: 0.4 }
      },
      // Special enemies
      shadow_assassin: {
        name: "Shadow Assassin",
        health: 60,
        maxHealth: 60,
        damage: 35,
        speed: 120,
        size: { width: 20, height: 20 },
        ai: "stealth",
        loot: { gold: [10, 25], items: ["shadow_cloak", "assassin_blade"] },
        abilities: ["stealth", "backstab", "shadow_step", "poison_dart"],
        resistances: { physical: 0.1, magical: 0.3 },
        weaknesses: { light: 0.5 }
      }
    };
  }
  /**
   * Initialize combat abilities
   */
  initializeAbilities() {
    return {
      // Basic attacks
      basic_attack: {
        name: "Basic Attack",
        type: "melee",
        damage: 1,
        cooldown: 1e3,
        range: 50,
        effects: [],
        animation: "slash"
      },
      heavy_attack: {
        name: "Heavy Attack",
        type: "melee",
        damage: 2,
        cooldown: 2e3,
        range: 60,
        effects: ["knockback"],
        animation: "heavy_slash"
      },
      // Ranged attacks
      fireball: {
        name: "Fireball",
        type: "projectile",
        damage: 1.5,
        cooldown: 1500,
        range: 200,
        speed: 300,
        effects: ["burning"],
        element: "fire",
        animation: "fireball_cast"
      },
      lightning_bolt: {
        name: "Lightning Bolt",
        type: "instant",
        damage: 2.5,
        cooldown: 3e3,
        range: 150,
        effects: ["shocked"],
        element: "lightning",
        animation: "lightning_cast"
      },
      // Area attacks
      whirlwind: {
        name: "Whirlwind",
        type: "area",
        damage: 0.8,
        cooldown: 4e3,
        range: 80,
        effects: ["knockback"],
        animation: "whirlwind"
      },
      meteor: {
        name: "Meteor",
        type: "area",
        damage: 3,
        cooldown: 8e3,
        range: 100,
        effects: ["burning", "knockback"],
        element: "fire",
        animation: "meteor_cast"
      },
      // Support abilities
      heal: {
        name: "Heal",
        type: "support",
        healing: 50,
        cooldown: 5e3,
        range: 0,
        effects: [],
        animation: "heal_cast"
      },
      shield: {
        name: "Shield",
        type: "buff",
        absorption: 100,
        duration: 1e4,
        cooldown: 15e3,
        effects: ["damage_absorption"],
        animation: "shield_cast"
      },
      // Special abilities
      berserker_rage: {
        name: "Berserker Rage",
        type: "buff",
        damageMultiplier: 2,
        speedMultiplier: 1.5,
        duration: 15e3,
        cooldown: 6e4,
        effects: ["damage_boost", "speed_boost"],
        animation: "rage_activation"
      },
      time_slow: {
        name: "Time Slow",
        type: "debuff",
        speedMultiplier: 0.3,
        duration: 5e3,
        cooldown: 3e4,
        range: 120,
        effects: ["slow"],
        animation: "time_slow_cast"
      }
    };
  }
  /**
   * Initialize damage calculator
   */
  initializeDamageCalculator() {
    return {
      calculateDamage: (attacker, target, ability) => {
        let baseDamage = attacker.stats.damage || 10;
        if (ability.damage) {
          baseDamage *= ability.damage;
        }
        const critChance = attacker.stats.criticalChance || 0.05;
        const critMultiplier = attacker.stats.criticalMultiplier || 1.5;
        if (Math.random() < critChance) {
          baseDamage *= critMultiplier;
          this.eventBus.emit("combat:criticalHit", { attacker, target, damage: baseDamage });
        }
        if (ability.element) {
          const resistance = target.resistances?.[ability.element] || 0;
          const weakness = target.weaknesses?.[ability.element] || 0;
          baseDamage *= 1 - resistance + weakness;
        }
        const armor = target.stats.armor || 0;
        const damageReduction = armor / (armor + 100);
        baseDamage *= 1 - damageReduction;
        return Math.max(1, Math.floor(baseDamage));
      },
      calculateHealing: (healer, target, ability) => {
        let baseHealing = ability.healing || 0;
        const healingBonus = healer.stats.healingBonus || 0;
        baseHealing *= 1 + healingBonus;
        return Math.floor(baseHealing);
      }
    };
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("combat:start", this.startCombat.bind(this));
    this.eventBus.on("combat:end", this.endCombat.bind(this));
    this.eventBus.on("combat:attack", this.handleAttack.bind(this));
    this.eventBus.on("combat:ability", this.handleAbility.bind(this));
    this.eventBus.on("combat:damage", this.handleDamage.bind(this));
    this.eventBus.on("combat:death", this.handleDeath.bind(this));
    this.eventBus.on("player:move", this.handlePlayerMove.bind(this));
    this.eventBus.on("player:ability", this.handlePlayerAbility.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("combat:start", this.startCombat.bind(this));
    this.eventBus.removeListener("combat:end", this.endCombat.bind(this));
    this.eventBus.removeListener("combat:attack", this.handleAttack.bind(this));
    this.eventBus.removeListener("combat:ability", this.handleAbility.bind(this));
    this.eventBus.removeListener("combat:damage", this.handleDamage.bind(this));
    this.eventBus.removeListener("combat:death", this.handleDeath.bind(this));
    this.eventBus.removeListener("player:move", this.handlePlayerMove.bind(this));
    this.eventBus.removeListener("player:ability", this.handlePlayerAbility.bind(this));
  }
  /**
   * Set up combat areas
   */
  setupCombatAreas() {
    this.combatAreas = [
      {
        id: "forest_clearing",
        name: "Forest Clearing",
        bounds: { x: 0, y: 0, width: 800, height: 600 },
        enemyTypes: ["goblin", "orc", "skeleton"],
        spawnPoints: [
          { x: 100, y: 100 },
          { x: 700, y: 100 },
          { x: 100, y: 500 },
          { x: 700, y: 500 }
        ]
      },
      {
        id: "cave_entrance",
        name: "Cave Entrance",
        bounds: { x: 0, y: 0, width: 600, height: 400 },
        enemyTypes: ["skeleton", "shadow_assassin"],
        spawnPoints: [
          { x: 50, y: 200 },
          { x: 550, y: 200 }
        ]
      },
      {
        id: "dragon_lair",
        name: "Dragon Lair",
        bounds: { x: 0, y: 0, width: 1e3, height: 800 },
        enemyTypes: ["troll", "dragon"],
        spawnPoints: [
          { x: 500, y: 400 }
        ]
      }
    ];
  }
  /**
   * Initialize enemy spawner
   */
  initializeEnemySpawner() {
    this.enemySpawner = {
      lastSpawnTime: 0,
      spawnInterval: this.combatConfig.enemySpawnRate,
      maxEnemies: this.combatConfig.maxEnemies,
      currentArea: null
    };
  }
  /**
   * Start combat
   */
  startCombat(areaId) {
    if (this.combatState.isInCombat) return;
    this.combatState.isInCombat = true;
    this.combatState.combatStartTime = Date.now();
    this.enemySpawner.currentArea = this.combatAreas.find((area) => area.id === areaId);
    this.logger.info(`Combat started in area: ${areaId}`);
    this.eventBus.emit("combat:started", {
      areaId,
      timestamp: this.combatState.combatStartTime
    });
  }
  /**
   * End combat
   */
  endCombat() {
    if (!this.combatState.isInCombat) return;
    this.combatState.isInCombat = false;
    this.clearAllCombatEntities();
    const combatDuration = Date.now() - this.combatState.combatStartTime;
    this.logger.info(`Combat ended after ${combatDuration}ms`);
    this.eventBus.emit("combat:ended", {
      duration: combatDuration,
      timestamp: Date.now()
    });
  }
  /**
   * Update enemies
   */
  updateEnemies(deltaTime) {
    for (const [id, enemy] of this.combatState.enemies) {
      this.updateEnemyAI(enemy, deltaTime);
      this.updateEnemyPosition(enemy, deltaTime);
      this.updateEnemyAbilities(enemy, deltaTime);
      if (enemy.health <= 0) {
        this.handleEnemyDeath(enemy);
        this.combatState.enemies.delete(id);
      }
    }
  }
  /**
   * Update enemy AI
   */
  updateEnemyAI(enemy, deltaTime) {
    const enemyType = this.enemyTypes[enemy.type];
    if (!enemyType) return;
    switch (enemyType.ai) {
      case "aggressive":
        this.updateAggressiveAI(enemy, deltaTime);
        break;
      case "defensive":
        this.updateDefensiveAI(enemy, deltaTime);
        break;
      case "stealth":
        this.updateStealthAI(enemy, deltaTime);
        break;
      case "boss":
        this.updateBossAI(enemy, deltaTime);
        break;
    }
  }
  /**
   * Update aggressive AI
   */
  updateAggressiveAI(enemy, deltaTime) {
    const nearestPlayer = this.findNearestPlayer(enemy);
    if (!nearestPlayer) return;
    const distance = this.getDistance(enemy, nearestPlayer);
    if (distance > 30) {
      const angle = Math.atan2(nearestPlayer.y - enemy.y, nearestPlayer.x - enemy.x);
      enemy.velocityX = Math.cos(angle) * enemy.speed;
      enemy.velocityY = Math.sin(angle) * enemy.speed;
    } else {
      enemy.velocityX = 0;
      enemy.velocityY = 0;
      if (Date.now() - enemy.lastAttackTime > enemy.attackCooldown) {
        this.enemyAttack(enemy, nearestPlayer);
      }
    }
  }
  /**
   * Update defensive AI
   */
  updateDefensiveAI(enemy, deltaTime) {
    const nearestPlayer = this.findNearestPlayer(enemy);
    if (!nearestPlayer) return;
    const distance = this.getDistance(enemy, nearestPlayer);
    if (distance < 50) {
      const angle = Math.atan2(enemy.y - nearestPlayer.y, enemy.x - nearestPlayer.x);
      enemy.velocityX = Math.cos(angle) * enemy.speed * 0.5;
      enemy.velocityY = Math.sin(angle) * enemy.speed * 0.5;
    } else if (distance > 100) {
      const angle = Math.atan2(nearestPlayer.y - enemy.y, nearestPlayer.x - enemy.x);
      enemy.velocityX = Math.cos(angle) * enemy.speed * 0.3;
      enemy.velocityY = Math.sin(angle) * enemy.speed * 0.3;
    } else {
      enemy.velocityX = 0;
      enemy.velocityY = 0;
    }
    if (distance > 30 && distance < 150 && Date.now() - enemy.lastAttackTime > enemy.attackCooldown) {
      this.enemyRangedAttack(enemy, nearestPlayer);
    }
  }
  /**
   * Update stealth AI
   */
  updateStealthAI(enemy, deltaTime) {
    if (enemy.stealthCooldown > 0) {
      enemy.stealthCooldown -= deltaTime;
    } else if (Math.random() < 0.1) {
      enemy.isStealthed = true;
      enemy.stealthDuration = 3e3;
    }
    if (enemy.isStealthed) {
      enemy.stealthDuration -= deltaTime;
      if (enemy.stealthDuration <= 0) {
        enemy.isStealthed = false;
        enemy.stealthCooldown = 5e3;
      }
    }
    if (enemy.isStealthed) {
      const nearestPlayer = this.findNearestPlayer(enemy);
      if (nearestPlayer) {
        const angle = Math.atan2(nearestPlayer.y - enemy.y, nearestPlayer.x - enemy.x);
        enemy.velocityX = Math.cos(angle) * enemy.speed * 1.2;
        enemy.velocityY = Math.sin(angle) * enemy.speed * 1.2;
        const distance = this.getDistance(enemy, nearestPlayer);
        if (distance < 20) {
          this.enemyBackstab(enemy, nearestPlayer);
        }
      }
    }
  }
  /**
   * Update boss AI
   */
  updateBossAI(enemy, deltaTime) {
    const healthPercentage = enemy.health / enemy.maxHealth;
    if (healthPercentage > 0.7) {
      this.updateAggressiveAI(enemy, deltaTime);
    } else if (healthPercentage > 0.3) {
      this.updateBossPhase2(enemy, deltaTime);
    } else {
      this.updateBossPhase3(enemy, deltaTime);
    }
  }
  /**
   * Update boss phase 2
   */
  updateBossPhase2(enemy, deltaTime) {
    if (Date.now() - enemy.lastSpecialAbility > 5e3) {
      const abilities = ["fire_breath", "wing_beat"];
      const ability = abilities[Math.floor(Math.random() * abilities.length)];
      this.useEnemyAbility(enemy, ability);
      enemy.lastSpecialAbility = Date.now();
    }
    this.updateAggressiveAI(enemy, deltaTime);
  }
  /**
   * Update boss phase 3
   */
  updateBossPhase3(enemy, deltaTime) {
    enemy.speed *= 1.5;
    enemy.damage *= 1.3;
    if (Date.now() - enemy.lastSpecialAbility > 2e3) {
      const abilities = ["fire_breath", "wing_beat", "dragon_roar"];
      const ability = abilities[Math.floor(Math.random() * abilities.length)];
      this.useEnemyAbility(enemy, ability);
      enemy.lastSpecialAbility = Date.now();
    }
    this.updateAggressiveAI(enemy, deltaTime);
  }
  /**
   * Update enemy position
   */
  updateEnemyPosition(enemy, deltaTime) {
    enemy.x += enemy.velocityX * deltaTime / 1e3;
    enemy.y += enemy.velocityY * deltaTime / 1e3;
    const area = this.enemySpawner.currentArea;
    if (area) {
      enemy.x = Math.max(area.bounds.x, Math.min(area.bounds.x + area.bounds.width, enemy.x));
      enemy.y = Math.max(area.bounds.y, Math.min(area.bounds.y + area.bounds.height, enemy.y));
    }
  }
  /**
   * Update enemy abilities
   */
  updateEnemyAbilities(enemy, deltaTime) {
    if (enemy.abilityCooldowns) {
      for (const [ability, cooldown] of enemy.abilityCooldowns) {
        if (cooldown > 0) {
          enemy.abilityCooldowns.set(ability, cooldown - deltaTime);
        }
      }
    }
  }
  /**
   * Update projectiles
   */
  updateProjectiles(deltaTime) {
    for (const [id, projectile] of this.combatState.projectiles) {
      projectile.x += projectile.velocityX * deltaTime / 1e3;
      projectile.y += projectile.velocityY * deltaTime / 1e3;
      this.checkProjectileCollisions(projectile);
      if (this.isProjectileExpired(projectile)) {
        this.combatState.projectiles.delete(id);
      }
    }
  }
  /**
   * Update effects
   */
  updateEffects(deltaTime) {
    for (const [id, effect] of this.combatState.effects) {
      effect.duration -= deltaTime;
      this.applyEffect(effect);
      if (effect.duration <= 0) {
        this.removeEffect(effect);
        this.combatState.effects.delete(id);
      }
    }
  }
  /**
   * Update combos
   */
  updateCombos(deltaTime) {
    for (const [id, combo] of this.combatState.combos) {
      combo.timeSinceLastHit += deltaTime;
      if (combo.timeSinceLastHit > this.combatConfig.comboWindow) {
        this.endCombo(combo);
        this.combatState.combos.delete(id);
      }
    }
  }
  /**
   * Spawn enemies
   */
  spawnEnemies(deltaTime) {
    if (!this.combatState.isInCombat || !this.enemySpawner.currentArea) return;
    this.enemySpawner.lastSpawnTime += deltaTime;
    if (this.enemySpawner.lastSpawnTime >= this.enemySpawner.spawnInterval && this.combatState.enemies.size < this.enemySpawner.maxEnemies) {
      this.spawnEnemy();
      this.enemySpawner.lastSpawnTime = 0;
    }
  }
  /**
   * Spawn a single enemy
   */
  spawnEnemy() {
    const area = this.enemySpawner.currentArea;
    const enemyType = area.enemyTypes[Math.floor(Math.random() * area.enemyTypes.length)];
    const spawnPoint = area.spawnPoints[Math.floor(Math.random() * area.spawnPoints.length)];
    const enemy = this.createEnemy(enemyType, spawnPoint.x, spawnPoint.y);
    this.combatState.enemies.set(enemy.id, enemy);
    this.logger.info(`Spawned ${enemyType} at (${spawnPoint.x}, ${spawnPoint.y})`);
  }
  /**
   * Create enemy
   */
  createEnemy(type, x, y) {
    const enemyType = this.enemyTypes[type];
    if (!enemyType) {
      throw new Error(`Unknown enemy type: ${type}`);
    }
    return {
      id: `enemy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type,
      name: enemyType.name,
      x,
      y,
      health: enemyType.health,
      maxHealth: enemyType.maxHealth,
      damage: enemyType.damage,
      speed: enemyType.speed,
      velocityX: 0,
      velocityY: 0,
      size: enemyType.size,
      ai: enemyType.ai,
      abilities: [...enemyType.abilities],
      resistances: { ...enemyType.resistances },
      weaknesses: { ...enemyType.weaknesses },
      lastAttackTime: 0,
      attackCooldown: 2e3,
      lastSpecialAbility: 0,
      abilityCooldowns: /* @__PURE__ */ new Map(),
      isStealthed: false,
      stealthCooldown: 0,
      stealthDuration: 0,
      loot: enemyType.loot
    };
  }
  /**
   * Handle attack
   */
  handleAttack(data) {
    const { attacker, target, ability } = data;
    if (!this.canAttack(attacker, target)) return;
    const damage = this.damageCalculator.calculateDamage(attacker, target, ability);
    this.dealDamage(target, damage, attacker);
    attacker.lastAttackTime = Date.now();
    this.createAttackEffect(attacker, target, ability);
    this.updateCombo(attacker, target);
    this.eventBus.emit("combat:attackExecuted", {
      attacker,
      target,
      damage,
      ability
    });
  }
  /**
   * Handle ability
   */
  handleAbility(data) {
    const { caster, ability, target } = data;
    if (!this.canUseAbility(caster, ability)) return;
    this.useAbility(caster, ability, target);
    if (caster.abilityCooldowns) {
      caster.abilityCooldowns.set(ability.id, ability.cooldown);
    }
    this.eventBus.emit("combat:abilityUsed", {
      caster,
      ability,
      target
    });
  }
  /**
   * Handle damage
   */
  handleDamage(data) {
    const { target, damage, source, type } = data;
    target.health = Math.max(0, target.health - damage);
    this.createDamageEffect(target, damage);
    if (type && this.combatConfig.statusEffects.includes(type)) {
      this.applyStatusEffect(target, type);
    }
    this.eventBus.emit("combat:damageDealt", {
      target,
      damage,
      source,
      type
    });
  }
  /**
   * Handle death
   */
  handleDeath(data) {
    const { entity } = data;
    this.dropLoot(entity);
    this.createDeathEffect(entity);
    this.awardExperience(entity);
    this.eventBus.emit("combat:entityDied", {
      entity,
      timestamp: Date.now()
    });
  }
  /**
   * Handle player move
   */
  handlePlayerMove(data) {
    this.playerPosition = { x: data.x, y: data.y };
  }
  /**
   * Handle player ability
   */
  handlePlayerAbility(data) {
    const { ability, target } = data;
    this.usePlayerAbility(ability, target);
  }
  /**
   * Check if combat should end
   */
  checkCombatEnd() {
    if (this.combatState.enemies.size === 0) {
      this.endCombat();
    }
  }
  /**
   * Clear all combat entities
   */
  clearAllCombatEntities() {
    this.combatState.enemies.clear();
    this.combatState.projectiles.clear();
    this.combatState.effects.clear();
    this.combatState.combos.clear();
  }
  /**
   * Find nearest player
   */
  findNearestPlayer(enemy) {
    return this.playerPosition || { x: 400, y: 300 };
  }
  /**
   * Get distance between two entities
   */
  getDistance(entity1, entity2) {
    const dx = entity2.x - entity1.x;
    const dy = entity2.y - entity1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Check if entity can attack
   */
  canAttack(attacker, target) {
    const distance = this.getDistance(attacker, target);
    const range = attacker.attackRange || 50;
    return distance <= range && Date.now() - attacker.lastAttackTime > attacker.attackCooldown;
  }
  /**
   * Check if entity can use ability
   */
  canUseAbility(caster, ability) {
    if (caster.abilityCooldowns) {
      const cooldown = caster.abilityCooldowns.get(ability.id);
      if (cooldown && cooldown > 0) return false;
    }
    return caster.mana >= (ability.manaCost || 0);
  }
  /**
   * Deal damage to target
   */
  dealDamage(target, damage, source) {
    target.health = Math.max(0, target.health - damage);
    this.eventBus.emit("combat:damage", {
      target,
      damage,
      source,
      timestamp: Date.now()
    });
    if (target.health <= 0) {
      this.eventBus.emit("combat:death", {
        entity: target,
        source,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Use ability
   */
  useAbility(caster, ability, target) {
    const abilityData = this.abilities[ability.id];
    if (!abilityData) return;
    switch (abilityData.type) {
      case "melee":
        this.useMeleeAbility(caster, abilityData, target);
        break;
      case "projectile":
        this.useProjectileAbility(caster, abilityData, target);
        break;
      case "instant":
        this.useInstantAbility(caster, abilityData, target);
        break;
      case "area":
        this.useAreaAbility(caster, abilityData, target);
        break;
      case "support":
        this.useSupportAbility(caster, abilityData, target);
        break;
      case "buff":
        this.useBuffAbility(caster, abilityData, target);
        break;
      case "debuff":
        this.useDebuffAbility(caster, abilityData, target);
        break;
    }
  }
  /**
   * Use melee ability
   */
  useMeleeAbility(caster, ability, target) {
    if (!target) return;
    const damage = this.damageCalculator.calculateDamage(caster, target, ability);
    this.dealDamage(target, damage, caster);
    this.applyAbilityEffects(ability, target);
  }
  /**
   * Use projectile ability
   */
  useProjectileAbility(caster, ability, target) {
    const projectile = this.createProjectile(caster, ability, target);
    this.combatState.projectiles.set(projectile.id, projectile);
  }
  /**
   * Use instant ability
   */
  useInstantAbility(caster, ability, target) {
    if (!target) return;
    const damage = this.damageCalculator.calculateDamage(caster, target, ability);
    this.dealDamage(target, damage, caster);
    this.applyAbilityEffects(ability, target);
  }
  /**
   * Use area ability
   */
  useAreaAbility(caster, ability, target) {
    const centerX = target ? target.x : caster.x;
    const centerY = target ? target.y : caster.y;
    const entitiesInRange = this.getEntitiesInRange(centerX, centerY, ability.range);
    entitiesInRange.forEach((entity) => {
      const damage = this.damageCalculator.calculateDamage(caster, entity, ability);
      this.dealDamage(entity, damage, caster);
      this.applyAbilityEffects(ability, entity);
    });
  }
  /**
   * Use support ability
   */
  useSupportAbility(caster, ability, target) {
    if (!target) return;
    const healing = this.damageCalculator.calculateHealing(caster, target, ability);
    target.health = Math.min(target.maxHealth, target.health + healing);
    this.eventBus.emit("combat:healing", {
      target,
      healing,
      source: caster,
      timestamp: Date.now()
    });
  }
  /**
   * Use buff ability
   */
  useBuffAbility(caster, ability, target) {
    if (!target) return;
    const effect = this.createEffect(ability, target, caster);
    this.combatState.effects.set(effect.id, effect);
  }
  /**
   * Use debuff ability
   */
  useDebuffAbility(caster, ability, target) {
    if (!target) return;
    const effect = this.createEffect(ability, target, caster);
    this.combatState.effects.set(effect.id, effect);
  }
  /**
   * Create projectile
   */
  createProjectile(caster, ability, target) {
    const angle = target ? Math.atan2(target.y - caster.y, target.x - caster.x) : caster.facing || 0;
    return {
      id: `projectile_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      x: caster.x,
      y: caster.y,
      velocityX: Math.cos(angle) * ability.speed,
      velocityY: Math.sin(angle) * ability.speed,
      damage: ability.damage,
      caster,
      ability,
      lifetime: 5e3,
      createdAt: Date.now()
    };
  }
  /**
   * Create effect
   */
  createEffect(ability, target, caster) {
    return {
      id: `effect_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: ability.id,
      target,
      caster,
      duration: ability.duration || 5e3,
      effects: ability.effects || [],
      createdAt: Date.now()
    };
  }
  /**
   * Apply effect
   */
  applyEffect(effect) {
    effect.effects.forEach((effectType) => {
      switch (effectType) {
        case "damage_boost":
          effect.target.damageMultiplier = (effect.target.damageMultiplier || 1) * 1.2;
          break;
        case "speed_boost":
          effect.target.speedMultiplier = (effect.target.speedMultiplier || 1) * 1.2;
          break;
        case "slow":
          effect.target.speedMultiplier = (effect.target.speedMultiplier || 1) * 0.5;
          break;
        case "burning":
          this.applyBurningEffect(effect.target);
          break;
        case "frozen":
          this.applyFrozenEffect(effect.target);
          break;
        case "shocked":
          this.applyShockedEffect(effect.target);
          break;
        case "poisoned":
          this.applyPoisonedEffect(effect.target);
          break;
      }
    });
  }
  /**
   * Remove effect
   */
  removeEffect(effect) {
    effect.effects.forEach((effectType) => {
      switch (effectType) {
        case "damage_boost":
          effect.target.damageMultiplier = (effect.target.damageMultiplier || 1) / 1.2;
          break;
        case "speed_boost":
          effect.target.speedMultiplier = (effect.target.speedMultiplier || 1) / 1.2;
          break;
        case "slow":
          effect.target.speedMultiplier = (effect.target.speedMultiplier || 1) / 0.5;
          break;
      }
    });
  }
  /**
   * Apply ability effects
   */
  applyAbilityEffects(ability, target) {
    if (!ability.effects) return;
    ability.effects.forEach((effect) => {
      switch (effect) {
        case "knockback":
          this.applyKnockback(target, ability.knockbackForce || 100);
          break;
        case "burning":
          this.applyBurningEffect(target);
          break;
        case "frozen":
          this.applyFrozenEffect(target);
          break;
        case "shocked":
          this.applyShockedEffect(target);
          break;
        case "poisoned":
          this.applyPoisonedEffect(target);
          break;
        case "stunned":
          this.applyStunnedEffect(target);
          break;
        case "slowed":
          this.applySlowedEffect(target);
          break;
      }
    });
  }
  /**
   * Apply knockback
   */
  applyKnockback(target, force) {
    const angle = Math.atan2(target.y - this.playerPosition.y, target.x - this.playerPosition.x);
    target.velocityX = Math.cos(angle) * force;
    target.velocityY = Math.sin(angle) * force;
  }
  /**
   * Apply burning effect
   */
  applyBurningEffect(target) {
    target.statusEffects = target.statusEffects || /* @__PURE__ */ new Set();
    target.statusEffects.add("burning");
    const burnDamage = 5;
    this.dealDamage(target, burnDamage, null);
  }
  /**
   * Apply frozen effect
   */
  applyFrozenEffect(target) {
    target.statusEffects = target.statusEffects || /* @__PURE__ */ new Set();
    target.statusEffects.add("frozen");
    target.speedMultiplier = 0.1;
  }
  /**
   * Apply shocked effect
   */
  applyShockedEffect(target) {
    target.statusEffects = target.statusEffects || /* @__PURE__ */ new Set();
    target.statusEffects.add("shocked");
    if (Math.random() < 0.3) {
      this.applyStunnedEffect(target);
    }
  }
  /**
   * Apply poisoned effect
   */
  applyPoisonedEffect(target) {
    target.statusEffects = target.statusEffects || /* @__PURE__ */ new Set();
    target.statusEffects.add("poisoned");
    const poisonDamage = 3;
    this.dealDamage(target, poisonDamage, null);
  }
  /**
   * Apply stunned effect
   */
  applyStunnedEffect(target) {
    target.statusEffects = target.statusEffects || /* @__PURE__ */ new Set();
    target.statusEffects.add("stunned");
    target.velocityX = 0;
    target.velocityY = 0;
  }
  /**
   * Apply slowed effect
   */
  applySlowedEffect(target) {
    target.statusEffects = target.statusEffects || /* @__PURE__ */ new Set();
    target.statusEffects.add("slowed");
    target.speedMultiplier = 0.5;
  }
  /**
   * Update combo
   */
  updateCombo(attacker, target) {
    const comboId = `${attacker.id}_${target.id}`;
    let combo = this.combatState.combos.get(comboId);
    if (!combo) {
      combo = {
        id: comboId,
        attacker,
        target,
        hits: 0,
        damage: 0,
        timeSinceLastHit: 0,
        startTime: Date.now()
      };
      this.combatState.combos.set(comboId, combo);
    }
    combo.hits++;
    combo.timeSinceLastHit = 0;
    const comboMultiplier = 1 + combo.hits * 0.1;
    this.eventBus.emit("combat:comboHit", {
      combo,
      multiplier: comboMultiplier
    });
  }
  /**
   * End combo
   */
  endCombo(combo) {
    this.eventBus.emit("combat:comboEnded", {
      combo,
      finalHits: combo.hits,
      totalDamage: combo.damage
    });
  }
  /**
   * Get entities in range
   */
  getEntitiesInRange(x, y, range) {
    const entities = [];
    for (const enemy of this.combatState.enemies.values()) {
      const distance = this.getDistance({ x, y }, enemy);
      if (distance <= range) {
        entities.push(enemy);
      }
    }
    return entities;
  }
  /**
   * Check projectile collisions
   */
  checkProjectileCollisions(projectile) {
    for (const enemy of this.combatState.enemies.values()) {
      const distance = this.getDistance(projectile, enemy);
      if (distance < 20) {
        this.dealDamage(enemy, projectile.damage, projectile.caster);
        this.combatState.projectiles.delete(projectile.id);
        return;
      }
    }
  }
  /**
   * Check if projectile is expired
   */
  isProjectileExpired(projectile) {
    return Date.now() - projectile.createdAt > projectile.lifetime;
  }
  /**
   * Create attack effect
   */
  createAttackEffect(attacker, target, ability) {
    this.eventBus.emit("combat:attackEffect", {
      attacker,
      target,
      ability,
      timestamp: Date.now()
    });
  }
  /**
   * Create damage effect
   */
  createDamageEffect(target, damage) {
    this.eventBus.emit("combat:damageEffect", {
      target,
      damage,
      timestamp: Date.now()
    });
  }
  /**
   * Create death effect
   */
  createDeathEffect(entity) {
    this.eventBus.emit("combat:deathEffect", {
      entity,
      timestamp: Date.now()
    });
  }
  /**
   * Drop loot
   */
  dropLoot(entity) {
    if (!entity.loot) return;
    const loot = {
      gold: this.calculateLootAmount(entity.loot.gold),
      items: this.calculateLootItems(entity.loot.items)
    };
    this.eventBus.emit("combat:lootDropped", {
      entity,
      loot,
      position: { x: entity.x, y: entity.y }
    });
  }
  /**
   * Calculate loot amount
   */
  calculateLootAmount(lootRange) {
    if (!lootRange || lootRange.length !== 2) return 0;
    return Math.floor(Math.random() * (lootRange[1] - lootRange[0] + 1)) + lootRange[0];
  }
  /**
   * Calculate loot items
   */
  calculateLootItems(itemList) {
    if (!itemList || itemList.length === 0) return [];
    const items = [];
    const dropChance = 0.3;
    itemList.forEach((item) => {
      if (Math.random() < dropChance) {
        items.push(item);
      }
    });
    return items;
  }
  /**
   * Award experience
   */
  awardExperience(entity) {
    const experience = this.calculateExperience(entity);
    this.eventBus.emit("combat:experienceGained", {
      amount: experience,
      source: entity,
      timestamp: Date.now()
    });
  }
  /**
   * Calculate experience
   */
  calculateExperience(entity) {
    const baseExp = entity.maxHealth * 0.1;
    const levelBonus = entity.level || 1;
    return Math.floor(baseExp * levelBonus);
  }
  /**
   * Enemy attack
   */
  enemyAttack(enemy, target) {
    const ability = this.abilities.basic_attack;
    this.handleAttack({
      attacker: enemy,
      target,
      ability
    });
    enemy.lastAttackTime = Date.now();
  }
  /**
   * Enemy ranged attack
   */
  enemyRangedAttack(enemy, target) {
    const ability = this.abilities.fireball;
    this.useProjectileAbility(enemy, ability, target);
    enemy.lastAttackTime = Date.now();
  }
  /**
   * Enemy backstab
   */
  enemyBackstab(enemy, target) {
    const ability = { ...this.abilities.basic_attack, damage: 3 };
    this.handleAttack({
      attacker: enemy,
      target,
      ability
    });
    enemy.lastAttackTime = Date.now();
  }
  /**
   * Use enemy ability
   */
  useEnemyAbility(enemy, abilityId) {
    const ability = this.abilities[abilityId];
    if (!ability) return;
    this.useAbility(enemy, ability, null);
  }
  /**
   * Use player ability
   */
  usePlayerAbility(ability, target) {
    this.useAbility(this.player, ability, target);
  }
  /**
   * Handle enemy death
   */
  handleEnemyDeath(enemy) {
    this.handleDeath({ entity: enemy });
  }
  /**
   * Get combat state
   */
  getCombatState() {
    return { ...this.combatState };
  }
  /**
   * Get enemy count
   */
  getEnemyCount() {
    return this.combatState.enemies.size;
  }
  /**
   * Is in combat
   */
  isInCombat() {
    return this.combatState.isInCombat;
  }
};

// src/systems/ProceduralAreaSystem.js
var ProceduralAreaSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("ProceduralAreaSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("ProceduralAreaSystem requires logger dependency");
    }
    this.generationState = {
      currentArea: null,
      generatedAreas: /* @__PURE__ */ new Map(),
      activeDungeons: /* @__PURE__ */ new Map(),
      explorationData: /* @__PURE__ */ new Map(),
      seed: Date.now()
    };
    this.generationConfig = {
      maxAreaSize: 2e3,
      minAreaSize: 500,
      chunkSize: 100,
      maxDungeonDepth: 10,
      biomeTransitionSmoothness: 0.3,
      lootDensity: 0.1,
      enemyDensity: 0.05
    };
    this.biomes = this.initializeBiomes();
    this.dungeonTemplates = this.initializeDungeonTemplates();
    this.lootTables = this.initializeLootTables();
    this.enemySpawnTables = this.initializeEnemySpawnTables();
    this.setupEventHandlers();
    this.logger.info("ProceduralAreaSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing ProceduralAreaSystem...");
    this.rng = this.createSeededRNG(this.generationState.seed);
    await this.generateArea("starting_forest", 0, 0);
    this.logger.info("ProceduralAreaSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up ProceduralAreaSystem...");
    this.generationState.generatedAreas.clear();
    this.generationState.activeDungeons.clear();
    this.generationState.explorationData.clear();
    this.removeEventHandlers();
    this.logger.info("ProceduralAreaSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updateActiveDungeons(deltaTime);
    this.updateExplorationData(deltaTime);
    this.checkAreaTransitions(gameState);
  }
  /**
   * Initialize biomes
   */
  initializeBiomes() {
    return {
      forest: {
        name: "Forest",
        description: "A dense woodland with ancient trees",
        color: "#228B22",
        terrain: {
          ground: "grass",
          obstacles: ["tree", "rock", "bush"],
          decorations: ["flower", "mushroom", "fallen_log"]
        },
        weather: {
          type: "sunny",
          intensity: 0.5,
          effects: ["dappled_light", "bird_sounds"]
        },
        loot: {
          common: ["herbs", "berries", "wood"],
          uncommon: ["rare_herbs", "animal_pelt"],
          rare: ["magical_herbs", "ancient_wood"]
        },
        enemies: ["goblin", "wolf", "spider"],
        ambientSounds: ["wind_through_trees", "bird_chirping"],
        music: "forest_ambient"
      },
      desert: {
        name: "Desert",
        description: "A vast expanse of sand and dunes",
        color: "#F4A460",
        terrain: {
          ground: "sand",
          obstacles: ["cactus", "rock_formation", "sand_dune"],
          decorations: ["desert_flower", "bone", "ancient_ruins"]
        },
        weather: {
          type: "hot",
          intensity: 0.8,
          effects: ["heat_haze", "sand_storm"]
        },
        loot: {
          common: ["sand_crystal", "desert_flower"],
          uncommon: ["ancient_coin", "desert_artifact"],
          rare: ["pharaoh_treasure", "sand_magic_crystal"]
        },
        enemies: ["scorpion", "desert_nomad", "sand_elemental"],
        ambientSounds: ["wind_across_sand", "desert_silence"],
        music: "desert_ambient"
      },
      mountain: {
        name: "Mountain",
        description: "Rugged peaks and rocky terrain",
        color: "#696969",
        terrain: {
          ground: "stone",
          obstacles: ["boulder", "cliff", "snow_patch"],
          decorations: ["mountain_flower", "crystal_formation", "eagle_nest"]
        },
        weather: {
          type: "cold",
          intensity: 0.7,
          effects: ["snow", "fog", "strong_winds"]
        },
        loot: {
          common: ["mountain_herbs", "iron_ore"],
          uncommon: ["precious_gem", "mountain_crystal"],
          rare: ["dragon_scale", "mountain_pearl"]
        },
        enemies: ["mountain_troll", "eagle", "ice_elemental"],
        ambientSounds: ["wind_through_rocks", "eagle_cry"],
        music: "mountain_ambient"
      },
      swamp: {
        name: "Swamp",
        description: "A murky wetland with twisted trees",
        color: "#556B2F",
        terrain: {
          ground: "mud",
          obstacles: ["swamp_tree", "mud_pit", "quicksand"],
          decorations: ["moss", "lily_pad", "ancient_statue"]
        },
        weather: {
          type: "humid",
          intensity: 0.6,
          effects: ["fog", "miasma", "rain"]
        },
        loot: {
          common: ["swamp_moss", "mud_crystal"],
          uncommon: ["swamp_herb", "ancient_relic"],
          rare: ["swamp_magic_essence", "cursed_artifact"]
        },
        enemies: ["swamp_monster", "poison_frog", "will_o_wisp"],
        ambientSounds: ["water_dripping", "frog_croaking"],
        music: "swamp_ambient"
      },
      arctic: {
        name: "Arctic",
        description: "Frozen wasteland with ice and snow",
        color: "#B0E0E6",
        terrain: {
          ground: "ice",
          obstacles: ["ice_formation", "snow_drift", "frozen_lake"],
          decorations: ["ice_crystal", "aurora", "polar_bear_track"]
        },
        weather: {
          type: "freezing",
          intensity: 0.9,
          effects: ["blizzard", "ice_storm", "northern_lights"]
        },
        loot: {
          common: ["ice_crystal", "snow_essence"],
          uncommon: ["arctic_fur", "ice_gem"],
          rare: ["aurora_crystal", "ice_dragon_scale"]
        },
        enemies: ["polar_bear", "ice_wolf", "frost_giant"],
        ambientSounds: ["wind_across_ice", "ice_cracking"],
        music: "arctic_ambient"
      },
      volcanic: {
        name: "Volcanic",
        description: "A land of fire and molten rock",
        color: "#8B0000",
        terrain: {
          ground: "lava_rock",
          obstacles: ["lava_pool", "volcanic_rock", "ash_pile"],
          decorations: ["lava_crystal", "volcanic_glass", "dragon_bone"]
        },
        weather: {
          type: "scorching",
          intensity: 1,
          effects: ["lava_rain", "ash_cloud", "heat_waves"]
        },
        loot: {
          common: ["lava_crystal", "volcanic_ash"],
          uncommon: ["fire_gem", "dragon_scale"],
          rare: ["phoenix_feather", "volcanic_core"]
        },
        enemies: ["fire_elemental", "lava_golem", "fire_dragon"],
        ambientSounds: ["lava_bubbling", "volcanic_rumble"],
        music: "volcanic_ambient"
      }
    };
  }
  /**
   * Initialize dungeon templates
   */
  initializeDungeonTemplates() {
    return {
      ancient_tomb: {
        name: "Ancient Tomb",
        description: "A mysterious burial chamber",
        levels: 3,
        rooms: {
          entrance: {
            type: "entrance",
            size: { width: 200, height: 150 },
            enemies: ["skeleton", "zombie"],
            loot: ["ancient_coin", "tomb_relic"]
          },
          main_chamber: {
            type: "boss",
            size: { width: 300, height: 200 },
            enemies: ["tomb_guardian"],
            loot: ["ancient_treasure", "magical_artifact"]
          },
          treasure_room: {
            type: "treasure",
            size: { width: 150, height: 150 },
            enemies: [],
            loot: ["gold_hoard", "rare_gem", "legendary_item"]
          }
        },
        connections: [
          { from: "entrance", to: "main_chamber" },
          { from: "main_chamber", to: "treasure_room" }
        ]
      },
      goblin_cave: {
        name: "Goblin Cave",
        description: "A network of tunnels inhabited by goblins",
        levels: 2,
        rooms: {
          cave_entrance: {
            type: "entrance",
            size: { width: 180, height: 120 },
            enemies: ["goblin", "goblin_warrior"],
            loot: ["goblin_ear", "rusty_weapon"]
          },
          goblin_camp: {
            type: "camp",
            size: { width: 250, height: 180 },
            enemies: ["goblin_chief", "goblin_shaman"],
            loot: ["goblin_treasure", "shaman_staff"]
          }
        },
        connections: [
          { from: "cave_entrance", to: "goblin_camp" }
        ]
      },
      dragon_lair: {
        name: "Dragon Lair",
        description: "The lair of a powerful dragon",
        levels: 5,
        rooms: {
          lair_entrance: {
            type: "entrance",
            size: { width: 200, height: 150 },
            enemies: ["dragon_guardian", "fire_elemental"],
            loot: ["dragon_scale", "fire_gem"]
          },
          treasure_chamber: {
            type: "treasure",
            size: { width: 300, height: 200 },
            enemies: ["dragon_hoard_guardian"],
            loot: ["dragon_gold", "magical_weapon"]
          },
          dragon_throne: {
            type: "boss",
            size: { width: 400, height: 300 },
            enemies: ["ancient_dragon"],
            loot: ["dragon_heart", "legendary_armor", "dragon_essence"]
          }
        },
        connections: [
          { from: "lair_entrance", to: "treasure_chamber" },
          { from: "treasure_chamber", to: "dragon_throne" }
        ]
      }
    };
  }
  /**
   * Initialize loot tables
   */
  initializeLootTables() {
    return {
      common: [
        { item: "health_potion", weight: 30, value: 10 },
        { item: "mana_potion", weight: 25, value: 10 },
        { item: "gold_coin", weight: 20, value: 5 },
        { item: "iron_ore", weight: 15, value: 8 },
        { item: "basic_weapon", weight: 10, value: 15 }
      ],
      uncommon: [
        { item: "greater_health_potion", weight: 25, value: 25 },
        { item: "magic_scroll", weight: 20, value: 30 },
        { item: "silver_coin", weight: 15, value: 20 },
        { item: "steel_ore", weight: 15, value: 25 },
        { item: "enchanted_weapon", weight: 15, value: 50 },
        { item: "rare_gem", weight: 10, value: 40 }
      ],
      rare: [
        { item: "elixir_of_life", weight: 20, value: 100 },
        { item: "ancient_scroll", weight: 15, value: 150 },
        { item: "gold_coin_pile", weight: 15, value: 75 },
        { item: "mithril_ore", weight: 15, value: 100 },
        { item: "legendary_weapon", weight: 15, value: 300 },
        { item: "precious_gem", weight: 10, value: 200 },
        { item: "magical_artifact", weight: 10, value: 500 }
      ],
      legendary: [
        { item: "phoenix_elixir", weight: 15, value: 1e3 },
        { item: "dragon_scroll", weight: 10, value: 2e3 },
        { item: "treasure_chest", weight: 15, value: 500 },
        { item: "adamantine_ore", weight: 10, value: 1e3 },
        { item: "mythical_weapon", weight: 15, value: 5e3 },
        { item: "dragon_gem", weight: 10, value: 3e3 },
        { item: "divine_artifact", weight: 10, value: 1e4 },
        { item: "world_essence", weight: 15, value: 5e3 }
      ]
    };
  }
  /**
   * Initialize enemy spawn tables
   */
  initializeEnemySpawnTables() {
    return {
      forest: [
        { enemy: "goblin", weight: 40, level: 1 },
        { enemy: "wolf", weight: 30, level: 2 },
        { enemy: "spider", weight: 20, level: 1 },
        { enemy: "bear", weight: 10, level: 3 }
      ],
      desert: [
        { enemy: "scorpion", weight: 35, level: 2 },
        { enemy: "desert_nomad", weight: 30, level: 3 },
        { enemy: "sand_elemental", weight: 20, level: 4 },
        { enemy: "desert_dragon", weight: 15, level: 6 }
      ],
      mountain: [
        { enemy: "mountain_troll", weight: 25, level: 4 },
        { enemy: "eagle", weight: 30, level: 2 },
        { enemy: "ice_elemental", weight: 25, level: 5 },
        { enemy: "mountain_giant", weight: 20, level: 7 }
      ],
      swamp: [
        { enemy: "swamp_monster", weight: 30, level: 3 },
        { enemy: "poison_frog", weight: 25, level: 1 },
        { enemy: "will_o_wisp", weight: 25, level: 4 },
        { enemy: "swamp_dragon", weight: 20, level: 6 }
      ],
      arctic: [
        { enemy: "polar_bear", weight: 30, level: 4 },
        { enemy: "ice_wolf", weight: 25, level: 3 },
        { enemy: "frost_giant", weight: 25, level: 6 },
        { enemy: "ice_dragon", weight: 20, level: 8 }
      ],
      volcanic: [
        { enemy: "fire_elemental", weight: 30, level: 5 },
        { enemy: "lava_golem", weight: 25, level: 6 },
        { enemy: "fire_dragon", weight: 25, level: 8 },
        { enemy: "volcanic_titan", weight: 20, level: 10 }
      ]
    };
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("area:generate", this.generateArea.bind(this));
    this.eventBus.on("area:explore", this.exploreArea.bind(this));
    this.eventBus.on("area:transition", this.handleAreaTransition.bind(this));
    this.eventBus.on("dungeon:enter", this.enterDungeon.bind(this));
    this.eventBus.on("dungeon:exit", this.exitDungeon.bind(this));
    this.eventBus.on("dungeon:complete", this.completeDungeon.bind(this));
    this.eventBus.on("exploration:discover", this.handleDiscovery.bind(this));
    this.eventBus.on("exploration:loot", this.handleLootDiscovery.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("area:generate", this.generateArea.bind(this));
    this.eventBus.removeListener("area:explore", this.exploreArea.bind(this));
    this.eventBus.removeListener("area:transition", this.handleAreaTransition.bind(this));
    this.eventBus.removeListener("dungeon:enter", this.enterDungeon.bind(this));
    this.eventBus.removeListener("dungeon:exit", this.exitDungeon.bind(this));
    this.eventBus.removeListener("dungeon:complete", this.completeDungeon.bind(this));
    this.eventBus.removeListener("exploration:discover", this.handleDiscovery.bind(this));
    this.eventBus.removeListener("exploration:loot", this.handleLootDiscovery.bind(this));
  }
  /**
   * Create seeded random number generator
   */
  createSeededRNG(seed) {
    let state = seed;
    return {
      next: () => {
        state = (state * 9301 + 49297) % 233280;
        return state / 233280;
      },
      nextInt: (min, max) => {
        return Math.floor(this.rng.next() * (max - min + 1)) + min;
      },
      nextFloat: (min, max) => {
        return this.rng.next() * (max - min) + min;
      }
    };
  }
  /**
   * Generate area
   */
  async generateArea(areaType, x, y) {
    const areaId = `${areaType}_${x}_${y}`;
    if (this.generationState.generatedAreas.has(areaId)) {
      return this.generationState.generatedAreas.get(areaId);
    }
    this.logger.info(`Generating area: ${areaType} at (${x}, ${y})`);
    const area = {
      id: areaId,
      type: areaType,
      x,
      y,
      size: this.generateAreaSize(),
      biome: this.determineBiome(x, y),
      terrain: this.generateTerrain(x, y),
      loot: this.generateLoot(x, y),
      enemies: this.generateEnemies(x, y),
      dungeons: this.generateDungeons(x, y),
      exploration: this.initializeExplorationData(areaId),
      generatedAt: Date.now()
    };
    this.generationState.generatedAreas.set(areaId, area);
    this.eventBus.emit("area:generated", {
      area,
      timestamp: Date.now()
    });
    return area;
  }
  /**
   * Generate area size
   */
  generateAreaSize() {
    const minSize = this.generationConfig.minAreaSize;
    const maxSize = this.generationConfig.maxAreaSize;
    return {
      width: this.rng.nextInt(minSize, maxSize),
      height: this.rng.nextInt(minSize, maxSize)
    };
  }
  /**
   * Determine biome based on coordinates
   */
  determineBiome(x, y) {
    const noise = this.noise2D(x * 0.01, y * 0.01);
    const biomeKeys = Object.keys(this.biomes);
    const biomeIndex = Math.floor((noise + 1) * 0.5 * biomeKeys.length);
    return biomeKeys[Math.min(biomeIndex, biomeKeys.length - 1)];
  }
  /**
   * Generate terrain
   */
  generateTerrain(x, y) {
    const biome = this.determineBiome(x, y);
    const biomeData = this.biomes[biome];
    const terrain = {
      ground: biomeData.terrain.ground,
      obstacles: [],
      decorations: [],
      heightMap: this.generateHeightMap(x, y),
      waterSources: this.generateWaterSources(x, y),
      caves: this.generateCaves(x, y)
    };
    const obstacleCount = this.rng.nextInt(10, 30);
    for (let i = 0; i < obstacleCount; i++) {
      const obstacle = this.generateObstacle(biomeData.terrain.obstacles, x, y);
      if (obstacle) terrain.obstacles.push(obstacle);
    }
    const decorationCount = this.rng.nextInt(15, 40);
    for (let i = 0; i < decorationCount; i++) {
      const decoration = this.generateDecoration(biomeData.terrain.decorations, x, y);
      if (decoration) terrain.decorations.push(decoration);
    }
    return terrain;
  }
  /**
   * Generate height map
   */
  generateHeightMap(x, y) {
    const size = this.generationConfig.chunkSize;
    const heightMap = [];
    for (let i = 0; i < size; i++) {
      heightMap[i] = [];
      for (let j = 0; j < size; j++) {
        const worldX = x + i;
        const worldY = y + j;
        heightMap[i][j] = this.noise2D(worldX * 0.1, worldY * 0.1);
      }
    }
    return heightMap;
  }
  /**
   * Generate water sources
   */
  generateWaterSources(x, y) {
    const sources = [];
    const sourceCount = this.rng.nextInt(2, 8);
    for (let i = 0; i < sourceCount; i++) {
      sources.push({
        x: this.rng.nextInt(0, this.generationConfig.chunkSize),
        y: this.rng.nextInt(0, this.generationConfig.chunkSize),
        size: this.rng.nextInt(20, 80),
        type: this.rng.next() < 0.7 ? "pond" : "river"
      });
    }
    return sources;
  }
  /**
   * Generate caves
   */
  generateCaves(x, y) {
    const caves = [];
    const caveCount = this.rng.nextInt(1, 4);
    for (let i = 0; i < caveCount; i++) {
      caves.push({
        x: this.rng.nextInt(0, this.generationConfig.chunkSize),
        y: this.rng.nextInt(0, this.generationConfig.chunkSize),
        depth: this.rng.nextInt(1, 5),
        type: this.rng.next() < 0.5 ? "natural" : "dungeon"
      });
    }
    return caves;
  }
  /**
   * Generate obstacle
   */
  generateObstacle(obstacleTypes, x, y) {
    const obstacleType = obstacleTypes[Math.floor(this.rng.next() * obstacleTypes.length)];
    const size = this.rng.nextInt(20, 60);
    return {
      type: obstacleType,
      x: this.rng.nextInt(0, this.generationConfig.chunkSize),
      y: this.rng.nextInt(0, this.generationConfig.chunkSize),
      width: size,
      height: size,
      rotation: this.rng.next() * Math.PI * 2
    };
  }
  /**
   * Generate decoration
   */
  generateDecoration(decorationTypes, x, y) {
    const decorationType = decorationTypes[Math.floor(this.rng.next() * decorationTypes.length)];
    const size = this.rng.nextInt(10, 30);
    return {
      type: decorationType,
      x: this.rng.nextInt(0, this.generationConfig.chunkSize),
      y: this.rng.nextInt(0, this.generationConfig.chunkSize),
      width: size,
      height: size,
      rotation: this.rng.next() * Math.PI * 2
    };
  }
  /**
   * Generate loot
   */
  generateLoot(x, y) {
    const loot = [];
    const lootCount = Math.floor(this.rng.next() * 10) + 5;
    for (let i = 0; i < lootCount; i++) {
      const lootItem = this.generateLootItem(x, y);
      if (lootItem) loot.push(lootItem);
    }
    return loot;
  }
  /**
   * Generate loot item
   */
  generateLootItem(x, y) {
    const rarity = this.determineLootRarity();
    const lootTable = this.lootTables[rarity];
    if (!lootTable || lootTable.length === 0) return null;
    const totalWeight = lootTable.reduce((sum, item) => sum + item.weight, 0);
    let randomWeight = this.rng.next() * totalWeight;
    for (const item of lootTable) {
      randomWeight -= item.weight;
      if (randomWeight <= 0) {
        return {
          item: item.item,
          rarity,
          value: item.value,
          x: this.rng.nextInt(0, this.generationConfig.chunkSize),
          y: this.rng.nextInt(0, this.generationConfig.chunkSize),
          discovered: false
        };
      }
    }
    return null;
  }
  /**
   * Determine loot rarity
   */
  determineLootRarity() {
    const roll = this.rng.next();
    if (roll < 0.6) return "common";
    if (roll < 0.85) return "uncommon";
    if (roll < 0.95) return "rare";
    return "legendary";
  }
  /**
   * Generate enemies
   */
  generateEnemies(x, y) {
    const biome = this.determineBiome(x, y);
    const spawnTable = this.enemySpawnTables[biome];
    if (!spawnTable) return [];
    const enemies = [];
    const enemyCount = Math.floor(this.rng.next() * 8) + 3;
    for (let i = 0; i < enemyCount; i++) {
      const enemy = this.generateEnemy(spawnTable, x, y);
      if (enemy) enemies.push(enemy);
    }
    return enemies;
  }
  /**
   * Generate enemy
   */
  generateEnemy(spawnTable, x, y) {
    const totalWeight = spawnTable.reduce((sum, enemy) => sum + enemy.weight, 0);
    let randomWeight = this.rng.next() * totalWeight;
    for (const enemyData of spawnTable) {
      randomWeight -= enemyData.weight;
      if (randomWeight <= 0) {
        return {
          type: enemyData.enemy,
          level: enemyData.level,
          x: this.rng.nextInt(0, this.generationConfig.chunkSize),
          y: this.rng.nextInt(0, this.generationConfig.chunkSize),
          spawned: false,
          defeated: false
        };
      }
    }
    return null;
  }
  /**
   * Generate dungeons
   */
  generateDungeons(x, y) {
    const dungeons = [];
    const dungeonCount = this.rng.nextInt(0, 3);
    for (let i = 0; i < dungeonCount; i++) {
      const dungeon = this.generateDungeon(x, y);
      if (dungeon) dungeons.push(dungeon);
    }
    return dungeons;
  }
  /**
   * Generate dungeon
   */
  generateDungeon(x, y) {
    const templateKeys = Object.keys(this.dungeonTemplates);
    const templateKey = templateKeys[Math.floor(this.rng.next() * templateKeys.length)];
    const template = this.dungeonTemplates[templateKey];
    return {
      id: `dungeon_${x}_${y}_${Date.now()}`,
      template: templateKey,
      name: template.name,
      description: template.description,
      x: this.rng.nextInt(0, this.generationConfig.chunkSize),
      y: this.rng.nextInt(0, this.generationConfig.chunkSize),
      level: 1,
      maxLevel: template.levels,
      completed: false,
      discovered: false
    };
  }
  /**
   * Initialize exploration data
   */
  initializeExplorationData(areaId) {
    return {
      explored: false,
      explorationProgress: 0,
      discoveries: [],
      secrets: [],
      landmarks: [],
      lastVisited: null
    };
  }
  /**
   * Explore area
   */
  exploreArea(areaId, playerPosition) {
    const area = this.generationState.generatedAreas.get(areaId);
    if (!area) return;
    const exploration = area.exploration;
    exploration.explored = true;
    exploration.lastVisited = Date.now();
    this.checkForDiscoveries(area, playerPosition);
    this.updateExplorationProgress(area);
    this.eventBus.emit("area:explored", {
      areaId,
      exploration,
      timestamp: Date.now()
    });
  }
  /**
   * Check for discoveries
   */
  checkForDiscoveries(area, playerPosition) {
    area.loot.forEach((loot) => {
      if (!loot.discovered) {
        const distance = this.getDistance(playerPosition, { x: loot.x, y: loot.y });
        if (distance < 50) {
          loot.discovered = true;
          this.eventBus.emit("exploration:loot", {
            loot,
            areaId: area.id,
            timestamp: Date.now()
          });
        }
      }
    });
    area.dungeons.forEach((dungeon) => {
      if (!dungeon.discovered) {
        const distance = this.getDistance(playerPosition, { x: dungeon.x, y: dungeon.y });
        if (distance < 100) {
          dungeon.discovered = true;
          this.eventBus.emit("exploration:discover", {
            type: "dungeon",
            discovery: dungeon,
            areaId: area.id,
            timestamp: Date.now()
          });
        }
      }
    });
  }
  /**
   * Update exploration progress
   */
  updateExplorationProgress(area) {
    const totalDiscoveries = area.loot.length + area.dungeons.length;
    const discoveredCount = area.loot.filter((l) => l.discovered).length + area.dungeons.filter((d) => d.discovered).length;
    area.exploration.explorationProgress = totalDiscoveries > 0 ? discoveredCount / totalDiscoveries * 100 : 0;
  }
  /**
   * Enter dungeon
   */
  enterDungeon(dungeonId) {
    const dungeon = this.findDungeonById(dungeonId);
    if (!dungeon) return;
    const dungeonInstance = this.createDungeonInstance(dungeon);
    this.generationState.activeDungeons.set(dungeonId, dungeonInstance);
    this.eventBus.emit("dungeon:entered", {
      dungeonId,
      dungeon: dungeonInstance,
      timestamp: Date.now()
    });
  }
  /**
   * Exit dungeon
   */
  exitDungeon(dungeonId) {
    const dungeon = this.generationState.activeDungeons.get(dungeonId);
    if (!dungeon) return;
    this.generationState.activeDungeons.delete(dungeonId);
    this.eventBus.emit("dungeon:exited", {
      dungeonId,
      timestamp: Date.now()
    });
  }
  /**
   * Complete dungeon
   */
  completeDungeon(dungeonId) {
    const dungeon = this.generationState.activeDungeons.get(dungeonId);
    if (!dungeon) return;
    dungeon.completed = true;
    this.awardDungeonRewards(dungeon);
    this.eventBus.emit("dungeon:completed", {
      dungeonId,
      dungeon,
      timestamp: Date.now()
    });
  }
  /**
   * Create dungeon instance
   */
  createDungeonInstance(dungeon) {
    const template = this.dungeonTemplates[dungeon.template];
    return {
      ...dungeon,
      rooms: this.generateDungeonRooms(template),
      currentRoom: "entrance",
      completedRooms: [],
      enemies: this.generateDungeonEnemies(template),
      loot: this.generateDungeonLoot(template)
    };
  }
  /**
   * Generate dungeon rooms
   */
  generateDungeonRooms(template) {
    const rooms = {};
    Object.entries(template.rooms).forEach(([roomId, roomData]) => {
      rooms[roomId] = {
        ...roomData,
        id: roomId,
        explored: false,
        enemies: [...roomData.enemies],
        loot: [...roomData.loot]
      };
    });
    return rooms;
  }
  /**
   * Generate dungeon enemies
   */
  generateDungeonEnemies(template) {
    const enemies = [];
    Object.values(template.rooms).forEach((room) => {
      room.enemies.forEach((enemyType) => {
        enemies.push({
          type: enemyType,
          room: room.id,
          x: this.rng.nextInt(0, room.size.width),
          y: this.rng.nextInt(0, room.size.height),
          defeated: false
        });
      });
    });
    return enemies;
  }
  /**
   * Generate dungeon loot
   */
  generateDungeonLoot(template) {
    const loot = [];
    Object.values(template.rooms).forEach((room) => {
      room.loot.forEach((lootType) => {
        loot.push({
          type: lootType,
          room: room.id,
          x: this.rng.nextInt(0, room.size.width),
          y: this.rng.nextInt(0, room.size.height),
          discovered: false
        });
      });
    });
    return loot;
  }
  /**
   * Award dungeon rewards
   */
  awardDungeonRewards(dungeon) {
    const rewards = {
      experience: dungeon.level * 100,
      gold: dungeon.level * 50,
      items: []
    };
    dungeon.loot.forEach((loot) => {
      if (loot.discovered) {
        rewards.items.push(loot.type);
      }
    });
    this.eventBus.emit("dungeon:rewards", {
      dungeonId: dungeon.id,
      rewards,
      timestamp: Date.now()
    });
  }
  /**
   * Handle area transition
   */
  handleAreaTransition(data) {
    const { fromArea, toArea, playerPosition } = data;
    this.generateArea(toArea.type, toArea.x, toArea.y);
    this.eventBus.emit("area:transitioned", {
      fromArea,
      toArea,
      playerPosition,
      timestamp: Date.now()
    });
  }
  /**
   * Handle discovery
   */
  handleDiscovery(data) {
    const { type, discovery, areaId } = data;
    this.logger.info(`Discovered ${type}: ${discovery.name} in area ${areaId}`);
  }
  /**
   * Handle loot discovery
   */
  handleLootDiscovery(data) {
    const { loot, areaId } = data;
    this.logger.info(`Discovered loot: ${loot.item} in area ${areaId}`);
  }
  /**
   * Update active dungeons
   */
  updateActiveDungeons(deltaTime) {
    for (const [dungeonId, dungeon] of this.generationState.activeDungeons) {
      this.updateDungeonState(dungeon, deltaTime);
    }
  }
  /**
   * Update exploration data
   */
  updateExplorationData(deltaTime) {
  }
  /**
   * Check area transitions
   */
  checkAreaTransitions(gameState) {
    if (!gameState.player) return;
    const player = gameState.player;
    const currentArea = this.getCurrentArea(player.x, player.y);
    if (currentArea && currentArea.id !== this.generationState.currentArea?.id) {
      this.generationState.currentArea = currentArea;
      this.exploreArea(currentArea.id, { x: player.x, y: player.y });
    }
  }
  /**
   * Get current area
   */
  getCurrentArea(x, y) {
    const areaX = Math.floor(x / this.generationConfig.chunkSize);
    const areaY = Math.floor(y / this.generationConfig.chunkSize);
    const areaId = `area_${areaX}_${areaY}`;
    return this.generationState.generatedAreas.get(areaId);
  }
  /**
   * Find dungeon by ID
   */
  findDungeonById(dungeonId) {
    for (const area of this.generationState.generatedAreas.values()) {
      const dungeon = area.dungeons.find((d) => d.id === dungeonId);
      if (dungeon) return dungeon;
    }
    return null;
  }
  /**
   * Update dungeon state
   */
  updateDungeonState(dungeon, deltaTime) {
  }
  /**
   * Get distance between two points
   */
  getDistance(point1, point2) {
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * 2D noise function
   */
  noise2D(x, y) {
    return Math.sin(x) * Math.cos(y) * 0.5 + 0.5;
  }
  /**
   * Get area data
   */
  getArea(areaId) {
    return this.generationState.generatedAreas.get(areaId);
  }
  /**
   * Get all areas
   */
  getAllAreas() {
    return Array.from(this.generationState.generatedAreas.values());
  }
  /**
   * Get active dungeons
   */
  getActiveDungeons() {
    return Array.from(this.generationState.activeDungeons.values());
  }
  /**
   * Get exploration data
   */
  getExplorationData(areaId) {
    const area = this.generationState.generatedAreas.get(areaId);
    return area ? area.exploration : null;
  }
};

// src/systems/ItemizationSystem.js
var ItemizationSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("ItemizationSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("ItemizationSystem requires logger dependency");
    }
    this.itemState = {
      generatedItems: /* @__PURE__ */ new Map(),
      itemTemplates: /* @__PURE__ */ new Map(),
      affixDatabase: /* @__PURE__ */ new Map(),
      setItems: /* @__PURE__ */ new Map(),
      uniqueItems: /* @__PURE__ */ new Map(),
      craftingRecipes: /* @__PURE__ */ new Map()
    };
    this.itemConfig = {
      maxAffixes: {
        common: 1,
        uncommon: 2,
        rare: 4,
        epic: 6,
        legendary: 8,
        unique: 10
      },
      affixWeights: {
        common: 100,
        uncommon: 50,
        rare: 25,
        epic: 10,
        legendary: 5,
        unique: 1
      },
      socketChances: {
        common: 0.1,
        uncommon: 0.2,
        rare: 0.3,
        epic: 0.4,
        legendary: 0.6,
        unique: 0.8
      }
    };
    this.initializeItemTemplates();
    this.initializeAffixDatabase();
    this.initializeSetItems();
    this.initializeUniqueItems();
    this.initializeCraftingRecipes();
    this.setupEventHandlers();
    this.logger.info("ItemizationSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing ItemizationSystem...");
    await this.loadItemData();
    this.logger.info("ItemizationSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up ItemizationSystem...");
    this.saveItemData();
    this.itemState.generatedItems.clear();
    this.removeEventHandlers();
    this.logger.info("ItemizationSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updateItemEffects(deltaTime);
    this.updateCraftingTimers(deltaTime);
  }
  /**
   * Initialize item templates
   */
  initializeItemTemplates() {
    this.itemState.itemTemplates.set("sword", {
      name: "Sword",
      type: "weapon",
      slot: "main_hand",
      baseStats: {
        damage: { min: 10, max: 20 },
        attackSpeed: 1,
        range: 1.2
      },
      requirements: {
        level: 1,
        strength: 10
      },
      allowedAffixes: ["damage", "attack_speed", "critical_chance", "critical_damage", "elemental_damage"],
      socketTypes: ["weapon"],
      maxSockets: 6
    });
    this.itemState.itemTemplates.set("bow", {
      name: "Bow",
      type: "weapon",
      slot: "main_hand",
      baseStats: {
        damage: { min: 8, max: 16 },
        attackSpeed: 1.2,
        range: 3
      },
      requirements: {
        level: 1,
        dexterity: 12
      },
      allowedAffixes: ["damage", "attack_speed", "critical_chance", "critical_damage", "elemental_damage", "piercing"],
      socketTypes: ["weapon"],
      maxSockets: 6
    });
    this.itemState.itemTemplates.set("staff", {
      name: "Staff",
      type: "weapon",
      slot: "main_hand",
      baseStats: {
        damage: { min: 6, max: 12 },
        attackSpeed: 0.8,
        range: 1.5
      },
      requirements: {
        level: 1,
        intelligence: 15
      },
      allowedAffixes: ["damage", "spell_power", "mana", "mana_regeneration", "elemental_damage", "spell_critical"],
      socketTypes: ["weapon"],
      maxSockets: 6
    });
    this.itemState.itemTemplates.set("helmet", {
      name: "Helmet",
      type: "armor",
      slot: "head",
      baseStats: {
        armor: 5,
        health: 20
      },
      requirements: {
        level: 1
      },
      allowedAffixes: ["armor", "health", "mana", "resistance", "critical_chance", "experience_gain"],
      socketTypes: ["armor"],
      maxSockets: 4
    });
    this.itemState.itemTemplates.set("chestplate", {
      name: "Chestplate",
      type: "armor",
      slot: "chest",
      baseStats: {
        armor: 15,
        health: 50
      },
      requirements: {
        level: 1
      },
      allowedAffixes: ["armor", "health", "mana", "resistance", "damage_reduction", "health_regeneration"],
      socketTypes: ["armor"],
      maxSockets: 4
    });
    this.itemState.itemTemplates.set("boots", {
      name: "Boots",
      type: "armor",
      slot: "feet",
      baseStats: {
        armor: 3,
        movementSpeed: 1.1
      },
      requirements: {
        level: 1
      },
      allowedAffixes: ["armor", "movement_speed", "health", "resistance", "stamina", "jump_height"],
      socketTypes: ["armor"],
      maxSockets: 2
    });
    this.itemState.itemTemplates.set("ring", {
      name: "Ring",
      type: "accessory",
      slot: "ring",
      baseStats: {
        health: 10,
        mana: 10
      },
      requirements: {
        level: 1
      },
      allowedAffixes: ["health", "mana", "damage", "armor", "resistance", "critical_chance", "experience_gain"],
      socketTypes: ["accessory"],
      maxSockets: 2
    });
    this.itemState.itemTemplates.set("amulet", {
      name: "Amulet",
      type: "accessory",
      slot: "neck",
      baseStats: {
        health: 15,
        mana: 15
      },
      requirements: {
        level: 1
      },
      allowedAffixes: ["health", "mana", "damage", "armor", "resistance", "critical_chance", "experience_gain", "luck"],
      socketTypes: ["accessory"],
      maxSockets: 2
    });
  }
  /**
   * Initialize affix database
   */
  initializeAffixDatabase() {
    this.itemState.affixDatabase.set("mighty", {
      name: "Mighty",
      type: "prefix",
      rarity: "common",
      stats: { damage: { min: 5, max: 10 } },
      level: 1,
      weight: 50
    });
    this.itemState.affixDatabase.set("sharp", {
      name: "Sharp",
      type: "prefix",
      rarity: "common",
      stats: { critical_chance: { min: 0.02, max: 0.05 } },
      level: 1,
      weight: 40
    });
    this.itemState.affixDatabase.set("sturdy", {
      name: "Sturdy",
      type: "prefix",
      rarity: "common",
      stats: { armor: { min: 3, max: 8 } },
      level: 1,
      weight: 45
    });
    this.itemState.affixDatabase.set("vital", {
      name: "Vital",
      type: "prefix",
      rarity: "common",
      stats: { health: { min: 15, max: 30 } },
      level: 1,
      weight: 35
    });
    this.itemState.affixDatabase.set("arcane", {
      name: "Arcane",
      type: "prefix",
      rarity: "uncommon",
      stats: { mana: { min: 20, max: 40 }, spell_power: { min: 5, max: 12 } },
      level: 5,
      weight: 25
    });
    this.itemState.affixDatabase.set("legendary", {
      name: "Legendary",
      type: "prefix",
      rarity: "legendary",
      stats: {
        damage: { min: 25, max: 50 },
        critical_chance: { min: 0.1, max: 0.2 },
        critical_damage: { min: 0.5, max: 1 }
      },
      level: 20,
      weight: 2
    });
    this.itemState.affixDatabase.set("of_power", {
      name: "of Power",
      type: "suffix",
      rarity: "common",
      stats: { damage: { min: 3, max: 7 } },
      level: 1,
      weight: 40
    });
    this.itemState.affixDatabase.set("of_protection", {
      name: "of Protection",
      type: "suffix",
      rarity: "common",
      stats: { armor: { min: 2, max: 5 } },
      level: 1,
      weight: 35
    });
    this.itemState.affixDatabase.set("of_vitality", {
      name: "of Vitality",
      type: "suffix",
      rarity: "common",
      stats: { health: { min: 10, max: 20 } },
      level: 1,
      weight: 30
    });
    this.itemState.affixDatabase.set("of_swiftness", {
      name: "of Swiftness",
      type: "suffix",
      rarity: "uncommon",
      stats: { attack_speed: { min: 0.1, max: 0.2 }, movement_speed: { min: 0.05, max: 0.1 } },
      level: 5,
      weight: 20
    });
    this.itemState.affixDatabase.set("of_destruction", {
      name: "of Destruction",
      type: "suffix",
      rarity: "epic",
      stats: {
        damage: { min: 15, max: 30 },
        critical_damage: { min: 0.3, max: 0.6 }
      },
      level: 15,
      weight: 8
    });
    this.itemState.affixDatabase.set("of_immortality", {
      name: "of Immortality",
      type: "suffix",
      rarity: "legendary",
      stats: {
        health: { min: 100, max: 200 },
        health_regeneration: { min: 5, max: 10 },
        damage_reduction: { min: 0.1, max: 0.2 }
      },
      level: 25,
      weight: 1
    });
    this.itemState.affixDatabase.set("flaming", {
      name: "Flaming",
      type: "prefix",
      rarity: "uncommon",
      stats: { fire_damage: { min: 8, max: 15 } },
      level: 3,
      weight: 20
    });
    this.itemState.affixDatabase.set("freezing", {
      name: "Freezing",
      type: "prefix",
      rarity: "uncommon",
      stats: { ice_damage: { min: 8, max: 15 } },
      level: 3,
      weight: 20
    });
    this.itemState.affixDatabase.set("shocking", {
      name: "Shocking",
      type: "prefix",
      rarity: "uncommon",
      stats: { lightning_damage: { min: 8, max: 15 } },
      level: 3,
      weight: 20
    });
    this.itemState.affixDatabase.set("poisonous", {
      name: "Poisonous",
      type: "prefix",
      rarity: "uncommon",
      stats: { poison_damage: { min: 6, max: 12 } },
      level: 3,
      weight: 20
    });
  }
  /**
   * Initialize set items
   */
  initializeSetItems() {
    this.itemState.setItems.set("warrior_set", {
      name: "Warrior's Set",
      pieces: ["helmet", "chestplate", "boots", "gloves"],
      bonuses: {
        2: { damage: 20, armor: 10 },
        3: { health: 50, critical_chance: 0.05 },
        4: { damage: 50, armor: 25, health: 100 }
      },
      items: {
        helmet: {
          name: "Warrior's Helm",
          baseStats: { armor: 8, health: 30 },
          setBonus: "warrior_set"
        },
        chestplate: {
          name: "Warrior's Plate",
          baseStats: { armor: 20, health: 60 },
          setBonus: "warrior_set"
        },
        boots: {
          name: "Warrior's Boots",
          baseStats: { armor: 5, movementSpeed: 1.1 },
          setBonus: "warrior_set"
        },
        gloves: {
          name: "Warrior's Gauntlets",
          baseStats: { armor: 6, damage: 5 },
          setBonus: "warrior_set"
        }
      }
    });
    this.itemState.setItems.set("mage_set", {
      name: "Mage's Set",
      pieces: ["hat", "robe", "boots", "gloves"],
      bonuses: {
        2: { mana: 40, spell_power: 15 },
        3: { mana_regeneration: 2, spell_critical: 0.1 },
        4: { mana: 100, spell_power: 40, spell_critical: 0.2 }
      },
      items: {
        hat: {
          name: "Mage's Hat",
          baseStats: { mana: 25, spell_power: 8 },
          setBonus: "mage_set"
        },
        robe: {
          name: "Mage's Robe",
          baseStats: { mana: 50, spell_power: 15 },
          setBonus: "mage_set"
        },
        boots: {
          name: "Mage's Boots",
          baseStats: { mana: 15, movementSpeed: 1.05 },
          setBonus: "mage_set"
        },
        gloves: {
          name: "Mage's Gloves",
          baseStats: { mana: 20, spell_power: 10 },
          setBonus: "mage_set"
        }
      }
    });
  }
  /**
   * Initialize unique items
   */
  initializeUniqueItems() {
    this.itemState.uniqueItems.set("excalibur", {
      name: "Excalibur",
      type: "weapon",
      slot: "main_hand",
      rarity: "unique",
      level: 30,
      baseStats: {
        damage: { min: 50, max: 100 },
        attackSpeed: 1.2,
        range: 1.5
      },
      uniqueStats: {
        damage: 50,
        critical_chance: 0.15,
        critical_damage: 1,
        light_damage: 25
      },
      uniqueProperties: [
        "Chance to cast Light Beam on critical hit",
        "Increases all light damage by 50%",
        "Grants immunity to darkness effects"
      ],
      requirements: {
        level: 30,
        strength: 25,
        dexterity: 20
      },
      maxSockets: 8
    });
    this.itemState.uniqueItems.set("crown_of_kings", {
      name: "Crown of Kings",
      type: "armor",
      slot: "head",
      rarity: "unique",
      level: 25,
      baseStats: {
        armor: 15,
        health: 100,
        mana: 50
      },
      uniqueStats: {
        health: 100,
        mana: 50,
        experience_gain: 0.25,
        gold_find: 0.5
      },
      uniqueProperties: [
        "Increases experience gain by 25%",
        "Increases gold find by 50%",
        "Grants +1 to all attributes"
      ],
      requirements: {
        level: 25
      },
      maxSockets: 6
    });
    this.itemState.uniqueItems.set("ring_of_power", {
      name: "Ring of Power",
      type: "accessory",
      slot: "ring",
      rarity: "unique",
      level: 20,
      baseStats: {
        health: 50,
        mana: 50
      },
      uniqueStats: {
        damage: 30,
        armor: 20,
        health: 50,
        mana: 50,
        critical_chance: 0.1,
        critical_damage: 0.5
      },
      uniqueProperties: [
        "Increases all damage by 30%",
        "Increases all resistances by 25%",
        "Grants immunity to status effects"
      ],
      requirements: {
        level: 20
      },
      maxSockets: 4
    });
  }
  /**
   * Initialize crafting recipes
   */
  initializeCraftingRecipes() {
    this.itemState.craftingRecipes.set("health_potion", {
      name: "Health Potion",
      type: "consumable",
      ingredients: [
        { item: "healing_herb", quantity: 2 },
        { item: "water", quantity: 1 }
      ],
      result: {
        item: "health_potion",
        quantity: 1
      },
      level: 1,
      time: 5e3
    });
    this.itemState.craftingRecipes.set("iron_sword", {
      name: "Iron Sword",
      type: "weapon",
      ingredients: [
        { item: "iron_ore", quantity: 3 },
        { item: "wood", quantity: 1 }
      ],
      result: {
        item: "iron_sword",
        quantity: 1
      },
      level: 5,
      time: 3e4
    });
    this.itemState.craftingRecipes.set("magic_ring", {
      name: "Magic Ring",
      type: "accessory",
      ingredients: [
        { item: "gold_ore", quantity: 2 },
        { item: "magic_crystal", quantity: 1 },
        { item: "enchantment_scroll", quantity: 1 }
      ],
      result: {
        item: "magic_ring",
        quantity: 1
      },
      level: 10,
      time: 6e4
    });
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("item:generate", this.generateItem.bind(this));
    this.eventBus.on("item:identify", this.identifyItem.bind(this));
    this.eventBus.on("item:enhance", this.enhanceItem.bind(this));
    this.eventBus.on("item:socket", this.socketItem.bind(this));
    this.eventBus.on("crafting:start", this.startCrafting.bind(this));
    this.eventBus.on("crafting:complete", this.completeCrafting.bind(this));
    this.eventBus.on("loot:drop", this.dropLoot.bind(this));
    this.eventBus.on("loot:pickup", this.pickupLoot.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("item:generate", this.generateItem.bind(this));
    this.eventBus.removeListener("item:identify", this.identifyItem.bind(this));
    this.eventBus.removeListener("item:enhance", this.enhanceItem.bind(this));
    this.eventBus.removeListener("item:socket", this.socketItem.bind(this));
    this.eventBus.removeListener("crafting:start", this.startCrafting.bind(this));
    this.eventBus.removeListener("crafting:complete", this.completeCrafting.bind(this));
    this.eventBus.removeListener("loot:drop", this.dropLoot.bind(this));
    this.eventBus.removeListener("loot:pickup", this.pickupLoot.bind(this));
  }
  /**
   * Generate item
   */
  generateItem(data) {
    const { template, level, rarity, quality } = data;
    const itemTemplate = this.itemState.itemTemplates.get(template);
    if (!itemTemplate) {
      this.logger.error(`Unknown item template: ${template}`);
      return null;
    }
    const item = this.createItem(itemTemplate, level, rarity, quality);
    this.itemState.generatedItems.set(item.id, item);
    this.eventBus.emit("item:generated", {
      item,
      timestamp: Date.now()
    });
    return item;
  }
  /**
   * Create item
   */
  createItem(template, level, rarity, quality) {
    const item = {
      id: `item_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      template: template.name,
      type: template.type,
      slot: template.slot,
      name: template.name,
      level: level || 1,
      rarity: rarity || this.determineRarity(),
      quality: quality || this.determineQuality(),
      baseStats: { ...template.baseStats },
      affixes: [],
      sockets: [],
      setBonus: null,
      uniqueProperties: [],
      requirements: { ...template.requirements },
      identified: false,
      enhanced: false,
      createdAt: Date.now()
    };
    this.generateAffixes(item, template);
    this.generateSockets(item, template);
    this.applySetBonus(item);
    this.applyUniqueProperties(item);
    this.calculateFinalStats(item);
    return item;
  }
  /**
   * Determine item rarity
   */
  determineRarity() {
    const roll = Math.random() * 100;
    if (roll < 60) return "common";
    if (roll < 85) return "uncommon";
    if (roll < 95) return "rare";
    if (roll < 99) return "epic";
    return "legendary";
  }
  /**
   * Determine item quality
   */
  determineQuality() {
    const roll = Math.random() * 100;
    if (roll < 40) return "normal";
    if (roll < 70) return "superior";
    if (roll < 90) return "exceptional";
    return "perfect";
  }
  /**
   * Generate affixes
   */
  generateAffixes(item, template) {
    const maxAffixes = this.itemConfig.maxAffixes[item.rarity];
    const affixCount = Math.floor(Math.random() * maxAffixes) + 1;
    const availableAffixes = this.getAvailableAffixes(template.allowedAffixes, item.level);
    for (let i = 0; i < affixCount; i++) {
      const affix = this.selectRandomAffix(availableAffixes, item.level);
      if (affix) {
        item.affixes.push(this.createAffixInstance(affix, item.level));
      }
    }
  }
  /**
   * Get available affixes
   */
  getAvailableAffixes(allowedAffixes, level) {
    const available = [];
    for (const [affixId, affix] of this.itemState.affixDatabase) {
      if (affix.level <= level && this.isAffixCompatible(affix, allowedAffixes)) {
        available.push(affix);
      }
    }
    return available;
  }
  /**
   * Check if affix is compatible
   */
  isAffixCompatible(affix, allowedAffixes) {
    const affixStats = Object.keys(affix.stats);
    return affixStats.some((stat) => allowedAffixes.includes(stat));
  }
  /**
   * Select random affix
   */
  selectRandomAffix(availableAffixes, level) {
    if (availableAffixes.length === 0) return null;
    const totalWeight = availableAffixes.reduce((sum, affix) => sum + affix.weight, 0);
    let randomWeight = Math.random() * totalWeight;
    for (const affix of availableAffixes) {
      randomWeight -= affix.weight;
      if (randomWeight <= 0) {
        return affix;
      }
    }
    return availableAffixes[0];
  }
  /**
   * Create affix instance
   */
  createAffixInstance(affix, level) {
    const instance = {
      id: affix.name.toLowerCase().replace(/\s+/g, "_"),
      name: affix.name,
      type: affix.type,
      rarity: affix.rarity,
      stats: {}
    };
    Object.entries(affix.stats).forEach(([stat, range]) => {
      const min = range.min * (1 + level * 0.1);
      const max = range.max * (1 + level * 0.1);
      instance.stats[stat] = Math.floor(Math.random() * (max - min + 1)) + min;
    });
    return instance;
  }
  /**
   * Generate sockets
   */
  generateSockets(item, template) {
    const socketChance = this.itemConfig.socketChances[item.rarity];
    if (Math.random() < socketChance) {
      const socketCount = Math.floor(Math.random() * template.maxSockets) + 1;
      for (let i = 0; i < socketCount; i++) {
        item.sockets.push({
          id: `socket_${i}`,
          type: template.socketTypes[Math.floor(Math.random() * template.socketTypes.length)],
          gem: null
        });
      }
    }
  }
  /**
   * Apply set bonus
   */
  applySetBonus(item) {
    for (const [setId, setData] of this.itemState.setItems) {
      if (setData.items[item.template]) {
        item.setBonus = setId;
        break;
      }
    }
  }
  /**
   * Apply unique properties
   */
  applyUniqueProperties(item) {
    if (item.rarity === "unique") {
      const uniqueItem = this.findUniqueItem(item.template);
      if (uniqueItem) {
        item.uniqueProperties = [...uniqueItem.uniqueProperties];
        item.uniqueStats = { ...uniqueItem.uniqueStats };
      }
    }
  }
  /**
   * Find unique item
   */
  findUniqueItem(template) {
    for (const [id, uniqueItem] of this.itemState.uniqueItems) {
      if (uniqueItem.name === template) {
        return uniqueItem;
      }
    }
    return null;
  }
  /**
   * Calculate final stats
   */
  calculateFinalStats(item) {
    item.finalStats = { ...item.baseStats };
    item.affixes.forEach((affix) => {
      Object.entries(affix.stats).forEach(([stat, value]) => {
        if (item.finalStats[stat]) {
          if (typeof item.finalStats[stat] === "object") {
            item.finalStats[stat].min += value;
            item.finalStats[stat].max += value;
          } else {
            item.finalStats[stat] += value;
          }
        } else {
          item.finalStats[stat] = value;
        }
      });
    });
    if (item.uniqueStats) {
      Object.entries(item.uniqueStats).forEach(([stat, value]) => {
        if (item.finalStats[stat]) {
          if (typeof item.finalStats[stat] === "object") {
            item.finalStats[stat].min += value;
            item.finalStats[stat].max += value;
          } else {
            item.finalStats[stat] += value;
          }
        } else {
          item.finalStats[stat] = value;
        }
      });
    }
    const qualityMultiplier = this.getQualityMultiplier(item.quality);
    Object.keys(item.finalStats).forEach((stat) => {
      if (typeof item.finalStats[stat] === "number") {
        item.finalStats[stat] = Math.floor(item.finalStats[stat] * qualityMultiplier);
      } else if (typeof item.finalStats[stat] === "object") {
        item.finalStats[stat].min = Math.floor(item.finalStats[stat].min * qualityMultiplier);
        item.finalStats[stat].max = Math.floor(item.finalStats[stat].max * qualityMultiplier);
      }
    });
  }
  /**
   * Get quality multiplier
   */
  getQualityMultiplier(quality) {
    const multipliers = {
      normal: 1,
      superior: 1.1,
      exceptional: 1.25,
      perfect: 1.5
    };
    return multipliers[quality] || 1;
  }
  /**
   * Identify item
   */
  identifyItem(data) {
    const { itemId } = data;
    const item = this.itemState.generatedItems.get(itemId);
    if (!item) {
      this.logger.error(`Item not found: ${itemId}`);
      return;
    }
    item.identified = true;
    this.eventBus.emit("item:identified", {
      item,
      timestamp: Date.now()
    });
  }
  /**
   * Enhance item
   */
  enhanceItem(data) {
    const { itemId, enhancementLevel } = data;
    const item = this.itemState.generatedItems.get(itemId);
    if (!item) {
      this.logger.error(`Item not found: ${itemId}`);
      return;
    }
    if (item.enhanced) {
      this.logger.warn("Item already enhanced");
      return;
    }
    const enhancementMultiplier = 1 + enhancementLevel * 0.1;
    Object.keys(item.finalStats).forEach((stat) => {
      if (typeof item.finalStats[stat] === "number") {
        item.finalStats[stat] = Math.floor(item.finalStats[stat] * enhancementMultiplier);
      } else if (typeof item.finalStats[stat] === "object") {
        item.finalStats[stat].min = Math.floor(item.finalStats[stat].min * enhancementMultiplier);
        item.finalStats[stat].max = Math.floor(item.finalStats[stat].max * enhancementMultiplier);
      }
    });
    item.enhanced = true;
    item.enhancementLevel = enhancementLevel;
    this.eventBus.emit("item:enhanced", {
      item,
      enhancementLevel,
      timestamp: Date.now()
    });
  }
  /**
   * Socket item
   */
  socketItem(data) {
    const { itemId, socketId, gemId } = data;
    const item = this.itemState.generatedItems.get(itemId);
    if (!item) {
      this.logger.error(`Item not found: ${itemId}`);
      return;
    }
    const socket = item.sockets.find((s) => s.id === socketId);
    if (!socket) {
      this.logger.error(`Socket not found: ${socketId}`);
      return;
    }
    if (socket.gem) {
      this.logger.warn("Socket already has a gem");
      return;
    }
    socket.gem = gemId;
    this.applyGemEffects(item, gemId);
    this.eventBus.emit("item:socketed", {
      item,
      socketId,
      gemId,
      timestamp: Date.now()
    });
  }
  /**
   * Apply gem effects
   */
  applyGemEffects(item, gemId) {
    this.logger.info(`Applied gem effects: ${gemId}`);
  }
  /**
   * Start crafting
   */
  startCrafting(data) {
    const { recipeId, ingredients } = data;
    const recipe = this.itemState.craftingRecipes.get(recipeId);
    if (!recipe) {
      this.logger.error(`Recipe not found: ${recipeId}`);
      return;
    }
    if (!this.hasRequiredIngredients(ingredients, recipe.ingredients)) {
      this.logger.warn("Missing required ingredients");
      return;
    }
    const craftingId = `crafting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const crafting = {
      id: craftingId,
      recipe,
      startTime: Date.now(),
      endTime: Date.now() + recipe.time,
      ingredients,
      completed: false
    };
    this.itemState.craftingRecipes.set(craftingId, crafting);
    this.eventBus.emit("crafting:started", {
      crafting,
      timestamp: Date.now()
    });
  }
  /**
   * Complete crafting
   */
  completeCrafting(data) {
    const { craftingId } = data;
    const crafting = this.itemState.craftingRecipes.get(craftingId);
    if (!crafting) {
      this.logger.error(`Crafting not found: ${craftingId}`);
      return;
    }
    if (crafting.completed) {
      this.logger.warn("Crafting already completed");
      return;
    }
    crafting.completed = true;
    const item = this.generateItem({
      template: crafting.recipe.result.item,
      level: crafting.recipe.level
    });
    this.eventBus.emit("crafting:completed", {
      crafting,
      item,
      timestamp: Date.now()
    });
  }
  /**
   * Check if player has required ingredients
   */
  hasRequiredIngredients(playerIngredients, requiredIngredients) {
    for (const required of requiredIngredients) {
      const playerIngredient = playerIngredients.find((ing) => ing.item === required.item);
      if (!playerIngredient || playerIngredient.quantity < required.quantity) {
        return false;
      }
    }
    return true;
  }
  /**
   * Drop loot
   */
  dropLoot(data) {
    const { position, lootTable, level } = data;
    const loot = this.generateLootFromTable(lootTable, level);
    this.eventBus.emit("loot:dropped", {
      loot,
      position,
      timestamp: Date.now()
    });
  }
  /**
   * Generate loot from table
   */
  generateLootFromTable(lootTable, level) {
    const loot = [];
    for (const entry of lootTable) {
      if (Math.random() < entry.chance) {
        const item = this.generateItem({
          template: entry.item,
          level: level || entry.level,
          rarity: entry.rarity
        });
        if (item) {
          loot.push({
            item,
            quantity: entry.quantity || 1,
            position: entry.position || { x: 0, y: 0 }
          });
        }
      }
    }
    return loot;
  }
  /**
   * Pickup loot
   */
  pickupLoot(data) {
    const { lootId } = data;
    this.eventBus.emit("loot:pickedUp", {
      lootId,
      timestamp: Date.now()
    });
  }
  /**
   * Update item effects
   */
  updateItemEffects(deltaTime) {
  }
  /**
   * Update crafting timers
   */
  updateCraftingTimers(deltaTime) {
    for (const [craftingId, crafting] of this.itemState.craftingRecipes) {
      if (!crafting.completed && Date.now() >= crafting.endTime) {
        this.completeCrafting({ craftingId });
      }
    }
  }
  /**
   * Load item data
   */
  async loadItemData() {
    try {
      const savedData = localStorage.getItem("itemizationData");
      if (savedData) {
        const data = JSON.parse(savedData);
        this.logger.info("Item data loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load item data:", error);
    }
  }
  /**
   * Save item data
   */
  saveItemData() {
    try {
      const data = {
        generatedItems: Array.from(this.itemState.generatedItems.entries()),
        timestamp: Date.now()
      };
      localStorage.setItem("itemizationData", JSON.stringify(data));
      this.logger.info("Item data saved to storage");
    } catch (error) {
      this.logger.error("Failed to save item data:", error);
    }
  }
  /**
   * Get item by ID
   */
  getItem(itemId) {
    return this.itemState.generatedItems.get(itemId);
  }
  /**
   * Get all items
   */
  getAllItems() {
    return Array.from(this.itemState.generatedItems.values());
  }
  /**
   * Get item templates
   */
  getItemTemplates() {
    return Array.from(this.itemState.itemTemplates.values());
  }
  /**
   * Get affix database
   */
  getAffixDatabase() {
    return Array.from(this.itemState.affixDatabase.values());
  }
  /**
   * Get set items
   */
  getSetItems() {
    return Array.from(this.itemState.setItems.values());
  }
  /**
   * Get unique items
   */
  getUniqueItems() {
    return Array.from(this.itemState.uniqueItems.values());
  }
  /**
   * Get crafting recipes
   */
  getCraftingRecipes() {
    return Array.from(this.itemState.craftingRecipes.values());
  }
};

// src/systems/EndgameSystem.js
var EndgameSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("EndgameSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("EndgameSystem requires logger dependency");
    }
    this.endgameState = {
      playerLevel: 1,
      prestigeLevel: 0,
      endgameUnlocked: false,
      activeRaids: /* @__PURE__ */ new Map(),
      pvpMatches: /* @__PURE__ */ new Map(),
      leaderboards: /* @__PURE__ */ new Map(),
      seasonalContent: /* @__PURE__ */ new Map(),
      replayableMaps: /* @__PURE__ */ new Map(),
      bossEncounters: /* @__PURE__ */ new Map()
    };
    this.endgameConfig = {
      maxLevel: 100,
      prestigeLevels: 10,
      raidMaxPlayers: 8,
      pvpMaxPlayers: 4,
      leaderboardUpdateInterval: 6e4,
      // 1 minute
      seasonalDuration: 7 * 24 * 60 * 60 * 1e3,
      // 7 days
      bossRespawnTime: 36e5
      // 1 hour
    };
    this.initializeReplayableMaps();
    this.initializeBossEncounters();
    this.initializePvPSystem();
    this.initializeRaidSystem();
    this.initializeLeaderboards();
    this.initializeSeasonalContent();
    this.setupEventHandlers();
    this.logger.info("EndgameSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing EndgameSystem...");
    await this.loadEndgameData();
    this.startBackgroundProcesses();
    this.logger.info("EndgameSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up EndgameSystem...");
    this.saveEndgameData();
    this.stopBackgroundProcesses();
    this.endgameState.activeRaids.clear();
    this.endgameState.pvpMatches.clear();
    this.endgameState.leaderboards.clear();
    this.endgameState.seasonalContent.clear();
    this.endgameState.replayableMaps.clear();
    this.endgameState.bossEncounters.clear();
    this.removeEventHandlers();
    this.logger.info("EndgameSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updateActiveRaids(deltaTime);
    this.updatePvPMatches(deltaTime);
    this.updateBossEncounters(deltaTime);
    this.updateSeasonalContent(deltaTime);
    this.updateLeaderboards(deltaTime);
  }
  /**
   * Initialize replayable maps
   */
  initializeReplayableMaps() {
    this.endgameState.replayableMaps.set("infinite_dungeon", {
      id: "infinite_dungeon",
      name: "Infinite Dungeon",
      description: "A never-ending dungeon that gets harder with each floor",
      type: "dungeon",
      difficulty: "scaling",
      maxPlayers: 4,
      floors: 1e3,
      currentFloor: 1,
      rewards: {
        experience: "scaling",
        loot: "scaling",
        currency: "scaling"
      },
      modifiers: [
        "enemy_health_boost",
        "enemy_damage_boost",
        "loot_quality_boost",
        "experience_boost"
      ],
      requirements: {
        level: 50,
        prestige: 0
      }
    });
    this.endgameState.replayableMaps.set("nightmare_realm", {
      id: "nightmare_realm",
      name: "Nightmare Realm",
      description: "A twisted dimension where reality bends",
      type: "realm",
      difficulty: "extreme",
      maxPlayers: 6,
      areas: 10,
      currentArea: 1,
      rewards: {
        experience: "high",
        loot: "legendary",
        currency: "high",
        uniqueItems: true
      },
      modifiers: [
        "reality_distortion",
        "time_dilation",
        "gravity_manipulation",
        "elemental_chaos"
      ],
      requirements: {
        level: 75,
        prestige: 2
      }
    });
    this.endgameState.replayableMaps.set("void_nexus", {
      id: "void_nexus",
      name: "Void Nexus",
      description: "The center of the void where ancient powers dwell",
      type: "nexus",
      difficulty: "legendary",
      maxPlayers: 8,
      phases: 5,
      currentPhase: 1,
      rewards: {
        experience: "maximum",
        loot: "unique",
        currency: "maximum",
        prestigePoints: true
      },
      modifiers: [
        "void_corruption",
        "dimensional_instability",
        "ancient_power",
        "cosmic_chaos"
      ],
      requirements: {
        level: 100,
        prestige: 5
      }
    });
  }
  /**
   * Initialize boss encounters
   */
  initializeBossEncounters() {
    this.endgameState.bossEncounters.set("dragon_king", {
      id: "dragon_king",
      name: "Dragon King",
      description: "The ancient ruler of all dragons",
      type: "world_boss",
      level: 100,
      health: 1e6,
      maxHealth: 1e6,
      phases: 4,
      currentPhase: 1,
      abilities: [
        "dragon_breath",
        "wing_beat",
        "tail_sweep",
        "dragon_roar",
        "meteor_storm",
        "dragon_rage"
      ],
      rewards: {
        experience: 5e4,
        gold: 1e5,
        items: ["dragon_king_crown", "dragon_king_scale", "dragon_king_heart"],
        uniqueItems: ["crown_of_dragons", "dragon_king_sword"]
      },
      respawnTime: 36e5,
      // 1 hour
      lastKilled: null,
      location: { x: 1e3, y: 1e3 },
      requirements: {
        level: 80,
        groupSize: 4
      }
    });
    this.endgameState.bossEncounters.set("void_lord", {
      id: "void_lord",
      name: "Void Lord",
      description: "The embodiment of the void itself",
      type: "raid_boss",
      level: 100,
      health: 2e6,
      maxHealth: 2e6,
      phases: 6,
      currentPhase: 1,
      abilities: [
        "void_blast",
        "dimensional_tear",
        "reality_break",
        "void_nova",
        "cosmic_storm",
        "void_consumption"
      ],
      rewards: {
        experience: 1e5,
        gold: 2e5,
        items: ["void_essence", "void_crystal", "void_heart"],
        uniqueItems: ["void_lord_crown", "void_lord_staff", "void_lord_armor"]
      },
      respawnTime: 72e5,
      // 2 hours
      lastKilled: null,
      location: { x: 2e3, y: 2e3 },
      requirements: {
        level: 90,
        groupSize: 8
      }
    });
    this.endgameState.bossEncounters.set("time_guardian", {
      id: "time_guardian",
      name: "Time Guardian",
      description: "The guardian of the temporal realm",
      type: "dungeon_boss",
      level: 95,
      health: 75e4,
      maxHealth: 75e4,
      phases: 3,
      currentPhase: 1,
      abilities: [
        "time_stop",
        "temporal_blast",
        "time_rewind",
        "chrono_storm",
        "temporal_prison"
      ],
      rewards: {
        experience: 75e3,
        gold: 15e4,
        items: ["time_crystal", "temporal_essence", "chrono_fragment"],
        uniqueItems: ["time_guardian_amulet", "temporal_blade"]
      },
      respawnTime: 18e5,
      // 30 minutes
      lastKilled: null,
      location: { x: 1500, y: 1500 },
      requirements: {
        level: 85,
        groupSize: 6
      }
    });
  }
  /**
   * Initialize PvP system
   */
  initializePvPSystem() {
    this.pvpSystem = {
      arenas: [
        {
          id: "duel_arena",
          name: "Duel Arena",
          description: "1v1 combat arena",
          maxPlayers: 2,
          type: "duel",
          map: "arena_small",
          rules: {
            timeLimit: 300,
            // 5 minutes
            respawns: false,
            items: "all",
            abilities: "all"
          }
        },
        {
          id: "team_arena",
          name: "Team Arena",
          description: "4v4 team combat",
          maxPlayers: 8,
          type: "team",
          map: "arena_large",
          rules: {
            timeLimit: 600,
            // 10 minutes
            respawns: true,
            items: "all",
            abilities: "all"
          }
        },
        {
          id: "battle_royale",
          name: "Battle Royale",
          description: "Last player standing",
          maxPlayers: 20,
          type: "battle_royale",
          map: "battle_royale_map",
          rules: {
            timeLimit: 1800,
            // 30 minutes
            respawns: false,
            items: "found_only",
            abilities: "all"
          }
        }
      ],
      rankings: /* @__PURE__ */ new Map(),
      seasons: [],
      currentSeason: null
    };
  }
  /**
   * Initialize raid system
   */
  initializeRaidSystem() {
    this.raidSystem = {
      raids: [
        {
          id: "dragon_raid",
          name: "Dragon Raid",
          description: "Raid the dragon's lair",
          maxPlayers: 8,
          difficulty: "hard",
          phases: 5,
          bosses: ["dragon_guardian", "dragon_queen", "dragon_king"],
          rewards: {
            experience: 2e5,
            gold: 5e5,
            items: ["dragon_raid_set"],
            uniqueItems: ["dragon_raid_weapon", "dragon_raid_armor"]
          },
          requirements: {
            level: 80,
            groupSize: 6
          }
        },
        {
          id: "void_raid",
          name: "Void Raid",
          description: "Conquer the void dimension",
          maxPlayers: 10,
          difficulty: "extreme",
          phases: 8,
          bosses: ["void_spawn", "void_guardian", "void_lord"],
          rewards: {
            experience: 5e5,
            gold: 1e6,
            items: ["void_raid_set"],
            uniqueItems: ["void_raid_weapon", "void_raid_armor"]
          },
          requirements: {
            level: 90,
            groupSize: 8
          }
        }
      ],
      activeRaids: /* @__PURE__ */ new Map(),
      raidHistory: []
    };
  }
  /**
   * Initialize leaderboards
   */
  initializeLeaderboards() {
    this.endgameState.leaderboards.set("level", {
      name: "Level Leaderboard",
      type: "level",
      entries: [],
      updateInterval: 6e4,
      lastUpdate: 0
    });
    this.endgameState.leaderboards.set("pvp", {
      name: "PvP Leaderboard",
      type: "pvp",
      entries: [],
      updateInterval: 3e4,
      lastUpdate: 0
    });
    this.endgameState.leaderboards.set("raid", {
      name: "Raid Leaderboard",
      type: "raid",
      entries: [],
      updateInterval: 12e4,
      lastUpdate: 0
    });
    this.endgameState.leaderboards.set("dungeon", {
      name: "Dungeon Leaderboard",
      type: "dungeon",
      entries: [],
      updateInterval: 3e5,
      lastUpdate: 0
    });
  }
  /**
   * Initialize seasonal content
   */
  initializeSeasonalContent() {
    this.endgameState.seasonalContent.set("winter_festival", {
      id: "winter_festival",
      name: "Winter Festival",
      description: "A magical winter celebration",
      startDate: /* @__PURE__ */ new Date("2024-12-01"),
      endDate: /* @__PURE__ */ new Date("2024-12-31"),
      active: false,
      rewards: {
        uniqueItems: ["winter_crown", "snow_queen_armor"],
        currency: "festival_coins",
        experience: "boosted"
      },
      events: [
        "snowball_fight",
        "ice_sculpting",
        "winter_races",
        "gift_exchange"
      ]
    });
    this.endgameState.seasonalContent.set("summer_solstice", {
      id: "summer_solstice",
      name: "Summer Solstice",
      description: "The longest day of the year brings special powers",
      startDate: /* @__PURE__ */ new Date("2024-06-20"),
      endDate: /* @__PURE__ */ new Date("2024-06-22"),
      active: false,
      rewards: {
        uniqueItems: ["sun_crown", "solstice_armor"],
        currency: "solstice_coins",
        experience: "boosted"
      },
      events: [
        "sun_worship",
        "fire_dancing",
        "summer_races",
        "light_rituals"
      ]
    });
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("endgame:unlock", this.unlockEndgame.bind(this));
    this.eventBus.on("endgame:prestige", this.prestigePlayer.bind(this));
    this.eventBus.on("map:enter", this.enterMap.bind(this));
    this.eventBus.on("map:complete", this.completeMap.bind(this));
    this.eventBus.on("boss:spawn", this.spawnBoss.bind(this));
    this.eventBus.on("boss:defeat", this.defeatBoss.bind(this));
    this.eventBus.on("pvp:join", this.joinPvP.bind(this));
    this.eventBus.on("pvp:leave", this.leavePvP.bind(this));
    this.eventBus.on("pvp:match", this.startPvPMatch.bind(this));
    this.eventBus.on("raid:start", this.startRaid.bind(this));
    this.eventBus.on("raid:complete", this.completeRaid.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("endgame:unlock", this.unlockEndgame.bind(this));
    this.eventBus.removeListener("endgame:prestige", this.prestigePlayer.bind(this));
    this.eventBus.removeListener("map:enter", this.enterMap.bind(this));
    this.eventBus.removeListener("map:complete", this.completeMap.bind(this));
    this.eventBus.removeListener("boss:spawn", this.spawnBoss.bind(this));
    this.eventBus.removeListener("boss:defeat", this.defeatBoss.bind(this));
    this.eventBus.removeListener("pvp:join", this.joinPvP.bind(this));
    this.eventBus.removeListener("pvp:leave", this.leavePvP.bind(this));
    this.eventBus.removeListener("pvp:match", this.startPvPMatch.bind(this));
    this.eventBus.removeListener("raid:start", this.startRaid.bind(this));
    this.eventBus.removeListener("raid:complete", this.completeRaid.bind(this));
  }
  /**
   * Unlock endgame content
   */
  unlockEndgame(data) {
    const { playerLevel } = data;
    if (playerLevel >= this.endgameConfig.maxLevel) {
      this.endgameState.endgameUnlocked = true;
      this.endgameState.playerLevel = playerLevel;
      this.eventBus.emit("endgame:unlocked", {
        playerLevel,
        timestamp: Date.now()
      });
      this.logger.info("Endgame content unlocked");
    }
  }
  /**
   * Prestige player
   */
  prestigePlayer(data) {
    const { playerId, currentLevel } = data;
    if (currentLevel < this.endgameConfig.maxLevel) {
      this.logger.warn("Player must be max level to prestige");
      return;
    }
    this.endgameState.prestigeLevel++;
    this.eventBus.emit("endgame:prestiged", {
      playerId,
      prestigeLevel: this.endgameState.prestigeLevel,
      timestamp: Date.now()
    });
    this.logger.info(`Player prestiged to level ${this.endgameState.prestigeLevel}`);
  }
  /**
   * Enter replayable map
   */
  enterMap(data) {
    const { mapId, playerId, groupId } = data;
    const map = this.endgameState.replayableMaps.get(mapId);
    if (!map) {
      this.logger.error(`Map not found: ${mapId}`);
      return;
    }
    if (!this.checkMapRequirements(map, playerId)) {
      this.logger.warn("Map requirements not met");
      return;
    }
    const mapInstance = this.createMapInstance(map, groupId);
    this.eventBus.emit("map:entered", {
      mapId,
      mapInstance,
      playerId,
      groupId,
      timestamp: Date.now()
    });
  }
  /**
   * Complete map
   */
  completeMap(data) {
    const { mapId, mapInstance, completionTime } = data;
    const rewards = this.calculateMapRewards(mapInstance, completionTime);
    this.updateMapLeaderboard(mapId, mapInstance, completionTime);
    this.eventBus.emit("map:completed", {
      mapId,
      mapInstance,
      rewards,
      completionTime,
      timestamp: Date.now()
    });
  }
  /**
   * Spawn boss
   */
  spawnBoss(data) {
    const { bossId, location } = data;
    const boss = this.endgameState.bossEncounters.get(bossId);
    if (!boss) {
      this.logger.error(`Boss not found: ${bossId}`);
      return;
    }
    if (boss.lastKilled && Date.now() - boss.lastKilled < boss.respawnTime) {
      this.logger.warn("Boss is still on cooldown");
      return;
    }
    boss.currentPhase = 1;
    boss.health = boss.maxHealth;
    boss.location = location || boss.location;
    this.eventBus.emit("boss:spawned", {
      bossId,
      boss,
      timestamp: Date.now()
    });
  }
  /**
   * Defeat boss
   */
  defeatBoss(data) {
    const { bossId, players } = data;
    const boss = this.endgameState.bossEncounters.get(bossId);
    if (!boss) {
      this.logger.error(`Boss not found: ${bossId}`);
      return;
    }
    const rewards = this.calculateBossRewards(boss, players);
    boss.lastKilled = Date.now();
    this.updateBossLeaderboard(bossId, players);
    this.eventBus.emit("boss:defeated", {
      bossId,
      boss,
      rewards,
      players,
      timestamp: Date.now()
    });
  }
  /**
   * Join PvP
   */
  joinPvP(data) {
    const { playerId, arenaId } = data;
    const arena = this.pvpSystem.arenas.find((a) => a.id === arenaId);
    if (!arena) {
      this.logger.error(`Arena not found: ${arenaId}`);
      return;
    }
    this.addToMatchmaking(playerId, arena);
    this.eventBus.emit("pvp:joined", {
      playerId,
      arenaId,
      timestamp: Date.now()
    });
  }
  /**
   * Leave PvP
   */
  leavePvP(data) {
    const { playerId, matchId } = data;
    this.removeFromMatch(playerId, matchId);
    this.eventBus.emit("pvp:left", {
      playerId,
      matchId,
      timestamp: Date.now()
    });
  }
  /**
   * Start PvP match
   */
  startPvPMatch(data) {
    const { matchId, players, arena } = data;
    const match = {
      id: matchId,
      arena,
      players,
      startTime: Date.now(),
      status: "active",
      results: []
    };
    this.endgameState.pvpMatches.set(matchId, match);
    this.eventBus.emit("pvp:matchStarted", {
      matchId,
      match,
      timestamp: Date.now()
    });
  }
  /**
   * Start raid
   */
  startRaid(data) {
    const { raidId, players } = data;
    const raid = this.raidSystem.raids.find((r) => r.id === raidId);
    if (!raid) {
      this.logger.error(`Raid not found: ${raidId}`);
      return;
    }
    if (!this.checkRaidRequirements(raid, players)) {
      this.logger.warn("Raid requirements not met");
      return;
    }
    const raidInstance = this.createRaidInstance(raid, players);
    this.endgameState.activeRaids.set(raidId, raidInstance);
    this.eventBus.emit("raid:started", {
      raidId,
      raidInstance,
      players,
      timestamp: Date.now()
    });
  }
  /**
   * Complete raid
   */
  completeRaid(data) {
    const { raidId, raidInstance, completionTime } = data;
    const rewards = this.calculateRaidRewards(raidInstance, completionTime);
    this.updateRaidLeaderboard(raidId, raidInstance, completionTime);
    this.endgameState.activeRaids.delete(raidId);
    this.eventBus.emit("raid:completed", {
      raidId,
      raidInstance,
      rewards,
      completionTime,
      timestamp: Date.now()
    });
  }
  /**
   * Update active raids
   */
  updateActiveRaids(deltaTime) {
    for (const [raidId, raid] of this.endgameState.activeRaids) {
      this.updateRaidInstance(raid, deltaTime);
    }
  }
  /**
   * Update PvP matches
   */
  updatePvPMatches(deltaTime) {
    for (const [matchId, match] of this.endgameState.pvpMatches) {
      this.updatePvPMatch(match, deltaTime);
    }
  }
  /**
   * Update boss encounters
   */
  updateBossEncounters(deltaTime) {
    for (const [bossId, boss] of this.endgameState.bossEncounters) {
      this.updateBossInstance(boss, deltaTime);
    }
  }
  /**
   * Update seasonal content
   */
  updateSeasonalContent(deltaTime) {
    const now = Date.now();
    for (const [seasonId, season] of this.endgameState.seasonalContent) {
      const isActive = now >= season.startDate.getTime() && now <= season.endDate.getTime();
      if (isActive !== season.active) {
        season.active = isActive;
        this.eventBus.emit("seasonal:statusChanged", {
          seasonId,
          active: isActive,
          timestamp: now
        });
      }
    }
  }
  /**
   * Update leaderboards
   */
  updateLeaderboards(deltaTime) {
    const now = Date.now();
    for (const [leaderboardId, leaderboard] of this.endgameState.leaderboards) {
      if (now - leaderboard.lastUpdate >= leaderboard.updateInterval) {
        this.updateLeaderboard(leaderboardId);
        leaderboard.lastUpdate = now;
      }
    }
  }
  /**
   * Check map requirements
   */
  checkMapRequirements(map, playerId) {
    if (this.endgameState.playerLevel < map.requirements.level) {
      return false;
    }
    if (this.endgameState.prestigeLevel < map.requirements.prestige) {
      return false;
    }
    return true;
  }
  /**
   * Create map instance
   */
  createMapInstance(map, groupId) {
    return {
      id: `map_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      mapId: map.id,
      groupId,
      startTime: Date.now(),
      currentFloor: map.type === "dungeon" ? 1 : 1,
      currentArea: map.type === "realm" ? 1 : 1,
      currentPhase: map.type === "nexus" ? 1 : 1,
      difficulty: map.difficulty,
      modifiers: [...map.modifiers],
      players: [],
      status: "active"
    };
  }
  /**
   * Calculate map rewards
   */
  calculateMapRewards(mapInstance, completionTime) {
    const baseRewards = {
      experience: 0,
      gold: 0,
      items: [],
      currency: 0
    };
    switch (mapInstance.mapId) {
      case "infinite_dungeon":
        baseRewards.experience = mapInstance.currentFloor * 1e3;
        baseRewards.gold = mapInstance.currentFloor * 500;
        break;
      case "nightmare_realm":
        baseRewards.experience = 5e4;
        baseRewards.gold = 25e3;
        baseRewards.currency = 1e3;
        break;
      case "void_nexus":
        baseRewards.experience = 1e5;
        baseRewards.gold = 5e4;
        baseRewards.currency = 2500;
        break;
    }
    const timeBonus = Math.max(0, 1 - completionTime / 36e5);
    baseRewards.experience *= 1 + timeBonus;
    baseRewards.gold *= 1 + timeBonus;
    return baseRewards;
  }
  /**
   * Calculate boss rewards
   */
  calculateBossRewards(boss, players) {
    const baseRewards = { ...boss.rewards };
    const playerCount = players.length;
    const scaleFactor = Math.min(2, 1 + (playerCount - 1) * 0.1);
    baseRewards.experience = Math.floor(baseRewards.experience * scaleFactor);
    baseRewards.gold = Math.floor(baseRewards.gold * scaleFactor);
    return baseRewards;
  }
  /**
   * Calculate raid rewards
   */
  calculateRaidRewards(raidInstance, completionTime) {
    const baseRewards = { ...raidInstance.rewards };
    const timeBonus = Math.max(0, 1 - completionTime / 72e5);
    baseRewards.experience *= 1 + timeBonus;
    baseRewards.gold *= 1 + timeBonus;
    return baseRewards;
  }
  /**
   * Update map leaderboard
   */
  updateMapLeaderboard(mapId, mapInstance, completionTime) {
    const leaderboard = this.endgameState.leaderboards.get("dungeon");
    const entry = {
      mapId,
      groupId: mapInstance.groupId,
      completionTime,
      timestamp: Date.now()
    };
    leaderboard.entries.push(entry);
    leaderboard.entries.sort((a, b) => a.completionTime - b.completionTime);
    leaderboard.entries = leaderboard.entries.slice(0, 100);
  }
  /**
   * Update boss leaderboard
   */
  updateBossLeaderboard(bossId, players) {
    const leaderboard = this.endgameState.leaderboards.get("raid");
    const entry = {
      bossId,
      players: players.map((p) => p.id),
      timestamp: Date.now()
    };
    leaderboard.entries.push(entry);
    leaderboard.entries.sort((a, b) => b.timestamp - a.timestamp);
    leaderboard.entries = leaderboard.entries.slice(0, 100);
  }
  /**
   * Update raid leaderboard
   */
  updateRaidLeaderboard(raidId, raidInstance, completionTime) {
    const leaderboard = this.endgameState.leaderboards.get("raid");
    const entry = {
      raidId,
      groupId: raidInstance.groupId,
      completionTime,
      timestamp: Date.now()
    };
    leaderboard.entries.push(entry);
    leaderboard.entries.sort((a, b) => a.completionTime - b.completionTime);
    leaderboard.entries = leaderboard.entries.slice(0, 100);
  }
  /**
   * Update leaderboard
   */
  updateLeaderboard(leaderboardId) {
    const leaderboard = this.endgameState.leaderboards.get(leaderboardId);
    switch (leaderboardId) {
      case "level":
        this.updateLevelLeaderboard(leaderboard);
        break;
      case "pvp":
        this.updatePvPLeaderboard(leaderboard);
        break;
      case "raid":
        this.updateRaidLeaderboard(leaderboard);
        break;
      case "dungeon":
        this.updateDungeonLeaderboard(leaderboard);
        break;
    }
  }
  /**
   * Update level leaderboard
   */
  updateLevelLeaderboard(leaderboard) {
    leaderboard.entries = [
      { playerId: "player1", level: 100, prestige: 5 },
      { playerId: "player2", level: 100, prestige: 4 },
      { playerId: "player3", level: 100, prestige: 3 }
    ];
  }
  /**
   * Update PvP leaderboard
   */
  updatePvPLeaderboard(leaderboard) {
    leaderboard.entries = [
      { playerId: "player1", rating: 2500, wins: 100, losses: 20 },
      { playerId: "player2", rating: 2400, wins: 95, losses: 25 },
      { playerId: "player3", rating: 2300, wins: 90, losses: 30 }
    ];
  }
  /**
   * Update raid leaderboard
   */
  updateRaidLeaderboard(leaderboard) {
    leaderboard.entries.sort((a, b) => a.completionTime - b.completionTime);
  }
  /**
   * Update dungeon leaderboard
   */
  updateDungeonLeaderboard(leaderboard) {
    leaderboard.entries.sort((a, b) => a.completionTime - b.completionTime);
  }
  /**
   * Add to matchmaking
   */
  addToMatchmaking(playerId, arena) {
    this.logger.info(`Player ${playerId} added to matchmaking for ${arena.name}`);
  }
  /**
   * Remove from match
   */
  removeFromMatch(playerId, matchId) {
    const match = this.endgameState.pvpMatches.get(matchId);
    if (match) {
      match.players = match.players.filter((p) => p.id !== playerId);
      if (match.players.length === 0) {
        this.endgameState.pvpMatches.delete(matchId);
      }
    }
  }
  /**
   * Check raid requirements
   */
  checkRaidRequirements(raid, players) {
    if (players.length < raid.requirements.groupSize) {
      return false;
    }
    return players.every((player) => player.level >= raid.requirements.level);
  }
  /**
   * Create raid instance
   */
  createRaidInstance(raid, players) {
    return {
      id: `raid_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      raidId: raid.id,
      players,
      startTime: Date.now(),
      currentPhase: 1,
      currentBoss: raid.bosses[0],
      status: "active"
    };
  }
  /**
   * Update raid instance
   */
  updateRaidInstance(raid, deltaTime) {
  }
  /**
   * Update PvP match
   */
  updatePvPMatch(match, deltaTime) {
  }
  /**
   * Update boss instance
   */
  updateBossInstance(boss, deltaTime) {
  }
  /**
   * Start background processes
   */
  startBackgroundProcesses() {
    this.leaderboardTimer = setInterval(() => {
      this.updateAllLeaderboards();
    }, 6e4);
    this.seasonalTimer = setInterval(() => {
      this.updateSeasonalContent(0);
    }, 6e4);
  }
  /**
   * Stop background processes
   */
  stopBackgroundProcesses() {
    if (this.leaderboardTimer) {
      clearInterval(this.leaderboardTimer);
    }
    if (this.seasonalTimer) {
      clearInterval(this.seasonalTimer);
    }
  }
  /**
   * Update all leaderboards
   */
  updateAllLeaderboards() {
    for (const leaderboardId of this.endgameState.leaderboards.keys()) {
      this.updateLeaderboard(leaderboardId);
    }
  }
  /**
   * Load endgame data
   */
  async loadEndgameData() {
    try {
      const savedData = localStorage.getItem("endgameData");
      if (savedData) {
        const data = JSON.parse(savedData);
        this.endgameState = { ...this.endgameState, ...data };
        this.logger.info("Endgame data loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load endgame data:", error);
    }
  }
  /**
   * Save endgame data
   */
  saveEndgameData() {
    try {
      const data = {
        playerLevel: this.endgameState.playerLevel,
        prestigeLevel: this.endgameState.prestigeLevel,
        endgameUnlocked: this.endgameState.endgameUnlocked,
        timestamp: Date.now()
      };
      localStorage.setItem("endgameData", JSON.stringify(data));
      this.logger.info("Endgame data saved to storage");
    } catch (error) {
      this.logger.error("Failed to save endgame data:", error);
    }
  }
  /**
   * Get endgame state
   */
  getEndgameState() {
    return { ...this.endgameState };
  }
  /**
   * Get replayable maps
   */
  getReplayableMaps() {
    return Array.from(this.endgameState.replayableMaps.values());
  }
  /**
   * Get boss encounters
   */
  getBossEncounters() {
    return Array.from(this.endgameState.bossEncounters.values());
  }
  /**
   * Get leaderboards
   */
  getLeaderboards() {
    return Array.from(this.endgameState.leaderboards.values());
  }
  /**
   * Get seasonal content
   */
  getSeasonalContent() {
    return Array.from(this.endgameState.seasonalContent.values());
  }
};

// src/systems/TradingSystem.js
var TradingSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("TradingSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("TradingSystem requires logger dependency");
    }
    this.tradingState = {
      activeTrades: /* @__PURE__ */ new Map(),
      tradeHistory: /* @__PURE__ */ new Map(),
      auctionHouse: /* @__PURE__ */ new Map(),
      marketPrices: /* @__PURE__ */ new Map(),
      playerReputation: /* @__PURE__ */ new Map(),
      currencyRates: /* @__PURE__ */ new Map(),
      tradeChannels: /* @__PURE__ */ new Map(),
      pendingTrades: /* @__PURE__ */ new Map()
    };
    this.tradingConfig = {
      maxTradeValue: 1e6,
      tradeTax: 0.05,
      // 5% tax on trades
      auctionTax: 0.1,
      // 10% tax on auctions
      maxAuctionDuration: 7 * 24 * 60 * 60 * 1e3,
      // 7 days
      minAuctionDuration: 60 * 60 * 1e3,
      // 1 hour
      reputationDecay: 0.01,
      // 1% reputation decay per day
      maxPendingTrades: 10,
      tradeTimeout: 3e5
      // 5 minutes
    };
    this.initializeCurrencies();
    this.initializeTradeChannels();
    this.initializeMarketData();
    this.initializeReputationSystem();
    this.setupEventHandlers();
    this.logger.info("TradingSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing TradingSystem...");
    await this.loadTradingData();
    this.startMarketUpdates();
    this.logger.info("TradingSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up TradingSystem...");
    this.saveTradingData();
    this.stopMarketUpdates();
    this.tradingState.activeTrades.clear();
    this.tradingState.tradeHistory.clear();
    this.tradingState.auctionHouse.clear();
    this.tradingState.marketPrices.clear();
    this.tradingState.playerReputation.clear();
    this.tradingState.currencyRates.clear();
    this.tradingState.tradeChannels.clear();
    this.tradingState.pendingTrades.clear();
    this.removeEventHandlers();
    this.logger.info("TradingSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updateActiveTrades(deltaTime);
    this.updateAuctionHouse(deltaTime);
    this.updateMarketPrices(deltaTime);
    this.updateReputationDecay(deltaTime);
  }
  /**
   * Initialize currencies
   */
  initializeCurrencies() {
    this.tradingState.currencyRates.set("gold", {
      name: "Gold",
      symbol: "G",
      baseValue: 1,
      decimals: 0
    });
    this.tradingState.currencyRates.set("silver", {
      name: "Silver",
      symbol: "S",
      baseValue: 0.1,
      decimals: 2
    });
    this.tradingState.currencyRates.set("copper", {
      name: "Copper",
      symbol: "C",
      baseValue: 0.01,
      decimals: 2
    });
    this.tradingState.currencyRates.set("platinum", {
      name: "Platinum",
      symbol: "P",
      baseValue: 10,
      decimals: 0
    });
    this.tradingState.currencyRates.set("gems", {
      name: "Gems",
      symbol: "💎",
      baseValue: 100,
      decimals: 0
    });
  }
  /**
   * Initialize trade channels
   */
  initializeTradeChannels() {
    this.tradingState.tradeChannels.set("global", {
      id: "global",
      name: "Global Trade",
      description: "Worldwide trading channel",
      maxPlayers: 1e3,
      taxRate: 0.05,
      minLevel: 1,
      active: true
    });
    this.tradingState.tradeChannels.set("guild", {
      id: "guild",
      name: "Guild Trade",
      description: "Guild-only trading channel",
      maxPlayers: 100,
      taxRate: 0.02,
      minLevel: 10,
      active: true
    });
    this.tradingState.tradeChannels.set("whisper", {
      id: "whisper",
      name: "Private Trade",
      description: "Direct player-to-player trading",
      maxPlayers: 2,
      taxRate: 0.01,
      minLevel: 1,
      active: true
    });
    this.tradingState.tradeChannels.set("premium", {
      id: "premium",
      name: "Premium Trade",
      description: "High-value trading channel",
      maxPlayers: 500,
      taxRate: 0.03,
      minLevel: 50,
      active: true
    });
  }
  /**
   * Initialize market data
   */
  initializeMarketData() {
    this.tradingState.marketPrices.set("health_potion", {
      item: "health_potion",
      basePrice: 10,
      currentPrice: 10,
      volatility: 0.1,
      lastUpdate: Date.now(),
      volume: 0,
      trend: "stable"
    });
    this.tradingState.marketPrices.set("mana_potion", {
      item: "mana_potion",
      basePrice: 15,
      currentPrice: 15,
      volatility: 0.1,
      lastUpdate: Date.now(),
      volume: 0,
      trend: "stable"
    });
    this.tradingState.marketPrices.set("iron_sword", {
      item: "iron_sword",
      basePrice: 100,
      currentPrice: 100,
      volatility: 0.2,
      lastUpdate: Date.now(),
      volume: 0,
      trend: "stable"
    });
    this.tradingState.marketPrices.set("magic_ring", {
      item: "magic_ring",
      basePrice: 500,
      currentPrice: 500,
      volatility: 0.3,
      lastUpdate: Date.now(),
      volume: 0,
      trend: "stable"
    });
  }
  /**
   * Initialize reputation system
   */
  initializeReputationSystem() {
    this.reputationSystem = {
      levels: [
        { name: "Hated", min: -1e3, max: -500, color: "#ff0000" },
        { name: "Disliked", min: -500, max: -100, color: "#ff8000" },
        { name: "Neutral", min: -100, max: 100, color: "#ffff00" },
        { name: "Liked", min: 100, max: 500, color: "#80ff00" },
        { name: "Respected", min: 500, max: 1e3, color: "#00ff00" },
        { name: "Honored", min: 1e3, max: 2e3, color: "#00ff80" },
        { name: "Revered", min: 2e3, max: 5e3, color: "#0080ff" },
        { name: "Exalted", min: 5e3, max: 1e4, color: "#8000ff" }
      ],
      decayRate: 0.01,
      // 1% per day
      maxReputation: 1e4,
      minReputation: -1e3
    };
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("trade:initiate", this.initiateTrade.bind(this));
    this.eventBus.on("trade:accept", this.acceptTrade.bind(this));
    this.eventBus.on("trade:decline", this.declineTrade.bind(this));
    this.eventBus.on("trade:modify", this.modifyTrade.bind(this));
    this.eventBus.on("trade:complete", this.completeTrade.bind(this));
    this.eventBus.on("trade:cancel", this.cancelTrade.bind(this));
    this.eventBus.on("auction:list", this.listAuction.bind(this));
    this.eventBus.on("auction:bid", this.placeBid.bind(this));
    this.eventBus.on("auction:buyout", this.buyoutAuction.bind(this));
    this.eventBus.on("auction:expire", this.expireAuction.bind(this));
    this.eventBus.on("market:priceUpdate", this.updateItemPrice.bind(this));
    this.eventBus.on("market:search", this.searchMarket.bind(this));
    this.eventBus.on("reputation:update", this.updateReputation.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("trade:initiate", this.initiateTrade.bind(this));
    this.eventBus.removeListener("trade:accept", this.acceptTrade.bind(this));
    this.eventBus.removeListener("trade:decline", this.declineTrade.bind(this));
    this.eventBus.removeListener("trade:modify", this.modifyTrade.bind(this));
    this.eventBus.removeListener("trade:complete", this.completeTrade.bind(this));
    this.eventBus.removeListener("trade:cancel", this.cancelTrade.bind(this));
    this.eventBus.removeListener("auction:list", this.listAuction.bind(this));
    this.eventBus.removeListener("auction:bid", this.placeBid.bind(this));
    this.eventBus.removeListener("auction:buyout", this.buyoutAuction.bind(this));
    this.eventBus.removeListener("auction:expire", this.expireAuction.bind(this));
    this.eventBus.removeListener("market:priceUpdate", this.updateItemPrice.bind(this));
    this.eventBus.removeListener("market:search", this.searchMarket.bind(this));
    this.eventBus.removeListener("reputation:update", this.updateReputation.bind(this));
  }
  /**
   * Initiate trade
   */
  initiateTrade(data) {
    const { fromPlayer, toPlayer, items, currency, channel } = data;
    if (!this.validateTrade(fromPlayer, toPlayer, items, currency)) {
      this.logger.warn("Invalid trade request");
      return;
    }
    if (!this.canPlayersTrade(fromPlayer, toPlayer)) {
      this.logger.warn("Players cannot trade");
      return;
    }
    const trade = this.createTrade(fromPlayer, toPlayer, items, currency, channel);
    this.tradingState.activeTrades.set(trade.id, trade);
    this.eventBus.emit("trade:initiated", {
      trade,
      timestamp: Date.now()
    });
  }
  /**
   * Accept trade
   */
  acceptTrade(data) {
    const { tradeId, playerId } = data;
    const trade = this.tradingState.activeTrades.get(tradeId);
    if (!trade) {
      this.logger.error(`Trade not found: ${tradeId}`);
      return;
    }
    if (trade.toPlayer.id !== playerId) {
      this.logger.warn("Player cannot accept this trade");
      return;
    }
    trade.status = "accepted";
    trade.acceptedAt = Date.now();
    this.startTradeCompletionTimer(trade);
    this.eventBus.emit("trade:accepted", {
      trade,
      timestamp: Date.now()
    });
  }
  /**
   * Decline trade
   */
  declineTrade(data) {
    const { tradeId, playerId, reason } = data;
    const trade = this.tradingState.activeTrades.get(tradeId);
    if (!trade) {
      this.logger.error(`Trade not found: ${tradeId}`);
      return;
    }
    if (trade.toPlayer.id !== playerId) {
      this.logger.warn("Player cannot decline this trade");
      return;
    }
    trade.status = "declined";
    trade.declinedAt = Date.now();
    trade.declineReason = reason;
    this.tradingState.activeTrades.delete(tradeId);
    this.eventBus.emit("trade:declined", {
      trade,
      reason,
      timestamp: Date.now()
    });
  }
  /**
   * Modify trade
   */
  modifyTrade(data) {
    const { tradeId, playerId, newItems, newCurrency } = data;
    const trade = this.tradingState.activeTrades.get(tradeId);
    if (!trade) {
      this.logger.error(`Trade not found: ${tradeId}`);
      return;
    }
    if (trade.fromPlayer.id !== playerId) {
      this.logger.warn("Player cannot modify this trade");
      return;
    }
    trade.items = newItems;
    trade.currency = newCurrency;
    trade.modifiedAt = Date.now();
    this.eventBus.emit("trade:modified", {
      trade,
      timestamp: Date.now()
    });
  }
  /**
   * Complete trade
   */
  completeTrade(data) {
    const { tradeId } = data;
    const trade = this.tradingState.activeTrades.get(tradeId);
    if (!trade) {
      this.logger.error(`Trade not found: ${tradeId}`);
      return;
    }
    if (trade.status !== "accepted") {
      this.logger.warn("Trade not accepted");
      return;
    }
    this.executeTrade(trade);
    this.updateTradeReputation(trade);
    this.addToTradeHistory(trade);
    this.tradingState.activeTrades.delete(tradeId);
    this.eventBus.emit("trade:completed", {
      trade,
      timestamp: Date.now()
    });
  }
  /**
   * Cancel trade
   */
  cancelTrade(data) {
    const { tradeId, playerId, reason } = data;
    const trade = this.tradingState.activeTrades.get(tradeId);
    if (!trade) {
      this.logger.error(`Trade not found: ${tradeId}`);
      return;
    }
    if (trade.fromPlayer.id !== playerId) {
      this.logger.warn("Player cannot cancel this trade");
      return;
    }
    trade.status = "cancelled";
    trade.cancelledAt = Date.now();
    trade.cancelReason = reason;
    this.tradingState.activeTrades.delete(tradeId);
    this.eventBus.emit("trade:cancelled", {
      trade,
      reason,
      timestamp: Date.now()
    });
  }
  /**
   * List auction
   */
  listAuction(data) {
    const { playerId, item, startingPrice, buyoutPrice, duration, channel } = data;
    if (!this.validateAuction(playerId, item, startingPrice, buyoutPrice, duration)) {
      this.logger.warn("Invalid auction request");
      return;
    }
    const auction = this.createAuction(playerId, item, startingPrice, buyoutPrice, duration, channel);
    this.tradingState.auctionHouse.set(auction.id, auction);
    this.eventBus.emit("auction:listed", {
      auction,
      timestamp: Date.now()
    });
  }
  /**
   * Place bid
   */
  placeBid(data) {
    const { auctionId, playerId, bidAmount } = data;
    const auction = this.tradingState.auctionHouse.get(auctionId);
    if (!auction) {
      this.logger.error(`Auction not found: ${auctionId}`);
      return;
    }
    if (auction.status !== "active") {
      this.logger.warn("Auction not active");
      return;
    }
    if (bidAmount <= auction.currentBid) {
      this.logger.warn("Bid too low");
      return;
    }
    auction.currentBid = bidAmount;
    auction.currentBidder = playerId;
    auction.bidCount++;
    auction.lastBidAt = Date.now();
    this.eventBus.emit("auction:bidPlaced", {
      auction,
      bidAmount,
      playerId,
      timestamp: Date.now()
    });
  }
  /**
   * Buyout auction
   */
  buyoutAuction(data) {
    const { auctionId, playerId } = data;
    const auction = this.tradingState.auctionHouse.get(auctionId);
    if (!auction) {
      this.logger.error(`Auction not found: ${auctionId}`);
      return;
    }
    if (auction.status !== "active") {
      this.logger.warn("Auction not active");
      return;
    }
    if (!auction.buyoutPrice) {
      this.logger.warn("Auction has no buyout price");
      return;
    }
    this.completeAuction(auction, playerId, auction.buyoutPrice);
    this.eventBus.emit("auction:buyout", {
      auction,
      playerId,
      timestamp: Date.now()
    });
  }
  /**
   * Expire auction
   */
  expireAuction(data) {
    const { auctionId } = data;
    const auction = this.tradingState.auctionHouse.get(auctionId);
    if (!auction) {
      this.logger.error(`Auction not found: ${auctionId}`);
      return;
    }
    auction.status = "expired";
    auction.expiredAt = Date.now();
    if (auction.currentBidder) {
      this.completeAuction(auction, auction.currentBidder, auction.currentBid);
    } else {
      this.returnAuctionItem(auction);
    }
    this.eventBus.emit("auction:expired", {
      auction,
      timestamp: Date.now()
    });
  }
  /**
   * Update item price
   */
  updateItemPrice(data) {
    const { item, newPrice, volume } = data;
    const priceData = this.tradingState.marketPrices.get(item);
    if (!priceData) {
      this.logger.error(`Price data not found for item: ${item}`);
      return;
    }
    const oldPrice = priceData.currentPrice;
    priceData.currentPrice = newPrice;
    priceData.volume += volume || 1;
    priceData.lastUpdate = Date.now();
    if (newPrice > oldPrice) {
      priceData.trend = "rising";
    } else if (newPrice < oldPrice) {
      priceData.trend = "falling";
    } else {
      priceData.trend = "stable";
    }
    this.eventBus.emit("market:priceUpdated", {
      item,
      oldPrice,
      newPrice,
      trend: priceData.trend,
      timestamp: Date.now()
    });
  }
  /**
   * Search market
   */
  searchMarket(data) {
    const { query, filters, sortBy, limit } = data;
    let results = [];
    for (const trade of this.tradingState.activeTrades.values()) {
      if (this.matchesSearchCriteria(trade, query, filters)) {
        results.push({
          type: "trade",
          id: trade.id,
          item: trade.items[0],
          price: trade.currency,
          player: trade.fromPlayer,
          timestamp: trade.createdAt
        });
      }
    }
    for (const auction of this.tradingState.auctionHouse.values()) {
      if (auction.status === "active" && this.matchesSearchCriteria(auction, query, filters)) {
        results.push({
          type: "auction",
          id: auction.id,
          item: auction.item,
          price: auction.currentBid,
          buyoutPrice: auction.buyoutPrice,
          player: auction.seller,
          timeLeft: auction.endTime - Date.now(),
          timestamp: auction.createdAt
        });
      }
    }
    results = this.sortSearchResults(results, sortBy);
    if (limit) {
      results = results.slice(0, limit);
    }
    this.eventBus.emit("market:searchResults", {
      query,
      results,
      timestamp: Date.now()
    });
  }
  /**
   * Update reputation
   */
  updateReputation(data) {
    const { playerId, change, reason } = data;
    const currentRep = this.tradingState.playerReputation.get(playerId) || 0;
    const newRep = Math.max(
      this.reputationSystem.minReputation,
      Math.min(this.reputationSystem.maxReputation, currentRep + change)
    );
    this.tradingState.playerReputation.set(playerId, newRep);
    this.eventBus.emit("reputation:updated", {
      playerId,
      oldReputation: currentRep,
      newReputation: newRep,
      change,
      reason,
      timestamp: Date.now()
    });
  }
  /**
   * Update active trades
   */
  updateActiveTrades(deltaTime) {
    const now = Date.now();
    for (const [tradeId, trade] of this.tradingState.activeTrades) {
      if (now - trade.createdAt > this.tradingConfig.tradeTimeout) {
        this.timeoutTrade(trade);
      }
    }
  }
  /**
   * Update auction house
   */
  updateAuctionHouse(deltaTime) {
    const now = Date.now();
    for (const [auctionId, auction] of this.tradingState.auctionHouse) {
      if (auction.status === "active" && now >= auction.endTime) {
        this.expireAuction({ auctionId });
      }
    }
  }
  /**
   * Update market prices
   */
  updateMarketPrices(deltaTime) {
    for (const [item, priceData] of this.tradingState.marketPrices) {
      this.updateMarketPrice(priceData, deltaTime);
    }
  }
  /**
   * Update reputation decay
   */
  updateReputationDecay(deltaTime) {
    const decayAmount = this.tradingConfig.reputationDecay * deltaTime / (24 * 60 * 60 * 1e3);
    for (const [playerId, reputation] of this.tradingState.playerReputation) {
      const newRep = Math.max(
        this.reputationSystem.minReputation,
        reputation - decayAmount
      );
      if (newRep !== reputation) {
        this.tradingState.playerReputation.set(playerId, newRep);
      }
    }
  }
  /**
   * Validate trade
   */
  validateTrade(fromPlayer, toPlayer, items, currency) {
    if (!fromPlayer || !toPlayer) {
      return false;
    }
    if (fromPlayer.id === toPlayer.id) {
      return false;
    }
    if (!items || items.length === 0) {
      return false;
    }
    if (!currency || currency.amount <= 0) {
      return false;
    }
    const totalValue = this.calculateTradeValue(items, currency);
    if (totalValue > this.tradingConfig.maxTradeValue) {
      return false;
    }
    return true;
  }
  /**
   * Check if players can trade
   */
  canPlayersTrade(fromPlayer, toPlayer) {
    if (!fromPlayer.online || !toPlayer.online) {
      return false;
    }
    if (fromPlayer.areaId !== toPlayer.areaId) {
      return false;
    }
    if (fromPlayer.inCombat || toPlayer.inCombat) {
      return false;
    }
    return true;
  }
  /**
   * Create trade
   */
  createTrade(fromPlayer, toPlayer, items, currency, channel) {
    return {
      id: `trade_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      fromPlayer,
      toPlayer,
      items,
      currency,
      channel,
      status: "pending",
      createdAt: Date.now(),
      acceptedAt: null,
      declinedAt: null,
      completedAt: null,
      cancelledAt: null
    };
  }
  /**
   * Execute trade
   */
  executeTrade(trade) {
    this.transferItems(trade.fromPlayer, trade.toPlayer, trade.items);
    this.transferCurrency(trade.toPlayer, trade.fromPlayer, trade.currency);
    this.applyTradeTax(trade);
    trade.status = "completed";
    trade.completedAt = Date.now();
  }
  /**
   * Transfer items
   */
  transferItems(fromPlayer, toPlayer, items) {
    this.logger.info(`Transferred ${items.length} items from ${fromPlayer.id} to ${toPlayer.id}`);
  }
  /**
   * Transfer currency
   */
  transferCurrency(fromPlayer, toPlayer, currency) {
    this.logger.info(`Transferred ${currency.amount} ${currency.type} from ${fromPlayer.id} to ${toPlayer.id}`);
  }
  /**
   * Apply trade tax
   */
  applyTradeTax(trade) {
    const channel = this.tradingState.tradeChannels.get(trade.channel);
    if (channel) {
      const taxAmount = trade.currency.amount * channel.taxRate;
      this.logger.info(`Applied ${taxAmount} tax to trade ${trade.id}`);
    }
  }
  /**
   * Update trade reputation
   */
  updateTradeReputation(trade) {
    this.updateReputation({
      playerId: trade.fromPlayer.id,
      change: 10,
      reason: "successful_trade"
    });
    this.updateReputation({
      playerId: trade.toPlayer.id,
      change: 10,
      reason: "successful_trade"
    });
  }
  /**
   * Add to trade history
   */
  addToTradeHistory(trade) {
    this.tradingState.tradeHistory.set(trade.id, {
      ...trade,
      historyType: "completed"
    });
  }
  /**
   * Start trade completion timer
   */
  startTradeCompletionTimer(trade) {
    setTimeout(() => {
      if (trade.status === "accepted") {
        this.completeTrade({ tradeId: trade.id });
      }
    }, 3e4);
  }
  /**
   * Timeout trade
   */
  timeoutTrade(trade) {
    trade.status = "timeout";
    trade.timeoutAt = Date.now();
    this.tradingState.activeTrades.delete(trade.id);
    this.eventBus.emit("trade:timeout", {
      trade,
      timestamp: Date.now()
    });
  }
  /**
   * Validate auction
   */
  validateAuction(playerId, item, startingPrice, buyoutPrice, duration) {
    if (!playerId) {
      return false;
    }
    if (!item) {
      return false;
    }
    if (startingPrice <= 0) {
      return false;
    }
    if (buyoutPrice && buyoutPrice <= startingPrice) {
      return false;
    }
    if (duration < this.tradingConfig.minAuctionDuration || duration > this.tradingConfig.maxAuctionDuration) {
      return false;
    }
    return true;
  }
  /**
   * Create auction
   */
  createAuction(playerId, item, startingPrice, buyoutPrice, duration, channel) {
    return {
      id: `auction_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      seller: playerId,
      item,
      startingPrice,
      currentBid: startingPrice,
      buyoutPrice,
      currentBidder: null,
      bidCount: 0,
      channel,
      status: "active",
      createdAt: Date.now(),
      endTime: Date.now() + duration,
      lastBidAt: null,
      completedAt: null,
      expiredAt: null
    };
  }
  /**
   * Complete auction
   */
  completeAuction(auction, buyerId, finalPrice) {
    auction.status = "completed";
    auction.completedAt = Date.now();
    auction.finalPrice = finalPrice;
    auction.buyer = buyerId;
    this.transferAuctionItem(auction);
    this.transferAuctionCurrency(auction);
    this.applyAuctionTax(auction);
  }
  /**
   * Return auction item
   */
  returnAuctionItem(auction) {
    this.logger.info(`Returned auction item to seller ${auction.seller}`);
  }
  /**
   * Transfer auction item
   */
  transferAuctionItem(auction) {
    this.logger.info(`Transferred auction item from ${auction.seller} to ${auction.buyer}`);
  }
  /**
   * Transfer auction currency
   */
  transferAuctionCurrency(auction) {
    this.logger.info(`Transferred ${auction.finalPrice} currency for auction ${auction.id}`);
  }
  /**
   * Apply auction tax
   */
  applyAuctionTax(auction) {
    const taxAmount = auction.finalPrice * this.tradingConfig.auctionTax;
    this.logger.info(`Applied ${taxAmount} tax to auction ${auction.id}`);
  }
  /**
   * Calculate trade value
   */
  calculateTradeValue(items, currency) {
    let totalValue = 0;
    items.forEach((item) => {
      const priceData = this.tradingState.marketPrices.get(item.type);
      if (priceData) {
        totalValue += priceData.currentPrice * item.quantity;
      }
    });
    totalValue += currency.amount;
    return totalValue;
  }
  /**
   * Matches search criteria
   */
  matchesSearchCriteria(item, query, filters) {
    if (query && !item.item.name.toLowerCase().includes(query.toLowerCase())) {
      return false;
    }
    if (filters) {
      if (filters.minPrice && item.price < filters.minPrice) {
        return false;
      }
      if (filters.maxPrice && item.price > filters.maxPrice) {
        return false;
      }
      if (filters.itemType && item.item.type !== filters.itemType) {
        return false;
      }
      if (filters.rarity && item.item.rarity !== filters.rarity) {
        return false;
      }
    }
    return true;
  }
  /**
   * Sort search results
   */
  sortSearchResults(results, sortBy) {
    switch (sortBy) {
      case "price_asc":
        return results.sort((a, b) => a.price - b.price);
      case "price_desc":
        return results.sort((a, b) => b.price - a.price);
      case "time_asc":
        return results.sort((a, b) => a.timestamp - b.timestamp);
      case "time_desc":
        return results.sort((a, b) => b.timestamp - a.timestamp);
      default:
        return results;
    }
  }
  /**
   * Update market price
   */
  updateMarketPrice(priceData, deltaTime) {
    const volatility = priceData.volatility;
    const change = (Math.random() - 0.5) * volatility * deltaTime / 1e3;
    priceData.currentPrice = Math.max(1, priceData.currentPrice + change);
  }
  /**
   * Start market updates
   */
  startMarketUpdates() {
    this.marketUpdateTimer = setInterval(() => {
      this.updateAllMarketPrices();
    }, 6e4);
  }
  /**
   * Stop market updates
   */
  stopMarketUpdates() {
    if (this.marketUpdateTimer) {
      clearInterval(this.marketUpdateTimer);
    }
  }
  /**
   * Update all market prices
   */
  updateAllMarketPrices() {
    for (const [item, priceData] of this.tradingState.marketPrices) {
      this.updateMarketPrice(priceData, 6e4);
    }
  }
  /**
   * Load trading data
   */
  async loadTradingData() {
    try {
      const savedData = localStorage.getItem("tradingData");
      if (savedData) {
        const data = JSON.parse(savedData);
        this.tradingState = { ...this.tradingState, ...data };
        this.logger.info("Trading data loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load trading data:", error);
    }
  }
  /**
   * Save trading data
   */
  saveTradingData() {
    try {
      const data = {
        tradeHistory: Array.from(this.tradingState.tradeHistory.entries()),
        marketPrices: Array.from(this.tradingState.marketPrices.entries()),
        playerReputation: Array.from(this.tradingState.playerReputation.entries()),
        timestamp: Date.now()
      };
      localStorage.setItem("tradingData", JSON.stringify(data));
      this.logger.info("Trading data saved to storage");
    } catch (error) {
      this.logger.error("Failed to save trading data:", error);
    }
  }
  /**
   * Get active trades
   */
  getActiveTrades() {
    return Array.from(this.tradingState.activeTrades.values());
  }
  /**
   * Get auction house
   */
  getAuctionHouse() {
    return Array.from(this.tradingState.auctionHouse.values());
  }
  /**
   * Get market prices
   */
  getMarketPrices() {
    return Array.from(this.tradingState.marketPrices.values());
  }
  /**
   * Get player reputation
   */
  getPlayerReputation(playerId) {
    return this.tradingState.playerReputation.get(playerId) || 0;
  }
  /**
   * Get trade history
   */
  getTradeHistory(playerId) {
    const history = [];
    for (const trade of this.tradingState.tradeHistory.values()) {
      if (trade.fromPlayer.id === playerId || trade.toPlayer.id === playerId) {
        history.push(trade);
      }
    }
    return history;
  }
};

// src/systems/ErrorHandlingSystem.js
var ErrorHandlingSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("ErrorHandlingSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("ErrorHandlingSystem requires logger dependency");
    }
    this.errorState = {
      errorCount: 0,
      lastError: null,
      errorHistory: [],
      performanceMetrics: /* @__PURE__ */ new Map(),
      validationRules: /* @__PURE__ */ new Map(),
      recoveryStrategies: /* @__PURE__ */ new Map(),
      userNotifications: /* @__PURE__ */ new Map(),
      errorThresholds: /* @__PURE__ */ new Map()
    };
    this.errorConfig = {
      maxErrorHistory: 1e3,
      errorReportingEnabled: true,
      performanceMonitoringEnabled: true,
      autoRecoveryEnabled: true,
      userNotificationEnabled: true,
      errorThresholds: {
        critical: 5,
        warning: 10,
        info: 50
      },
      performanceThresholds: {
        memoryUsage: 0.8,
        // 80%
        cpuUsage: 0.7,
        // 70%
        frameRate: 30,
        // FPS
        responseTime: 1e3
        // ms
      }
    };
    this.initializeErrorHandling();
    this.initializeValidationRules();
    this.initializeRecoveryStrategies();
    this.initializePerformanceMonitoring();
    this.setupEventHandlers();
    this.logger.info("ErrorHandlingSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing ErrorHandlingSystem...");
    this.setupGlobalErrorHandlers();
    this.startPerformanceMonitoring();
    await this.loadErrorData();
    this.logger.info("ErrorHandlingSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up ErrorHandlingSystem...");
    this.saveErrorData();
    this.stopPerformanceMonitoring();
    this.removeGlobalErrorHandlers();
    this.errorState.errorHistory.clear();
    this.errorState.performanceMetrics.clear();
    this.errorState.validationRules.clear();
    this.errorState.recoveryStrategies.clear();
    this.errorState.userNotifications.clear();
    this.errorState.errorThresholds.clear();
    this.removeEventHandlers();
    this.logger.info("ErrorHandlingSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updatePerformanceMetrics(deltaTime);
    this.checkErrorThresholds();
    this.processErrorRecovery(deltaTime);
    this.updateUserNotifications(deltaTime);
  }
  /**
   * Initialize error handling
   */
  initializeErrorHandling() {
    this.errorTypes = {
      VALIDATION_ERROR: "validation_error",
      NETWORK_ERROR: "network_error",
      RUNTIME_ERROR: "runtime_error",
      PERFORMANCE_ERROR: "performance_error",
      USER_ERROR: "user_error",
      SYSTEM_ERROR: "system_error",
      UNKNOWN_ERROR: "unknown_error"
    };
    this.severityLevels = {
      CRITICAL: "critical",
      HIGH: "high",
      MEDIUM: "medium",
      LOW: "low",
      INFO: "info"
    };
    this.errorCategories = {
      INPUT_VALIDATION: "input_validation",
      API_CALLS: "api_calls",
      RENDERING: "rendering",
      GAME_LOGIC: "game_logic",
      MEMORY_MANAGEMENT: "memory_management",
      NETWORK_COMMUNICATION: "network_communication",
      FILE_OPERATIONS: "file_operations",
      USER_INTERACTION: "user_interaction"
    };
  }
  /**
   * Initialize validation rules
   */
  initializeValidationRules() {
    this.errorState.validationRules.set("player_name", {
      required: true,
      minLength: 3,
      maxLength: 20,
      pattern: /^[a-zA-Z0-9_]+$/,
      message: "Player name must be 3-20 characters long and contain only letters, numbers, and underscores"
    });
    this.errorState.validationRules.set("email", {
      required: true,
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      message: "Please enter a valid email address"
    });
    this.errorState.validationRules.set("password", {
      required: true,
      minLength: 8,
      maxLength: 128,
      pattern: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
      message: "Password must be 8-128 characters long and contain at least one uppercase letter, one lowercase letter, one number, and one special character"
    });
    this.errorState.validationRules.set("item_id", {
      required: true,
      pattern: /^item_\d+_[a-zA-Z0-9]+$/,
      message: "Invalid item ID format"
    });
    this.errorState.validationRules.set("trade_amount", {
      required: true,
      min: 1,
      max: 1e6,
      type: "number",
      message: "Trade amount must be between 1 and 1,000,000"
    });
    this.errorState.validationRules.set("character_level", {
      required: true,
      min: 1,
      max: 100,
      type: "number",
      message: "Character level must be between 1 and 100"
    });
    this.errorState.validationRules.set("skill_points", {
      required: true,
      min: 0,
      max: 1e3,
      type: "number",
      message: "Skill points must be between 0 and 1000"
    });
    this.errorState.validationRules.set("coordinates", {
      required: true,
      type: "object",
      properties: {
        x: { type: "number", min: -1e4, max: 1e4 },
        y: { type: "number", min: -1e4, max: 1e4 }
      },
      message: "Coordinates must be valid numbers within the game world bounds"
    });
  }
  /**
   * Initialize recovery strategies
   */
  initializeRecoveryStrategies() {
    this.errorState.recoveryStrategies.set("network_error", {
      maxRetries: 3,
      retryDelay: 1e3,
      backoffMultiplier: 2,
      fallbackAction: "offline_mode",
      recoverySteps: [
        "retry_request",
        "check_connection",
        "fallback_to_cached_data",
        "notify_user"
      ]
    });
    this.errorState.recoveryStrategies.set("memory_error", {
      maxRetries: 1,
      retryDelay: 0,
      fallbackAction: "cleanup_memory",
      recoverySteps: [
        "clear_cache",
        "garbage_collect",
        "reduce_quality",
        "notify_user"
      ]
    });
    this.errorState.recoveryStrategies.set("rendering_error", {
      maxRetries: 2,
      retryDelay: 100,
      fallbackAction: "fallback_renderer",
      recoverySteps: [
        "retry_render",
        "clear_render_cache",
        "fallback_to_simple_renderer",
        "notify_user"
      ]
    });
    this.errorState.recoveryStrategies.set("game_logic_error", {
      maxRetries: 1,
      retryDelay: 0,
      fallbackAction: "reset_game_state",
      recoverySteps: [
        "validate_game_state",
        "reset_to_last_save",
        "notify_user"
      ]
    });
  }
  /**
   * Initialize performance monitoring
   */
  initializePerformanceMonitoring() {
    this.performanceMetrics = {
      memoryUsage: 0,
      cpuUsage: 0,
      frameRate: 0,
      responseTime: 0,
      errorRate: 0,
      lastUpdate: Date.now()
    };
    this.performanceHistory = [];
    this.maxPerformanceHistory = 100;
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("error:occurred", this.handleError.bind(this));
    this.eventBus.on("error:recovered", this.handleErrorRecovery.bind(this));
    this.eventBus.on("error:threshold_exceeded", this.handleThresholdExceeded.bind(this));
    this.eventBus.on("validation:failed", this.handleValidationFailure.bind(this));
    this.eventBus.on("validation:passed", this.handleValidationSuccess.bind(this));
    this.eventBus.on("performance:metric", this.handlePerformanceMetric.bind(this));
    this.eventBus.on("performance:threshold_exceeded", this.handlePerformanceThresholdExceeded.bind(this));
    this.eventBus.on("recovery:started", this.handleRecoveryStarted.bind(this));
    this.eventBus.on("recovery:completed", this.handleRecoveryCompleted.bind(this));
    this.eventBus.on("recovery:failed", this.handleRecoveryFailed.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("error:occurred", this.handleError.bind(this));
    this.eventBus.removeListener("error:recovered", this.handleErrorRecovery.bind(this));
    this.eventBus.removeListener("error:threshold_exceeded", this.handleThresholdExceeded.bind(this));
    this.eventBus.removeListener("validation:failed", this.handleValidationFailure.bind(this));
    this.eventBus.removeListener("validation:passed", this.handleValidationSuccess.bind(this));
    this.eventBus.removeListener("performance:metric", this.handlePerformanceMetric.bind(this));
    this.eventBus.removeListener("performance:threshold_exceeded", this.handlePerformanceThresholdExceeded.bind(this));
    this.eventBus.removeListener("recovery:started", this.handleRecoveryStarted.bind(this));
    this.eventBus.removeListener("recovery:completed", this.handleRecoveryCompleted.bind(this));
    this.eventBus.removeListener("recovery:failed", this.handleRecoveryFailed.bind(this));
  }
  /**
   * Set up global error handlers
   */
  setupGlobalErrorHandlers() {
    window.addEventListener("error", (event) => {
      this.handleGlobalError(event.error, event.filename, event.lineno, event.colno);
    });
    window.addEventListener("unhandledrejection", (event) => {
      this.handleUnhandledRejection(event.reason, event.promise);
    });
    const originalConsoleError = console.error;
    console.error = (...args) => {
      this.handleConsoleError(args);
      originalConsoleError.apply(console, args);
    };
  }
  /**
   * Remove global error handlers
   */
  removeGlobalErrorHandlers() {
    window.removeEventListener("error", this.handleGlobalError);
    window.removeEventListener("unhandledrejection", this.handleUnhandledRejection);
  }
  /**
   * Handle error
   */
  handleError(data) {
    const { error, context, severity, category } = data;
    const errorRecord = this.createErrorRecord(error, context, severity, category);
    this.addToErrorHistory(errorRecord);
    this.errorState.errorCount++;
    this.errorState.lastError = errorRecord;
    this.logError(errorRecord);
    this.attemptRecovery(errorRecord);
    this.notifyUser(errorRecord);
    if (this.errorConfig.errorReportingEnabled) {
      this.reportError(errorRecord);
    }
  }
  /**
   * Handle global error
   */
  handleGlobalError(error, filename, lineno, colno) {
    const errorRecord = {
      type: this.errorTypes.RUNTIME_ERROR,
      severity: this.severityLevels.HIGH,
      category: this.errorCategories.RENDERING,
      message: error.message || "Unknown error",
      stack: error.stack,
      filename,
      line: lineno,
      column: colno,
      timestamp: Date.now(),
      context: {
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: Date.now()
      }
    };
    this.handleError({ error: errorRecord });
  }
  /**
   * Handle unhandled rejection
   */
  handleUnhandledRejection(reason, promise) {
    const errorRecord = {
      type: this.errorTypes.RUNTIME_ERROR,
      severity: this.severityLevels.MEDIUM,
      category: this.errorCategories.API_CALLS,
      message: reason.message || "Unhandled promise rejection",
      stack: reason.stack,
      promise,
      timestamp: Date.now(),
      context: {
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: Date.now()
      }
    };
    this.handleError({ error: errorRecord });
  }
  /**
   * Handle console error
   */
  handleConsoleError(args) {
    const errorRecord = {
      type: this.errorTypes.RUNTIME_ERROR,
      severity: this.severityLevels.LOW,
      category: this.errorCategories.GAME_LOGIC,
      message: args.join(" "),
      timestamp: Date.now(),
      context: {
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: Date.now()
      }
    };
    this.handleError({ error: errorRecord });
  }
  /**
   * Create error record
   */
  createErrorRecord(error, context, severity, category) {
    return {
      id: `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: error.type || this.errorTypes.UNKNOWN_ERROR,
      severity: severity || this.severityLevels.MEDIUM,
      category: category || this.errorCategories.GAME_LOGIC,
      message: error.message || "Unknown error",
      stack: error.stack,
      context: context || {},
      timestamp: Date.now(),
      resolved: false,
      recoveryAttempts: 0
    };
  }
  /**
   * Add to error history
   */
  addToErrorHistory(errorRecord) {
    this.errorState.errorHistory.push(errorRecord);
    if (this.errorState.errorHistory.length > this.errorConfig.maxErrorHistory) {
      this.errorState.errorHistory = this.errorState.errorHistory.slice(-this.errorConfig.maxErrorHistory);
    }
  }
  /**
   * Log error
   */
  logError(errorRecord) {
    const logLevel = this.getLogLevel(errorRecord.severity);
    const logMessage = this.formatErrorMessage(errorRecord);
    switch (logLevel) {
      case "error":
        this.logger.error(logMessage);
        break;
      case "warn":
        this.logger.warn(logMessage);
        break;
      case "info":
        this.logger.info(logMessage);
        break;
      default:
        this.logger.log(logMessage);
    }
  }
  /**
   * Get log level
   */
  getLogLevel(severity) {
    const levelMap = {
      [this.severityLevels.CRITICAL]: "error",
      [this.severityLevels.HIGH]: "error",
      [this.severityLevels.MEDIUM]: "warn",
      [this.severityLevels.LOW]: "info",
      [this.severityLevels.INFO]: "info"
    };
    return levelMap[severity] || "log";
  }
  /**
   * Format error message
   */
  formatErrorMessage(errorRecord) {
    return `[${errorRecord.type}] ${errorRecord.message} (${errorRecord.category})`;
  }
  /**
   * Attempt recovery
   */
  attemptRecovery(errorRecord) {
    if (!this.errorConfig.autoRecoveryEnabled) {
      return;
    }
    const strategy = this.errorState.recoveryStrategies.get(errorRecord.type);
    if (!strategy) {
      return;
    }
    if (errorRecord.recoveryAttempts >= strategy.maxRetries) {
      this.logger.warn(`Max recovery attempts reached for error ${errorRecord.id}`);
      return;
    }
    errorRecord.recoveryAttempts++;
    this.executeRecoverySteps(errorRecord, strategy);
  }
  /**
   * Execute recovery steps
   */
  executeRecoverySteps(errorRecord, strategy) {
    strategy.recoverySteps.forEach((step, index) => {
      setTimeout(() => {
        this.executeRecoveryStep(errorRecord, step);
      }, index * strategy.retryDelay);
    });
  }
  /**
   * Execute recovery step
   */
  executeRecoveryStep(errorRecord, step) {
    switch (step) {
      case "retry_request":
        this.retryRequest(errorRecord);
        break;
      case "check_connection":
        this.checkConnection(errorRecord);
        break;
      case "fallback_to_cached_data":
        this.fallbackToCachedData(errorRecord);
        break;
      case "clear_cache":
        this.clearCache(errorRecord);
        break;
      case "garbage_collect":
        this.garbageCollect(errorRecord);
        break;
      case "reduce_quality":
        this.reduceQuality(errorRecord);
        break;
      case "retry_render":
        this.retryRender(errorRecord);
        break;
      case "clear_render_cache":
        this.clearRenderCache(errorRecord);
        break;
      case "fallback_to_simple_renderer":
        this.fallbackToSimpleRenderer(errorRecord);
        break;
      case "validate_game_state":
        this.validateGameState(errorRecord);
        break;
      case "reset_to_last_save":
        this.resetToLastSave(errorRecord);
        break;
      case "notify_user":
        this.notifyUser(errorRecord);
        break;
    }
  }
  /**
   * Notify user
   */
  notifyUser(errorRecord) {
    if (!this.errorConfig.userNotificationEnabled) {
      return;
    }
    const notification = this.createUserNotification(errorRecord);
    this.errorState.userNotifications.set(notification.id, notification);
    this.eventBus.emit("error:userNotification", {
      notification,
      timestamp: Date.now()
    });
  }
  /**
   * Create user notification
   */
  createUserNotification(errorRecord) {
    return {
      id: `notification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: "error",
      severity: errorRecord.severity,
      title: this.getUserFriendlyTitle(errorRecord),
      message: this.getUserFriendlyMessage(errorRecord),
      timestamp: Date.now(),
      dismissed: false,
      actionRequired: this.isActionRequired(errorRecord)
    };
  }
  /**
   * Get user-friendly title
   */
  getUserFriendlyTitle(errorRecord) {
    const titleMap = {
      [this.errorTypes.VALIDATION_ERROR]: "Input Error",
      [this.errorTypes.NETWORK_ERROR]: "Connection Error",
      [this.errorTypes.RUNTIME_ERROR]: "Application Error",
      [this.errorTypes.PERFORMANCE_ERROR]: "Performance Issue",
      [this.errorTypes.USER_ERROR]: "User Error",
      [this.errorTypes.SYSTEM_ERROR]: "System Error",
      [this.errorTypes.UNKNOWN_ERROR]: "Unknown Error"
    };
    return titleMap[errorRecord.type] || "Error";
  }
  /**
   * Get user-friendly message
   */
  getUserFriendlyMessage(errorRecord) {
    const messageMap = {
      [this.errorTypes.VALIDATION_ERROR]: "Please check your input and try again.",
      [this.errorTypes.NETWORK_ERROR]: "Please check your internet connection and try again.",
      [this.errorTypes.RUNTIME_ERROR]: "An unexpected error occurred. Please refresh the page.",
      [this.errorTypes.PERFORMANCE_ERROR]: "The application is running slowly. Please try refreshing the page.",
      [this.errorTypes.USER_ERROR]: "Please check your input and try again.",
      [this.errorTypes.SYSTEM_ERROR]: "A system error occurred. Please try again later.",
      [this.errorTypes.UNKNOWN_ERROR]: "An unknown error occurred. Please try again."
    };
    return messageMap[errorRecord.type] || "An error occurred. Please try again.";
  }
  /**
   * Check if action is required
   */
  isActionRequired(errorRecord) {
    return errorRecord.severity === this.severityLevels.CRITICAL || errorRecord.severity === this.severityLevels.HIGH;
  }
  /**
   * Validate input
   */
  validateInput(input, ruleName, value) {
    const rule = this.errorState.validationRules.get(ruleName);
    if (!rule) {
      this.logger.warn(`Validation rule not found: ${ruleName}`);
      return { valid: true };
    }
    const result = this.performValidation(value, rule);
    if (result.valid) {
      this.eventBus.emit("validation:passed", {
        ruleName,
        value,
        timestamp: Date.now()
      });
    } else {
      this.eventBus.emit("validation:failed", {
        ruleName,
        value,
        errors: result.errors,
        timestamp: Date.now()
      });
    }
    return result;
  }
  /**
   * Perform validation
   */
  performValidation(value, rule) {
    const errors = [];
    if (rule.required && (value === null || value === void 0 || value === "")) {
      errors.push("This field is required");
      return { valid: false, errors };
    }
    if (rule.type && typeof value !== rule.type) {
      errors.push(`Expected ${rule.type}, got ${typeof value}`);
      return { valid: false, errors };
    }
    if (rule.minLength && value.length < rule.minLength) {
      errors.push(`Minimum length is ${rule.minLength}`);
    }
    if (rule.maxLength && value.length > rule.maxLength) {
      errors.push(`Maximum length is ${rule.maxLength}`);
    }
    if (rule.min !== void 0 && value < rule.min) {
      errors.push(`Minimum value is ${rule.min}`);
    }
    if (rule.max !== void 0 && value > rule.max) {
      errors.push(`Maximum value is ${rule.max}`);
    }
    if (rule.pattern && !rule.pattern.test(value)) {
      errors.push(rule.message || "Invalid format");
    }
    if (rule.properties && typeof value === "object") {
      for (const [prop, propRule] of Object.entries(rule.properties)) {
        const propResult = this.performValidation(value[prop], propRule);
        if (!propResult.valid) {
          errors.push(`${prop}: ${propResult.errors.join(", ")}`);
        }
      }
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : [rule.message || "Invalid value"]
    };
  }
  /**
   * Update performance metrics
   */
  updatePerformanceMetrics(deltaTime) {
    if (!this.errorConfig.performanceMonitoringEnabled) {
      return;
    }
    if (performance.memory) {
      this.performanceMetrics.memoryUsage = performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize;
    }
    this.performanceMetrics.frameRate = 1e3 / deltaTime;
    this.performanceMetrics.responseTime = deltaTime;
    this.performanceMetrics.errorRate = this.errorState.errorCount / (Date.now() - this.performanceMetrics.lastUpdate) * 1e3;
    this.performanceMetrics.lastUpdate = Date.now();
    this.performanceHistory.push({
      ...this.performanceMetrics,
      timestamp: Date.now()
    });
    if (this.performanceHistory.length > this.maxPerformanceHistory) {
      this.performanceHistory = this.performanceHistory.slice(-this.maxPerformanceHistory);
    }
    this.checkPerformanceThresholds();
  }
  /**
   * Check performance thresholds
   */
  checkPerformanceThresholds() {
    const thresholds = this.errorConfig.performanceThresholds;
    if (this.performanceMetrics.memoryUsage > thresholds.memoryUsage) {
      this.handlePerformanceThresholdExceeded("memory", this.performanceMetrics.memoryUsage);
    }
    if (this.performanceMetrics.cpuUsage > thresholds.cpuUsage) {
      this.handlePerformanceThresholdExceeded("cpu", this.performanceMetrics.cpuUsage);
    }
    if (this.performanceMetrics.frameRate < thresholds.frameRate) {
      this.handlePerformanceThresholdExceeded("frameRate", this.performanceMetrics.frameRate);
    }
    if (this.performanceMetrics.responseTime > thresholds.responseTime) {
      this.handlePerformanceThresholdExceeded("responseTime", this.performanceMetrics.responseTime);
    }
  }
  /**
   * Check error thresholds
   */
  checkErrorThresholds() {
    const thresholds = this.errorConfig.errorThresholds;
    if (this.errorState.errorCount > thresholds.critical) {
      this.handleThresholdExceeded("critical", this.errorState.errorCount);
    } else if (this.errorState.errorCount > thresholds.warning) {
      this.handleThresholdExceeded("warning", this.errorState.errorCount);
    } else if (this.errorState.errorCount > thresholds.info) {
      this.handleThresholdExceeded("info", this.errorState.errorCount);
    }
  }
  /**
   * Process error recovery
   */
  processErrorRecovery(deltaTime) {
    for (const [errorId, errorRecord] of this.errorState.errorHistory) {
      if (!errorRecord.resolved && errorRecord.recoveryAttempts > 0) {
        this.checkRecoveryStatus(errorRecord);
      }
    }
  }
  /**
   * Update user notifications
   */
  updateUserNotifications(deltaTime) {
    const now = Date.now();
    for (const [notificationId, notification] of this.errorState.userNotifications) {
      if (now - notification.timestamp > 3e4) {
        notification.dismissed = true;
      }
    }
  }
  /**
   * Start performance monitoring
   */
  startPerformanceMonitoring() {
    if (!this.errorConfig.performanceMonitoringEnabled) {
      return;
    }
    this.performanceTimer = setInterval(() => {
      this.updatePerformanceMetrics(16);
    }, 1e3);
  }
  /**
   * Stop performance monitoring
   */
  stopPerformanceMonitoring() {
    if (this.performanceTimer) {
      clearInterval(this.performanceTimer);
    }
  }
  /**
   * Handle error recovery
   */
  handleErrorRecovery(data) {
    const { errorId, success } = data;
    const errorRecord = this.errorState.errorHistory.find((e) => e.id === errorId);
    if (errorRecord) {
      errorRecord.resolved = success;
      errorRecord.recoveryCompletedAt = Date.now();
    }
  }
  /**
   * Handle threshold exceeded
   */
  handleThresholdExceeded(data) {
    const { threshold, value } = data;
    this.logger.warn(`Error threshold exceeded: ${threshold} (${value})`);
    this.eventBus.emit("error:threshold_exceeded", {
      threshold,
      value,
      timestamp: Date.now()
    });
  }
  /**
   * Handle validation failure
   */
  handleValidationFailure(data) {
    const { ruleName, value, errors } = data;
    this.logger.warn(`Validation failed for ${ruleName}: ${errors.join(", ")}`);
  }
  /**
   * Handle validation success
   */
  handleValidationSuccess(data) {
    const { ruleName, value } = data;
    this.logger.debug(`Validation passed for ${ruleName}`);
  }
  /**
   * Handle performance metric
   */
  handlePerformanceMetric(data) {
    const { metric, value } = data;
    this.performanceMetrics[metric] = value;
  }
  /**
   * Handle performance threshold exceeded
   */
  handlePerformanceThresholdExceeded(metric, value) {
    this.logger.warn(`Performance threshold exceeded: ${metric} (${value})`);
    this.eventBus.emit("performance:threshold_exceeded", {
      metric,
      value,
      timestamp: Date.now()
    });
  }
  /**
   * Handle recovery started
   */
  handleRecoveryStarted(data) {
    const { errorId, strategy } = data;
    this.logger.info(`Recovery started for error ${errorId} using strategy ${strategy}`);
  }
  /**
   * Handle recovery completed
   */
  handleRecoveryCompleted(data) {
    const { errorId, success } = data;
    this.logger.info(`Recovery completed for error ${errorId}: ${success ? "success" : "failed"}`);
  }
  /**
   * Handle recovery failed
   */
  handleRecoveryFailed(data) {
    const { errorId, reason } = data;
    this.logger.error(`Recovery failed for error ${errorId}: ${reason}`);
  }
  /**
   * Load error data
   */
  async loadErrorData() {
    try {
      const savedData = localStorage.getItem("errorData");
      if (savedData) {
        const data = JSON.parse(savedData);
        this.errorState.errorCount = data.errorCount || 0;
        this.errorState.errorHistory = data.errorHistory || [];
        this.logger.info("Error data loaded from storage");
      }
    } catch (error) {
      this.logger.error("Failed to load error data:", error);
    }
  }
  /**
   * Save error data
   */
  saveErrorData() {
    try {
      const data = {
        errorCount: this.errorState.errorCount,
        errorHistory: this.errorState.errorHistory.slice(-100),
        // Keep only recent errors
        timestamp: Date.now()
      };
      localStorage.setItem("errorData", JSON.stringify(data));
      this.logger.info("Error data saved to storage");
    } catch (error) {
      this.logger.error("Failed to save error data:", error);
    }
  }
  /**
   * Get error statistics
   */
  getErrorStatistics() {
    const stats = {
      totalErrors: this.errorState.errorCount,
      errorsByType: {},
      errorsBySeverity: {},
      errorsByCategory: {},
      recentErrors: this.errorState.errorHistory.slice(-10),
      performanceMetrics: this.performanceMetrics
    };
    this.errorState.errorHistory.forEach((error) => {
      stats.errorsByType[error.type] = (stats.errorsByType[error.type] || 0) + 1;
      stats.errorsBySeverity[error.severity] = (stats.errorsBySeverity[error.severity] || 0) + 1;
      stats.errorsByCategory[error.category] = (stats.errorsByCategory[error.category] || 0) + 1;
    });
    return stats;
  }
  /**
   * Get performance metrics
   */
  getPerformanceMetrics() {
    return {
      current: this.performanceMetrics,
      history: this.performanceHistory,
      thresholds: this.errorConfig.performanceThresholds
    };
  }
  /**
   * Get user notifications
   */
  getUserNotifications() {
    return Array.from(this.errorState.userNotifications.values()).filter((notification) => !notification.dismissed);
  }
  /**
   * Dismiss notification
   */
  dismissNotification(notificationId) {
    const notification = this.errorState.userNotifications.get(notificationId);
    if (notification) {
      notification.dismissed = true;
    }
  }
  /**
   * Clear error history
   */
  clearErrorHistory() {
    this.errorState.errorHistory = [];
    this.errorState.errorCount = 0;
    this.logger.info("Error history cleared");
  }
  /**
   * Reset performance metrics
   */
  resetPerformanceMetrics() {
    this.performanceMetrics = {
      memoryUsage: 0,
      cpuUsage: 0,
      frameRate: 0,
      responseTime: 0,
      errorRate: 0,
      lastUpdate: Date.now()
    };
    this.performanceHistory = [];
    this.logger.info("Performance metrics reset");
  }
};

// src/systems/MobileOptimizationSystem.js
var MobileOptimizationSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("MobileOptimizationSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("MobileOptimizationSystem requires logger dependency");
    }
    this.mobileState = {
      isMobile: false,
      deviceType: "desktop",
      screenSize: { width: 0, height: 0 },
      orientation: "portrait",
      touchCapable: false,
      performanceLevel: "high",
      batteryLevel: 1,
      networkType: "unknown",
      touchControls: /* @__PURE__ */ new Map(),
      gestureRecognizers: /* @__PURE__ */ new Map(),
      responsiveBreakpoints: /* @__PURE__ */ new Map(),
      mobileFeatures: /* @__PURE__ */ new Map()
    };
    this.mobileConfig = {
      touchSensitivity: 1,
      gestureThreshold: 10,
      doubleTapDelay: 300,
      longPressDelay: 500,
      swipeThreshold: 50,
      pinchThreshold: 0.1,
      rotationThreshold: 15,
      responsiveBreakpoints: {
        mobile: 768,
        tablet: 1024,
        desktop: 1200
      },
      performanceLevels: {
        low: { maxFPS: 30, quality: 0.5, effects: false },
        medium: { maxFPS: 45, quality: 0.7, effects: true },
        high: { maxFPS: 60, quality: 1, effects: true }
      },
      touchZones: {
        left: { x: 0, y: 0, width: 0.3, height: 1 },
        right: { x: 0.7, y: 0, width: 0.3, height: 1 },
        center: { x: 0.3, y: 0, width: 0.4, height: 1 }
      }
    };
    this.initializeMobileDetection();
    this.initializeTouchControls();
    this.initializeGestureRecognition();
    this.initializeResponsiveDesign();
    this.initializeMobileFeatures();
    this.setupEventHandlers();
    this.logger.info("MobileOptimizationSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing MobileOptimizationSystem...");
    this.detectMobileDevice();
    this.setupResponsiveDesign();
    this.setupTouchControls();
    this.setupMobileFeatures();
    this.logger.info("MobileOptimizationSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up MobileOptimizationSystem...");
    this.removeTouchEventListeners();
    this.removeResponsiveDesignListeners();
    this.mobileState.touchControls.clear();
    this.mobileState.gestureRecognizers.clear();
    this.mobileState.responsiveBreakpoints.clear();
    this.mobileState.mobileFeatures.clear();
    this.removeEventHandlers();
    this.logger.info("MobileOptimizationSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updateTouchControls(deltaTime);
    this.updateGestureRecognition(deltaTime);
    this.updateResponsiveDesign(deltaTime);
    this.updateMobileFeatures(deltaTime);
  }
  /**
   * Initialize mobile detection
   */
  initializeMobileDetection() {
    this.mobileDetector = {
      userAgent: navigator.userAgent,
      touchCapable: "ontouchstart" in window || navigator.maxTouchPoints > 0,
      screenSize: { width: window.innerWidth, height: window.innerHeight },
      orientation: window.innerHeight > window.innerWidth ? "portrait" : "landscape"
    };
  }
  /**
   * Initialize touch controls
   */
  initializeTouchControls() {
    this.touchControls = {
      virtualJoystick: {
        active: false,
        position: { x: 0, y: 0 },
        radius: 50,
        deadZone: 10,
        sensitivity: 1
      },
      virtualButtons: /* @__PURE__ */ new Map(),
      touchZones: /* @__PURE__ */ new Map(),
      touchHistory: [],
      maxTouchHistory: 10
    };
  }
  /**
   * Initialize gesture recognition
   */
  initializeGestureRecognition() {
    this.gestureRecognizers = {
      tap: {
        enabled: true,
        threshold: 10,
        maxDuration: 300
      },
      doubleTap: {
        enabled: true,
        threshold: 10,
        maxDuration: 300,
        maxDelay: 500
      },
      longPress: {
        enabled: true,
        threshold: 10,
        minDuration: 500
      },
      swipe: {
        enabled: true,
        threshold: 50,
        minVelocity: 0.3
      },
      pinch: {
        enabled: true,
        threshold: 0.1
      },
      rotation: {
        enabled: true,
        threshold: 15
      }
    };
  }
  /**
   * Initialize responsive design
   */
  initializeResponsiveDesign() {
    this.responsiveDesign = {
      currentBreakpoint: "desktop",
      breakpoints: this.mobileConfig.responsiveBreakpoints,
      mediaQueries: /* @__PURE__ */ new Map(),
      responsiveElements: /* @__PURE__ */ new Map(),
      layoutMode: "desktop"
    };
  }
  /**
   * Initialize mobile features
   */
  initializeMobileFeatures() {
    this.mobileFeatures = {
      hapticFeedback: "vibrate" in navigator,
      deviceOrientation: "DeviceOrientationEvent" in window,
      deviceMotion: "DeviceMotionEvent" in window,
      fullscreen: "requestFullscreen" in document.documentElement,
      webAppManifest: "serviceWorker" in navigator,
      pushNotifications: "PushManager" in window,
      geolocation: "geolocation" in navigator,
      camera: "getUserMedia" in navigator.mediaDevices
    };
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("touch:start", this.handleTouchStart.bind(this));
    this.eventBus.on("touch:move", this.handleTouchMove.bind(this));
    this.eventBus.on("touch:end", this.handleTouchEnd.bind(this));
    this.eventBus.on("touch:cancel", this.handleTouchCancel.bind(this));
    this.eventBus.on("gesture:tap", this.handleTap.bind(this));
    this.eventBus.on("gesture:doubleTap", this.handleDoubleTap.bind(this));
    this.eventBus.on("gesture:longPress", this.handleLongPress.bind(this));
    this.eventBus.on("gesture:swipe", this.handleSwipe.bind(this));
    this.eventBus.on("gesture:pinch", this.handlePinch.bind(this));
    this.eventBus.on("gesture:rotation", this.handleRotation.bind(this));
    this.eventBus.on("mobile:orientationChange", this.handleOrientationChange.bind(this));
    this.eventBus.on("mobile:resize", this.handleResize.bind(this));
    this.eventBus.on("mobile:visibilityChange", this.handleVisibilityChange.bind(this));
    this.eventBus.on("mobile:batteryChange", this.handleBatteryChange.bind(this));
    this.eventBus.on("performance:levelChange", this.handlePerformanceLevelChange.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("touch:start", this.handleTouchStart.bind(this));
    this.eventBus.removeListener("touch:move", this.handleTouchMove.bind(this));
    this.eventBus.removeListener("touch:end", this.handleTouchEnd.bind(this));
    this.eventBus.removeListener("touch:cancel", this.handleTouchCancel.bind(this));
    this.eventBus.removeListener("gesture:tap", this.handleTap.bind(this));
    this.eventBus.removeListener("gesture:doubleTap", this.handleDoubleTap.bind(this));
    this.eventBus.removeListener("gesture:longPress", this.handleLongPress.bind(this));
    this.eventBus.removeListener("gesture:swipe", this.handleSwipe.bind(this));
    this.eventBus.removeListener("gesture:pinch", this.handlePinch.bind(this));
    this.eventBus.removeListener("gesture:rotation", this.handleRotation.bind(this));
    this.eventBus.removeListener("mobile:orientationChange", this.handleOrientationChange.bind(this));
    this.eventBus.removeListener("mobile:resize", this.handleResize.bind(this));
    this.eventBus.removeListener("mobile:visibilityChange", this.handleVisibilityChange.bind(this));
    this.eventBus.removeListener("mobile:batteryChange", this.handleBatteryChange.bind(this));
    this.eventBus.removeListener("performance:levelChange", this.handlePerformanceLevelChange.bind(this));
  }
  /**
   * Detect mobile device
   */
  detectMobileDevice() {
    const userAgent = navigator.userAgent;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    const isTablet = /iPad|Android/i.test(userAgent) && "ontouchstart" in window;
    this.mobileState.isMobile = isMobile;
    this.mobileState.touchCapable = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    this.mobileState.deviceType = isTablet ? "tablet" : isMobile ? "mobile" : "desktop";
    this.mobileState.screenSize = { width: window.innerWidth, height: window.innerHeight };
    this.mobileState.orientation = window.innerHeight > window.innerWidth ? "portrait" : "landscape";
    this.detectPerformanceLevel();
    this.logger.info(`Mobile device detected: ${this.mobileState.deviceType}`);
  }
  /**
   * Detect performance level
   */
  detectPerformanceLevel() {
    const screenSize = this.mobileState.screenSize;
    const isLowEnd = screenSize.width < 768 || screenSize.height < 768;
    const isHighEnd = screenSize.width >= 1200 && screenSize.height >= 800;
    if (isLowEnd) {
      this.mobileState.performanceLevel = "low";
    } else if (isHighEnd) {
      this.mobileState.performanceLevel = "high";
    } else {
      this.mobileState.performanceLevel = "medium";
    }
    this.logger.info(`Performance level detected: ${this.mobileState.performanceLevel}`);
  }
  /**
   * Set up responsive design
   */
  setupResponsiveDesign() {
    this.setupMediaQueries();
    this.setupResponsiveElements();
    this.setupLayoutMode();
    window.addEventListener("resize", this.handleResize.bind(this));
    window.addEventListener("orientationchange", this.handleOrientationChange.bind(this));
  }
  /**
   * Set up media queries
   */
  setupMediaQueries() {
    const breakpoints = this.mobileConfig.responsiveBreakpoints;
    Object.entries(breakpoints).forEach(([name, width]) => {
      const mediaQuery = window.matchMedia(`(max-width: ${width}px)`);
      this.responsiveDesign.mediaQueries.set(name, mediaQuery);
      mediaQuery.addListener((e) => {
        if (e.matches) {
          this.handleBreakpointChange(name);
        }
      });
    });
  }
  /**
   * Set up responsive elements
   */
  setupResponsiveElements() {
    const responsiveElements = document.querySelectorAll("[data-responsive]");
    responsiveElements.forEach((element) => {
      const breakpoints = element.dataset.responsive.split(",");
      this.responsiveDesign.responsiveElements.set(element, breakpoints);
    });
  }
  /**
   * Set up layout mode
   */
  setupLayoutMode() {
    const currentBreakpoint = this.getCurrentBreakpoint();
    this.responsiveDesign.currentBreakpoint = currentBreakpoint;
    this.responsiveDesign.layoutMode = this.getLayoutMode(currentBreakpoint);
    this.applyLayoutMode(this.responsiveDesign.layoutMode);
  }
  /**
   * Get current breakpoint
   */
  getCurrentBreakpoint() {
    const width = window.innerWidth;
    const breakpoints = this.mobileConfig.responsiveBreakpoints;
    if (width < breakpoints.mobile) {
      return "mobile";
    } else if (width < breakpoints.tablet) {
      return "tablet";
    } else {
      return "desktop";
    }
  }
  /**
   * Get layout mode
   */
  getLayoutMode(breakpoint) {
    const layoutModes = {
      mobile: "mobile",
      tablet: "tablet",
      desktop: "desktop"
    };
    return layoutModes[breakpoint] || "desktop";
  }
  /**
   * Apply layout mode
   */
  applyLayoutMode(layoutMode) {
    document.body.className = document.body.className.replace(/layout-\w+/g, "");
    document.body.classList.add(`layout-${layoutMode}`);
    this.eventBus.emit("mobile:layoutModeChanged", {
      layoutMode,
      timestamp: Date.now()
    });
  }
  /**
   * Set up touch controls
   */
  setupTouchControls() {
    if (!this.mobileState.touchCapable) {
      return;
    }
    document.addEventListener("touchstart", this.handleTouchStart.bind(this), { passive: false });
    document.addEventListener("touchmove", this.handleTouchMove.bind(this), { passive: false });
    document.addEventListener("touchend", this.handleTouchEnd.bind(this), { passive: false });
    document.addEventListener("touchcancel", this.handleTouchCancel.bind(this), { passive: false });
    this.setupVirtualJoystick();
    this.setupVirtualButtons();
    this.setupTouchZones();
  }
  /**
   * Set up virtual joystick
   */
  setupVirtualJoystick() {
    const joystick = document.createElement("div");
    joystick.id = "virtual-joystick";
    joystick.className = "virtual-joystick";
    joystick.style.cssText = `
      position: fixed;
      left: 50px;
      bottom: 50px;
      width: 100px;
      height: 100px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: ${this.mobileState.isMobile ? "block" : "none"};
    `;
    const knob = document.createElement("div");
    knob.className = "joystick-knob";
    knob.style.cssText = `
      position: absolute;
      top: 50%;
      left: 50%;
      width: 30px;
      height: 30px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.1s ease;
    `;
    joystick.appendChild(knob);
    document.body.appendChild(joystick);
    this.touchControls.virtualJoystick.element = joystick;
    this.touchControls.virtualJoystick.knob = knob;
  }
  /**
   * Set up virtual buttons
   */
  setupVirtualButtons() {
    const buttonConfigs = [
      { id: "jump", label: "Jump", position: { right: "50px", bottom: "50px" } },
      { id: "attack", label: "Attack", position: { right: "50px", bottom: "120px" } },
      { id: "interact", label: "Interact", position: { right: "50px", bottom: "190px" } },
      { id: "menu", label: "Menu", position: { right: "50px", top: "50px" } }
    ];
    buttonConfigs.forEach((config) => {
      const button = document.createElement("button");
      button.id = `virtual-button-${config.id}`;
      button.className = "virtual-button";
      button.textContent = config.label;
      button.style.cssText = `
        position: fixed;
        ${config.position.right ? `right: ${config.position.right};` : ""}
        ${config.position.left ? `left: ${config.position.left};` : ""}
        ${config.position.top ? `top: ${config.position.top};` : ""}
        ${config.position.bottom ? `bottom: ${config.position.bottom};` : ""}
        width: 60px;
        height: 60px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        font-size: 12px;
        z-index: 1000;
        display: ${this.mobileState.isMobile ? "block" : "none"};
        touch-action: manipulation;
      `;
      button.addEventListener("touchstart", (e) => {
        e.preventDefault();
        this.handleVirtualButtonPress(config.id);
      });
      button.addEventListener("touchend", (e) => {
        e.preventDefault();
        this.handleVirtualButtonRelease(config.id);
      });
      document.body.appendChild(button);
      this.touchControls.virtualButtons.set(config.id, button);
    });
  }
  /**
   * Set up touch zones
   */
  setupTouchZones() {
    const zones = this.mobileConfig.touchZones;
    Object.entries(zones).forEach(([name, zone]) => {
      const element = document.createElement("div");
      element.className = `touch-zone touch-zone-${name}`;
      element.style.cssText = `
        position: fixed;
        left: ${zone.x * 100}%;
        top: ${zone.y * 100}%;
        width: ${zone.width * 100}%;
        height: ${zone.height * 100}%;
        z-index: 999;
        display: ${this.mobileState.isMobile ? "block" : "none"};
        pointer-events: auto;
      `;
      element.addEventListener("touchstart", (e) => {
        this.handleTouchZoneStart(name, e);
      });
      element.addEventListener("touchmove", (e) => {
        this.handleTouchZoneMove(name, e);
      });
      element.addEventListener("touchend", (e) => {
        this.handleTouchZoneEnd(name, e);
      });
      document.body.appendChild(element);
      this.touchControls.touchZones.set(name, element);
    });
  }
  /**
   * Set up mobile features
   */
  setupMobileFeatures() {
    if (this.mobileFeatures.hapticFeedback) {
      this.setupHapticFeedback();
    }
    if (this.mobileFeatures.deviceOrientation) {
      this.setupDeviceOrientation();
    }
    if (this.mobileFeatures.deviceMotion) {
      this.setupDeviceMotion();
    }
    if (this.mobileFeatures.fullscreen) {
      this.setupFullscreen();
    }
    if (this.mobileFeatures.pushNotifications) {
      this.setupPushNotifications();
    }
    if (this.mobileFeatures.geolocation) {
      this.setupGeolocation();
    }
  }
  /**
   * Set up haptic feedback
   */
  setupHapticFeedback() {
    this.hapticFeedback = {
      light: () => navigator.vibrate(10),
      medium: () => navigator.vibrate(50),
      heavy: () => navigator.vibrate(100),
      pattern: (pattern) => navigator.vibrate(pattern)
    };
  }
  /**
   * Set up device orientation
   */
  setupDeviceOrientation() {
    window.addEventListener("deviceorientation", (event) => {
      this.handleDeviceOrientation(event);
    });
  }
  /**
   * Set up device motion
   */
  setupDeviceMotion() {
    window.addEventListener("devicemotion", (event) => {
      this.handleDeviceMotion(event);
    });
  }
  /**
   * Set up fullscreen
   */
  setupFullscreen() {
    this.fullscreen = {
      enter: () => {
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        }
      },
      exit: () => {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        }
      },
      toggle: () => {
        if (document.fullscreenElement) {
          this.fullscreen.exit();
        } else {
          this.fullscreen.enter();
        }
      }
    };
  }
  /**
   * Set up push notifications
   */
  setupPushNotifications() {
    this.pushNotifications = {
      requestPermission: async () => {
        if ("Notification" in window) {
          const permission = await Notification.requestPermission();
          return permission === "granted";
        }
        return false;
      },
      show: (title, options) => {
        if (Notification.permission === "granted") {
          new Notification(title, options);
        }
      }
    };
  }
  /**
   * Set up geolocation
   */
  setupGeolocation() {
    this.geolocation = {
      getCurrentPosition: () => {
        return new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject);
        });
      },
      watchPosition: (callback) => {
        return navigator.geolocation.watchPosition(callback);
      },
      clearWatch: (id) => {
        navigator.geolocation.clearWatch(id);
      }
    };
  }
  /**
   * Handle touch start
   */
  handleTouchStart(event) {
    event.preventDefault();
    const touches = Array.from(event.touches);
    const touch = touches[0];
    if (touch) {
      this.touchControls.touchHistory.push({
        type: "start",
        x: touch.clientX,
        y: touch.clientY,
        timestamp: Date.now()
      });
      if (this.touchControls.touchHistory.length > this.touchControls.maxTouchHistory) {
        this.touchControls.touchHistory.shift();
      }
      if (this.isPointInJoystick(touch.clientX, touch.clientY)) {
        this.touchControls.virtualJoystick.active = true;
        this.touchControls.virtualJoystick.startPosition = { x: touch.clientX, y: touch.clientY };
      }
      this.eventBus.emit("touch:start", {
        touch,
        touches,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Handle touch move
   */
  handleTouchMove(event) {
    event.preventDefault();
    const touches = Array.from(event.touches);
    const touch = touches[0];
    if (touch) {
      this.touchControls.touchHistory.push({
        type: "move",
        x: touch.clientX,
        y: touch.clientY,
        timestamp: Date.now()
      });
      if (this.touchControls.virtualJoystick.active) {
        this.updateVirtualJoystick(touch.clientX, touch.clientY);
      }
      this.eventBus.emit("touch:move", {
        touch,
        touches,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Handle touch end
   */
  handleTouchEnd(event) {
    event.preventDefault();
    const touches = Array.from(event.touches);
    const changedTouches = Array.from(event.changedTouches);
    const touch = changedTouches[0];
    if (touch) {
      this.touchControls.touchHistory.push({
        type: "end",
        x: touch.clientX,
        y: touch.clientY,
        timestamp: Date.now()
      });
      if (this.touchControls.virtualJoystick.active) {
        this.resetVirtualJoystick();
      }
      this.recognizeGestures();
      this.eventBus.emit("touch:end", {
        touch,
        touches,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Handle touch cancel
   */
  handleTouchCancel(event) {
    event.preventDefault();
    if (this.touchControls.virtualJoystick.active) {
      this.resetVirtualJoystick();
    }
    this.eventBus.emit("touch:cancel", {
      timestamp: Date.now()
    });
  }
  /**
   * Handle tap
   */
  handleTap(data) {
    this.logger.info("Tap gesture recognized");
    if (this.hapticFeedback) {
      this.hapticFeedback.light();
    }
    this.eventBus.emit("gesture:tap", data);
  }
  /**
   * Handle double tap
   */
  handleDoubleTap(data) {
    this.logger.info("Double tap gesture recognized");
    if (this.hapticFeedback) {
      this.hapticFeedback.medium();
    }
    this.eventBus.emit("gesture:doubleTap", data);
  }
  /**
   * Handle long press
   */
  handleLongPress(data) {
    this.logger.info("Long press gesture recognized");
    if (this.hapticFeedback) {
      this.hapticFeedback.heavy();
    }
    this.eventBus.emit("gesture:longPress", data);
  }
  /**
   * Handle swipe
   */
  handleSwipe(data) {
    this.logger.info(`Swipe gesture recognized: ${data.direction}`);
    if (this.hapticFeedback) {
      this.hapticFeedback.medium();
    }
    this.eventBus.emit("gesture:swipe", data);
  }
  /**
   * Handle pinch
   */
  handlePinch(data) {
    this.logger.info(`Pinch gesture recognized: ${data.scale}`);
    this.eventBus.emit("gesture:pinch", data);
  }
  /**
   * Handle rotation
   */
  handleRotation(data) {
    this.logger.info(`Rotation gesture recognized: ${data.rotation}`);
    this.eventBus.emit("gesture:rotation", data);
  }
  /**
   * Handle orientation change
   */
  handleOrientationChange(event) {
    const newOrientation = window.innerHeight > window.innerWidth ? "portrait" : "landscape";
    if (newOrientation !== this.mobileState.orientation) {
      this.mobileState.orientation = newOrientation;
      this.eventBus.emit("mobile:orientationChange", {
        orientation: newOrientation,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Handle resize
   */
  handleResize(event) {
    const newScreenSize = { width: window.innerWidth, height: window.innerHeight };
    if (newScreenSize.width !== this.mobileState.screenSize.width || newScreenSize.height !== this.mobileState.screenSize.height) {
      this.mobileState.screenSize = newScreenSize;
      this.updateResponsiveDesign();
      this.eventBus.emit("mobile:resize", {
        screenSize: newScreenSize,
        timestamp: Date.now()
      });
    }
  }
  /**
   * Handle visibility change
   */
  handleVisibilityChange(event) {
    const isVisible = !document.hidden;
    this.eventBus.emit("mobile:visibilityChange", {
      visible: isVisible,
      timestamp: Date.now()
    });
  }
  /**
   * Handle battery change
   */
  handleBatteryChange(event) {
    const batteryLevel = event.level;
    this.mobileState.batteryLevel = batteryLevel;
    if (batteryLevel < 0.2) {
      this.setPerformanceLevel("low");
    } else if (batteryLevel < 0.5) {
      this.setPerformanceLevel("medium");
    } else {
      this.setPerformanceLevel("high");
    }
    this.eventBus.emit("mobile:batteryChange", {
      batteryLevel,
      timestamp: Date.now()
    });
  }
  /**
   * Handle performance level change
   */
  handlePerformanceLevelChange(data) {
    const { level } = data;
    this.mobileState.performanceLevel = level;
    this.applyPerformanceSettings(level);
    this.logger.info(`Performance level changed to: ${level}`);
  }
  /**
   * Update touch controls
   */
  updateTouchControls(deltaTime) {
    if (this.touchControls.virtualJoystick.active) {
      this.updateVirtualJoystickPosition(deltaTime);
    }
  }
  /**
   * Update gesture recognition
   */
  updateGestureRecognition(deltaTime) {
    this.processTouchHistory();
  }
  /**
   * Update responsive design
   */
  updateResponsiveDesign(deltaTime) {
    const currentBreakpoint = this.getCurrentBreakpoint();
    if (currentBreakpoint !== this.responsiveDesign.currentBreakpoint) {
      this.handleBreakpointChange(currentBreakpoint);
    }
  }
  /**
   * Update mobile features
   */
  updateMobileFeatures(deltaTime) {
  }
  /**
   * Check if point is in joystick
   */
  isPointInJoystick(x, y) {
    const joystick = this.touchControls.virtualJoystick.element;
    if (!joystick) return false;
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
    return distance <= rect.width / 2;
  }
  /**
   * Update virtual joystick
   */
  updateVirtualJoystick(x, y) {
    const joystick = this.touchControls.virtualJoystick.element;
    const knob = this.touchControls.virtualJoystick.knob;
    if (!joystick || !knob) return;
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    const deltaX = x - centerX;
    const deltaY = y - centerY;
    const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2);
    const maxDistance = rect.width / 2 - 15;
    if (distance > maxDistance) {
      const angle = Math.atan2(deltaY, deltaX);
      const newX = Math.cos(angle) * maxDistance;
      const newY = Math.sin(angle) * maxDistance;
      knob.style.transform = `translate(${newX - 15}px, ${newY - 15}px)`;
      this.touchControls.virtualJoystick.position = {
        x: newX / maxDistance,
        y: newY / maxDistance
      };
    } else {
      knob.style.transform = `translate(${deltaX - 15}px, ${deltaY - 15}px)`;
      this.touchControls.virtualJoystick.position = {
        x: deltaX / maxDistance,
        y: deltaY / maxDistance
      };
    }
    this.eventBus.emit("input:joystick", {
      position: this.touchControls.virtualJoystick.position,
      timestamp: Date.now()
    });
  }
  /**
   * Reset virtual joystick
   */
  resetVirtualJoystick() {
    const knob = this.touchControls.virtualJoystick.knob;
    if (knob) {
      knob.style.transform = "translate(-50%, -50%)";
    }
    this.touchControls.virtualJoystick.active = false;
    this.touchControls.virtualJoystick.position = { x: 0, y: 0 };
  }
  /**
   * Handle virtual button press
   */
  handleVirtualButtonPress(buttonId) {
    this.eventBus.emit("input:buttonPress", {
      button: buttonId,
      timestamp: Date.now()
    });
  }
  /**
   * Handle virtual button release
   */
  handleVirtualButtonRelease(buttonId) {
    this.eventBus.emit("input:buttonRelease", {
      button: buttonId,
      timestamp: Date.now()
    });
  }
  /**
   * Handle touch zone start
   */
  handleTouchZoneStart(zoneName, event) {
    this.eventBus.emit("input:zoneStart", {
      zone: zoneName,
      touch: event.touches[0],
      timestamp: Date.now()
    });
  }
  /**
   * Handle touch zone move
   */
  handleTouchZoneMove(zoneName, event) {
    this.eventBus.emit("input:zoneMove", {
      zone: zoneName,
      touch: event.touches[0],
      timestamp: Date.now()
    });
  }
  /**
   * Handle touch zone end
   */
  handleTouchZoneEnd(zoneName, event) {
    this.eventBus.emit("input:zoneEnd", {
      zone: zoneName,
      touch: event.changedTouches[0],
      timestamp: Date.now()
    });
  }
  /**
   * Recognize gestures
   */
  recognizeGestures() {
    const history = this.touchControls.touchHistory;
    if (history.length < 2) return;
    const lastTouch = history[history.length - 1];
    const firstTouch = history[0];
    if (this.isTap(history)) {
      this.handleTap({ touch: lastTouch });
    }
    if (this.isDoubleTap(history)) {
      this.handleDoubleTap({ touch: lastTouch });
    }
    if (this.isLongPress(history)) {
      this.handleLongPress({ touch: lastTouch });
    }
    if (this.isSwipe(history)) {
      const direction = this.getSwipeDirection(history);
      this.handleSwipe({ touch: lastTouch, direction });
    }
  }
  /**
   * Check if gesture is tap
   */
  isTap(history) {
    const lastTouch = history[history.length - 1];
    const firstTouch = history[0];
    if (lastTouch.type !== "end") return false;
    const duration = lastTouch.timestamp - firstTouch.timestamp;
    const distance = Math.sqrt(
      (lastTouch.x - firstTouch.x) ** 2 + (lastTouch.y - firstTouch.y) ** 2
    );
    return duration < this.gestureRecognizers.tap.maxDuration && distance < this.gestureRecognizers.tap.threshold;
  }
  /**
   * Check if gesture is double tap
   */
  isDoubleTap(history) {
    return false;
  }
  /**
   * Check if gesture is long press
   */
  isLongPress(history) {
    const lastTouch = history[history.length - 1];
    const firstTouch = history[0];
    const duration = lastTouch.timestamp - firstTouch.timestamp;
    return duration >= this.gestureRecognizers.longPress.minDuration;
  }
  /**
   * Check if gesture is swipe
   */
  isSwipe(history) {
    const lastTouch = history[history.length - 1];
    const firstTouch = history[0];
    if (lastTouch.type !== "end") return false;
    const distance = Math.sqrt(
      (lastTouch.x - firstTouch.x) ** 2 + (lastTouch.y - firstTouch.y) ** 2
    );
    return distance >= this.gestureRecognizers.swipe.threshold;
  }
  /**
   * Get swipe direction
   */
  getSwipeDirection(history) {
    const lastTouch = history[history.length - 1];
    const firstTouch = history[0];
    const deltaX = lastTouch.x - firstTouch.x;
    const deltaY = lastTouch.y - firstTouch.y;
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      return deltaX > 0 ? "right" : "left";
    } else {
      return deltaY > 0 ? "down" : "up";
    }
  }
  /**
   * Handle breakpoint change
   */
  handleBreakpointChange(breakpoint) {
    this.responsiveDesign.currentBreakpoint = breakpoint;
    this.responsiveDesign.layoutMode = this.getLayoutMode(breakpoint);
    this.applyLayoutMode(this.responsiveDesign.layoutMode);
    this.logger.info(`Breakpoint changed to: ${breakpoint}`);
  }
  /**
   * Set performance level
   */
  setPerformanceLevel(level) {
    this.mobileState.performanceLevel = level;
    this.applyPerformanceSettings(level);
    this.eventBus.emit("performance:levelChange", {
      level,
      timestamp: Date.now()
    });
  }
  /**
   * Apply performance settings
   */
  applyPerformanceSettings(level) {
    const settings = this.mobileConfig.performanceLevels[level];
    if (settings) {
      this.logger.info(`Applied performance settings for level: ${level}`);
    }
  }
  /**
   * Remove touch event listeners
   */
  removeTouchEventListeners() {
    document.removeEventListener("touchstart", this.handleTouchStart);
    document.removeEventListener("touchmove", this.handleTouchMove);
    document.removeEventListener("touchend", this.handleTouchEnd);
    document.removeEventListener("touchcancel", this.handleTouchCancel);
  }
  /**
   * Remove responsive design listeners
   */
  removeResponsiveDesignListeners() {
    window.removeEventListener("resize", this.handleResize);
    window.removeEventListener("orientationchange", this.handleOrientationChange);
  }
  /**
   * Get mobile state
   */
  getMobileState() {
    return { ...this.mobileState };
  }
  /**
   * Get touch controls
   */
  getTouchControls() {
    return { ...this.touchControls };
  }
  /**
   * Get responsive design
   */
  getResponsiveDesign() {
    return { ...this.responsiveDesign };
  }
  /**
   * Get mobile features
   */
  getMobileFeatures() {
    return { ...this.mobileFeatures };
  }
  /**
   * Enable mobile mode
   */
  enableMobileMode() {
    this.mobileState.isMobile = true;
    this.setupTouchControls();
    this.setupMobileFeatures();
  }
  /**
   * Disable mobile mode
   */
  disableMobileMode() {
    this.mobileState.isMobile = false;
    this.removeTouchEventListeners();
  }
};

// src/systems/PerformanceOptimizationSystem.js
var PerformanceOptimizationSystem = class {
  constructor(dependencies = {}) {
    this.eventBus = dependencies.eventBus;
    this.logger = dependencies.logger;
    this.config = dependencies.config;
    if (!this.eventBus) {
      throw new Error("PerformanceOptimizationSystem requires eventBus dependency");
    }
    if (!this.logger) {
      throw new Error("PerformanceOptimizationSystem requires logger dependency");
    }
    this.performanceState = {
      frameRate: 0,
      frameTime: 0,
      memoryUsage: 0,
      cpuUsage: 0,
      renderTime: 0,
      updateTime: 0,
      assetLoadTime: 0,
      networkLatency: 0,
      performanceLevel: "high",
      optimizationEnabled: true,
      monitoringEnabled: true,
      profilingEnabled: false,
      metrics: /* @__PURE__ */ new Map(),
      thresholds: /* @__PURE__ */ new Map(),
      optimizations: /* @__PURE__ */ new Map(),
      resourcePools: /* @__PURE__ */ new Map(),
      assetCache: /* @__PURE__ */ new Map(),
      renderQueue: [],
      updateQueue: []
    };
    this.performanceConfig = {
      targetFrameRate: 60,
      maxFrameTime: 16.67,
      // 60 FPS
      memoryThreshold: 0.8,
      // 80% of available memory
      cpuThreshold: 0.7,
      // 70% CPU usage
      renderThreshold: 8,
      // 8ms render time
      updateThreshold: 8,
      // 8ms update time
      assetCacheSize: 100,
      // 100 assets in cache
      resourcePoolSize: 50,
      // 50 objects per pool
      optimizationLevels: {
        low: { maxFPS: 30, quality: 0.5, effects: false, shadows: false },
        medium: { maxFPS: 45, quality: 0.7, effects: true, shadows: false },
        high: { maxFPS: 60, quality: 1, effects: true, shadows: true }
      },
      monitoringInterval: 1e3,
      // 1 second
      profilingInterval: 100,
      // 100ms
      garbageCollectionInterval: 5e3
      // 5 seconds
    };
    this.initializePerformanceMonitoring();
    this.initializeMemoryManagement();
    this.initializeRenderingOptimization();
    this.initializeAssetManagement();
    this.initializeResourcePooling();
    this.setupEventHandlers();
    this.logger.info("PerformanceOptimizationSystem initialized");
  }
  /**
   * Initialize the system
   */
  async initialize() {
    this.logger.info("Initializing PerformanceOptimizationSystem...");
    this.startPerformanceMonitoring();
    this.initializeResourcePools();
    this.setupAssetCache();
    this.startOptimizationProcesses();
    this.logger.info("PerformanceOptimizationSystem initialized successfully");
  }
  /**
   * Cleanup the system
   */
  cleanup() {
    this.logger.info("Cleaning up PerformanceOptimizationSystem...");
    this.stopPerformanceMonitoring();
    this.stopOptimizationProcesses();
    this.clearResourcePools();
    this.clearAssetCache();
    this.performanceState.metrics.clear();
    this.performanceState.thresholds.clear();
    this.performanceState.optimizations.clear();
    this.performanceState.resourcePools.clear();
    this.performanceState.assetCache.clear();
    this.performanceState.renderQueue = [];
    this.performanceState.updateQueue = [];
    this.removeEventHandlers();
    this.logger.info("PerformanceOptimizationSystem cleaned up");
  }
  /**
   * Update the system
   */
  update(deltaTime, gameState) {
    this.updatePerformanceMetrics(deltaTime);
    this.checkPerformanceThresholds();
    this.applyOptimizations(deltaTime);
    this.updateResourcePools(deltaTime);
    this.updateAssetCache(deltaTime);
  }
  /**
   * Initialize performance monitoring
   */
  initializePerformanceMonitoring() {
    this.performanceMonitor = {
      frameCount: 0,
      lastFrameTime: 0,
      frameTimes: [],
      maxFrameTimeHistory: 60,
      memoryInfo: null,
      performanceObserver: null,
      metrics: {
        frameRate: 0,
        frameTime: 0,
        memoryUsage: 0,
        cpuUsage: 0,
        renderTime: 0,
        updateTime: 0
      }
    };
  }
  /**
   * Initialize memory management
   */
  initializeMemoryManagement() {
    this.memoryManager = {
      allocatedObjects: /* @__PURE__ */ new Map(),
      objectPools: /* @__PURE__ */ new Map(),
      garbageCollectionThreshold: 1e3,
      lastGarbageCollection: 0,
      memoryLeaks: /* @__PURE__ */ new Map(),
      memoryStats: {
        totalAllocated: 0,
        totalFreed: 0,
        currentUsage: 0,
        peakUsage: 0
      }
    };
  }
  /**
   * Initialize rendering optimization
   */
  initializeRenderingOptimization() {
    this.renderingOptimizer = {
      cullingEnabled: true,
      frustumCulling: true,
      occlusionCulling: false,
      levelOfDetail: true,
      instancing: true,
      batching: true,
      textureAtlas: true,
      shaderOptimization: true,
      renderQueue: [],
      visibleObjects: [],
      culledObjects: []
    };
  }
  /**
   * Initialize asset management
   */
  initializeAssetManagement() {
    this.assetManager = {
      loadedAssets: /* @__PURE__ */ new Map(),
      loadingQueue: [],
      cache: /* @__PURE__ */ new Map(),
      maxCacheSize: 100,
      compressionEnabled: true,
      lazyLoading: true,
      preloading: true,
      assetStats: {
        totalLoaded: 0,
        totalSize: 0,
        cacheHits: 0,
        cacheMisses: 0
      }
    };
  }
  /**
   * Initialize resource pooling
   */
  initializeResourcePooling() {
    this.resourcePooler = {
      pools: /* @__PURE__ */ new Map(),
      maxPoolSize: 50,
      poolStats: {
        totalPools: 0,
        totalObjects: 0,
        activeObjects: 0,
        pooledObjects: 0
      }
    };
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("performance:metric", this.handlePerformanceMetric.bind(this));
    this.eventBus.on("performance:threshold", this.handlePerformanceThreshold.bind(this));
    this.eventBus.on("performance:optimize", this.handlePerformanceOptimize.bind(this));
    this.eventBus.on("memory:allocate", this.handleMemoryAllocate.bind(this));
    this.eventBus.on("memory:free", this.handleMemoryFree.bind(this));
    this.eventBus.on("memory:leak", this.handleMemoryLeak.bind(this));
    this.eventBus.on("render:object", this.handleRenderObject.bind(this));
    this.eventBus.on("render:batch", this.handleRenderBatch.bind(this));
    this.eventBus.on("render:cull", this.handleRenderCull.bind(this));
    this.eventBus.on("asset:load", this.handleAssetLoad.bind(this));
    this.eventBus.on("asset:unload", this.handleAssetUnload.bind(this));
    this.eventBus.on("asset:cache", this.handleAssetCache.bind(this));
    this.eventBus.on("resource:create", this.handleResourceCreate.bind(this));
    this.eventBus.on("resource:destroy", this.handleResourceDestroy.bind(this));
    this.eventBus.on("resource:pool", this.handleResourcePool.bind(this));
  }
  /**
   * Remove event handlers
   */
  removeEventHandlers() {
    this.eventBus.removeListener("performance:metric", this.handlePerformanceMetric.bind(this));
    this.eventBus.removeListener("performance:threshold", this.handlePerformanceThreshold.bind(this));
    this.eventBus.removeListener("performance:optimize", this.handlePerformanceOptimize.bind(this));
    this.eventBus.removeListener("memory:allocate", this.handleMemoryAllocate.bind(this));
    this.eventBus.removeListener("memory:free", this.handleMemoryFree.bind(this));
    this.eventBus.removeListener("memory:leak", this.handleMemoryLeak.bind(this));
    this.eventBus.removeListener("render:object", this.handleRenderObject.bind(this));
    this.eventBus.removeListener("render:batch", this.handleRenderBatch.bind(this));
    this.eventBus.removeListener("render:cull", this.handleRenderCull.bind(this));
    this.eventBus.removeListener("asset:load", this.handleAssetLoad.bind(this));
    this.eventBus.removeListener("asset:unload", this.handleAssetUnload.bind(this));
    this.eventBus.removeListener("asset:cache", this.handleAssetCache.bind(this));
    this.eventBus.removeListener("resource:create", this.handleResourceCreate.bind(this));
    this.eventBus.removeListener("resource:destroy", this.handleResourceDestroy.bind(this));
    this.eventBus.removeListener("resource:pool", this.handleResourcePool.bind(this));
  }
  /**
   * Start performance monitoring
   */
  startPerformanceMonitoring() {
    if (!this.performanceConfig.monitoringEnabled) {
      return;
    }
    this.startFrameRateMonitoring();
    this.startMemoryMonitoring();
    this.startCPUMonitoring();
    if (this.performanceConfig.profilingEnabled) {
      this.startProfiling();
    }
  }
  /**
   * Stop performance monitoring
   */
  stopPerformanceMonitoring() {
    if (this.frameRateTimer) {
      clearInterval(this.frameRateTimer);
    }
    if (this.memoryTimer) {
      clearInterval(this.memoryTimer);
    }
    if (this.cpuTimer) {
      clearInterval(this.cpuTimer);
    }
    if (this.profilingTimer) {
      clearInterval(this.profilingTimer);
    }
  }
  /**
   * Start frame rate monitoring
   */
  startFrameRateMonitoring() {
    this.frameRateTimer = setInterval(() => {
      this.updateFrameRate();
    }, this.performanceConfig.monitoringInterval);
  }
  /**
   * Start memory monitoring
   */
  startMemoryMonitoring() {
    this.memoryTimer = setInterval(() => {
      this.updateMemoryUsage();
    }, this.performanceConfig.monitoringInterval);
  }
  /**
   * Start CPU monitoring
   */
  startCPUMonitoring() {
    this.cpuTimer = setInterval(() => {
      this.updateCPUUsage();
    }, this.performanceConfig.monitoringInterval);
  }
  /**
   * Start profiling
   */
  startProfiling() {
    this.profilingTimer = setInterval(() => {
      this.updateProfiling();
    }, this.performanceConfig.profilingInterval);
  }
  /**
   * Update frame rate
   */
  updateFrameRate() {
    const now = performance.now();
    const deltaTime = now - this.performanceMonitor.lastFrameTime;
    this.performanceMonitor.frameCount++;
    this.performanceMonitor.lastFrameTime = now;
    this.performanceState.frameRate = 1e3 / deltaTime;
    this.performanceState.frameTime = deltaTime;
    this.performanceMonitor.frameTimes.push(deltaTime);
    if (this.performanceMonitor.frameTimes.length > this.performanceMonitor.maxFrameTimeHistory) {
      this.performanceMonitor.frameTimes.shift();
    }
    this.performanceMonitor.metrics.frameRate = this.performanceState.frameRate;
    this.performanceMonitor.metrics.frameTime = this.performanceState.frameTime;
  }
  /**
   * Update memory usage
   */
  updateMemoryUsage() {
    if (performance.memory) {
      this.performanceState.memoryUsage = performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize;
      this.performanceMonitor.memoryInfo = {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit
      };
    }
    this.performanceMonitor.metrics.memoryUsage = this.performanceState.memoryUsage;
  }
  /**
   * Update CPU usage
   */
  updateCPUUsage() {
    const now = performance.now();
    const deltaTime = now - (this.lastCPUUpdate || now);
    this.performanceState.cpuUsage = Math.min(1, deltaTime / this.performanceConfig.maxFrameTime);
    this.lastCPUUpdate = now;
    this.performanceMonitor.metrics.cpuUsage = this.performanceState.cpuUsage;
  }
  /**
   * Update profiling
   */
  updateProfiling() {
    this.profileRendering();
    this.profileUpdates();
    this.profileMemory();
  }
  /**
   * Profile rendering
   */
  profileRendering() {
    const startTime = performance.now();
    this.processRenderQueue();
    const endTime = performance.now();
    this.performanceState.renderTime = endTime - startTime;
    this.performanceMonitor.metrics.renderTime = this.performanceState.renderTime;
  }
  /**
   * Profile updates
   */
  profileUpdates() {
    const startTime = performance.now();
    this.processUpdateQueue();
    const endTime = performance.now();
    this.performanceState.updateTime = endTime - startTime;
    this.performanceMonitor.metrics.updateTime = this.performanceState.updateTime;
  }
  /**
   * Profile memory
   */
  profileMemory() {
    this.checkMemoryLeaks();
    this.updateMemoryStatistics();
  }
  /**
   * Check performance thresholds
   */
  checkPerformanceThresholds() {
    const thresholds = this.performanceConfig;
    if (this.performanceState.frameRate < thresholds.targetFrameRate) {
      this.handlePerformanceThreshold("frameRate", this.performanceState.frameRate);
    }
    if (this.performanceState.frameTime > thresholds.maxFrameTime) {
      this.handlePerformanceThreshold("frameTime", this.performanceState.frameTime);
    }
    if (this.performanceState.memoryUsage > thresholds.memoryThreshold) {
      this.handlePerformanceThreshold("memory", this.performanceState.memoryUsage);
    }
    if (this.performanceState.cpuUsage > thresholds.cpuThreshold) {
      this.handlePerformanceThreshold("cpu", this.performanceState.cpuUsage);
    }
    if (this.performanceState.renderTime > thresholds.renderThreshold) {
      this.handlePerformanceThreshold("render", this.performanceState.renderTime);
    }
    if (this.performanceState.updateTime > thresholds.updateThreshold) {
      this.handlePerformanceThreshold("update", this.performanceState.updateTime);
    }
  }
  /**
   * Apply optimizations
   */
  applyOptimizations(deltaTime) {
    if (!this.performanceConfig.optimizationEnabled) {
      return;
    }
    this.applyFrameRateOptimizations();
    this.applyMemoryOptimizations();
    this.applyRenderingOptimizations();
    this.applyAssetOptimizations();
  }
  /**
   * Apply frame rate optimizations
   */
  applyFrameRateOptimizations() {
    if (this.performanceState.frameRate < this.performanceConfig.targetFrameRate) {
      this.reduceQuality();
      this.enableCulling();
      this.reduceEffects();
    }
  }
  /**
   * Apply memory optimizations
   */
  applyMemoryOptimizations() {
    if (this.performanceState.memoryUsage > this.performanceConfig.memoryThreshold) {
      this.triggerGarbageCollection();
      this.clearUnusedAssets();
      this.reduceObjectPools();
    }
  }
  /**
   * Apply rendering optimizations
   */
  applyRenderingOptimizations() {
    if (this.performanceState.renderTime > this.performanceConfig.renderThreshold) {
      this.enableBatching();
      this.enableInstancing();
      this.reduceDrawCalls();
    }
  }
  /**
   * Apply asset optimizations
   */
  applyAssetOptimizations() {
    this.implementLazyLoading();
    this.compressAssets();
    this.useTextureAtlases();
  }
  /**
   * Initialize resource pools
   */
  initializeResourcePools() {
    const poolTypes = [
      "gameObject",
      "particle",
      "sound",
      "texture",
      "mesh",
      "shader",
      "buffer",
      "texture"
    ];
    poolTypes.forEach((type) => {
      this.createResourcePool(type);
    });
  }
  /**
   * Create resource pool
   */
  createResourcePool(type) {
    const pool = {
      type,
      objects: [],
      maxSize: this.performanceConfig.resourcePoolSize,
      activeCount: 0,
      stats: {
        created: 0,
        destroyed: 0,
        pooled: 0,
        reused: 0
      }
    };
    this.performanceState.resourcePools.set(type, pool);
    this.resourcePooler.pools.set(type, pool);
    this.resourcePooler.poolStats.totalPools++;
  }
  /**
   * Get object from pool
   */
  getObjectFromPool(type) {
    const pool = this.performanceState.resourcePools.get(type);
    if (!pool) {
      return null;
    }
    if (pool.objects.length > 0) {
      const object = pool.objects.pop();
      pool.activeCount++;
      pool.stats.reused++;
      return object;
    } else {
      const object = this.createObject(type);
      pool.activeCount++;
      pool.stats.created++;
      return object;
    }
  }
  /**
   * Return object to pool
   */
  returnObjectToPool(type, object) {
    const pool = this.performanceState.resourcePools.get(type);
    if (!pool) {
      return;
    }
    if (pool.objects.length < pool.maxSize) {
      this.resetObject(object);
      pool.objects.push(object);
      pool.activeCount--;
      pool.stats.pooled++;
    } else {
      this.destroyObject(object);
      pool.activeCount--;
      pool.stats.destroyed++;
    }
  }
  /**
   * Create object
   */
  createObject(type) {
    return { type, id: Date.now(), active: true };
  }
  /**
   * Reset object
   */
  resetObject(object) {
    object.active = false;
    object.id = Date.now();
  }
  /**
   * Destroy object
   */
  destroyObject(object) {
    object.active = false;
  }
  /**
   * Set up asset cache
   */
  setupAssetCache() {
    this.assetCache = {
      maxSize: this.performanceConfig.assetCacheSize,
      assets: /* @__PURE__ */ new Map(),
      accessTimes: /* @__PURE__ */ new Map(),
      sizes: /* @__PURE__ */ new Map(),
      stats: {
        hits: 0,
        misses: 0,
        evictions: 0
      }
    };
  }
  /**
   * Load asset
   */
  async loadAsset(url, type) {
    if (this.assetCache.assets.has(url)) {
      this.assetCache.stats.hits++;
      this.assetCache.accessTimes.set(url, Date.now());
      return this.assetCache.assets.get(url);
    }
    this.assetCache.stats.misses++;
    const asset = await this.loadAssetFromURL(url, type);
    this.addAssetToCache(url, asset);
    return asset;
  }
  /**
   * Load asset from URL
   */
  async loadAssetFromURL(url, type) {
    const startTime = performance.now();
    try {
      let asset;
      switch (type) {
        case "image":
          asset = await this.loadImage(url);
          break;
        case "audio":
          asset = await this.loadAudio(url);
          break;
        case "json":
          asset = await this.loadJSON(url);
          break;
        case "text":
          asset = await this.loadText(url);
          break;
        default:
          throw new Error(`Unknown asset type: ${type}`);
      }
      const loadTime = performance.now() - startTime;
      this.performanceState.assetLoadTime = loadTime;
      return asset;
    } catch (error) {
      this.logger.error(`Failed to load asset: ${url}`, error);
      throw error;
    }
  }
  /**
   * Load image
   */
  async loadImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = url;
    });
  }
  /**
   * Load audio
   */
  async loadAudio(url) {
    return new Promise((resolve, reject) => {
      const audio = new Audio();
      audio.oncanplaythrough = () => resolve(audio);
      audio.onerror = reject;
      audio.src = url;
    });
  }
  /**
   * Load JSON
   */
  async loadJSON(url) {
    const response = await fetch(url);
    return await response.json();
  }
  /**
   * Load text
   */
  async loadText(url) {
    const response = await fetch(url);
    return await response.text();
  }
  /**
   * Add asset to cache
   */
  addAssetToCache(url, asset) {
    if (this.assetCache.assets.size >= this.assetCache.maxSize) {
      this.evictOldestAsset();
    }
    this.assetCache.assets.set(url, asset);
    this.assetCache.accessTimes.set(url, Date.now());
    this.assetCache.sizes.set(url, this.getAssetSize(asset));
  }
  /**
   * Evict oldest asset
   */
  evictOldestAsset() {
    let oldestUrl = null;
    let oldestTime = Infinity;
    for (const [url, time] of this.assetCache.accessTimes) {
      if (time < oldestTime) {
        oldestTime = time;
        oldestUrl = url;
      }
    }
    if (oldestUrl) {
      this.assetCache.assets.delete(oldestUrl);
      this.assetCache.accessTimes.delete(oldestUrl);
      this.assetCache.sizes.delete(oldestUrl);
      this.assetCache.stats.evictions++;
    }
  }
  /**
   * Get asset size
   */
  getAssetSize(asset) {
    if (asset instanceof Image) {
      return asset.width * asset.height * 4;
    } else if (asset instanceof Audio) {
      return asset.duration * 44100 * 2;
    } else if (typeof asset === "string") {
      return asset.length * 2;
    } else if (typeof asset === "object") {
      return JSON.stringify(asset).length * 2;
    }
    return 0;
  }
  /**
   * Start optimization processes
   */
  startOptimizationProcesses() {
    this.gcTimer = setInterval(() => {
      this.triggerGarbageCollection();
    }, this.performanceConfig.garbageCollectionInterval);
    this.assetCleanupTimer = setInterval(() => {
      this.cleanupUnusedAssets();
    }, this.performanceConfig.monitoringInterval * 2);
  }
  /**
   * Stop optimization processes
   */
  stopOptimizationProcesses() {
    if (this.gcTimer) {
      clearInterval(this.gcTimer);
    }
    if (this.assetCleanupTimer) {
      clearInterval(this.assetCleanupTimer);
    }
  }
  /**
   * Trigger garbage collection
   */
  triggerGarbageCollection() {
    if (typeof gc === "function") {
      gc();
    }
    this.logger.info("Garbage collection triggered");
  }
  /**
   * Cleanup unused assets
   */
  cleanupUnusedAssets() {
    const now = Date.now();
    const maxAge = 3e5;
    for (const [url, time] of this.assetCache.accessTimes) {
      if (now - time > maxAge) {
        this.assetCache.assets.delete(url);
        this.assetCache.accessTimes.delete(url);
        this.assetCache.sizes.delete(url);
      }
    }
  }
  /**
   * Update performance metrics
   */
  updatePerformanceMetrics(deltaTime) {
    this.performanceState.frameRate = 1e3 / deltaTime;
    this.performanceState.frameTime = deltaTime;
    this.updateMemoryUsage();
    this.updateCPUUsage();
  }
  /**
   * Update resource pools
   */
  updateResourcePools(deltaTime) {
    this.resourcePooler.poolStats.totalObjects = 0;
    this.resourcePooler.poolStats.activeObjects = 0;
    this.resourcePooler.poolStats.pooledObjects = 0;
    for (const pool of this.performanceState.resourcePools.values()) {
      this.resourcePooler.poolStats.totalObjects += pool.objects.length + pool.activeCount;
      this.resourcePooler.poolStats.activeObjects += pool.activeCount;
      this.resourcePooler.poolStats.pooledObjects += pool.objects.length;
    }
  }
  /**
   * Update asset cache
   */
  updateAssetCache(deltaTime) {
    this.assetManager.assetStats.totalLoaded = this.assetCache.assets.size;
    this.assetManager.assetStats.totalSize = Array.from(this.assetCache.sizes.values()).reduce((sum, size) => sum + size, 0);
  }
  /**
   * Process render queue
   */
  processRenderQueue() {
    this.performanceState.renderQueue.forEach((object) => {
      this.renderObject(object);
    });
  }
  /**
   * Process update queue
   */
  processUpdateQueue() {
    this.performanceState.updateQueue.forEach((object) => {
      this.updateObject(object);
    });
  }
  /**
   * Render object
   */
  renderObject(object) {
  }
  /**
   * Update object
   */
  updateObject(object) {
  }
  /**
   * Check memory leaks
   */
  checkMemoryLeaks() {
  }
  /**
   * Update memory statistics
   */
  updateMemoryStatistics() {
  }
  /**
   * Reduce quality
   */
  reduceQuality() {
    this.logger.info("Reducing quality for performance");
  }
  /**
   * Enable culling
   */
  enableCulling() {
    this.renderingOptimizer.cullingEnabled = true;
  }
  /**
   * Reduce effects
   */
  reduceEffects() {
    this.logger.info("Reducing effects for performance");
  }
  /**
   * Enable batching
   */
  enableBatching() {
    this.renderingOptimizer.batching = true;
  }
  /**
   * Enable instancing
   */
  enableInstancing() {
    this.renderingOptimizer.instancing = true;
  }
  /**
   * Reduce draw calls
   */
  reduceDrawCalls() {
    this.logger.info("Reducing draw calls for performance");
  }
  /**
   * Implement lazy loading
   */
  implementLazyLoading() {
    this.assetManager.lazyLoading = true;
  }
  /**
   * Compress assets
   */
  compressAssets() {
    this.assetManager.compressionEnabled = true;
  }
  /**
   * Use texture atlases
   */
  useTextureAtlases() {
    this.renderingOptimizer.textureAtlas = true;
  }
  /**
   * Clear unused assets
   */
  clearUnusedAssets() {
    this.cleanupUnusedAssets();
  }
  /**
   * Reduce object pools
   */
  reduceObjectPools() {
    for (const pool of this.performanceState.resourcePools.values()) {
      if (pool.objects.length > pool.maxSize / 2) {
        pool.objects = pool.objects.slice(0, pool.maxSize / 2);
      }
    }
  }
  /**
   * Handle performance metric
   */
  handlePerformanceMetric(data) {
    const { metric, value } = data;
    this.performanceState.metrics.set(metric, value);
  }
  /**
   * Handle performance threshold
   */
  handlePerformanceThreshold(threshold, value) {
    this.logger.warn(`Performance threshold exceeded: ${threshold} (${value})`);
    this.eventBus.emit("performance:thresholdExceeded", {
      threshold,
      value,
      timestamp: Date.now()
    });
  }
  /**
   * Handle performance optimize
   */
  handlePerformanceOptimize(data) {
    const { optimization, level } = data;
    this.performanceState.optimizations.set(optimization, level);
  }
  /**
   * Handle memory allocate
   */
  handleMemoryAllocate(data) {
    const { object, size } = data;
    this.memoryManager.allocatedObjects.set(object, size);
    this.memoryManager.memoryStats.totalAllocated += size;
    this.memoryManager.memoryStats.currentUsage += size;
  }
  /**
   * Handle memory free
   */
  handleMemoryFree(data) {
    const { object } = data;
    const size = this.memoryManager.allocatedObjects.get(object);
    if (size) {
      this.memoryManager.allocatedObjects.delete(object);
      this.memoryManager.memoryStats.totalFreed += size;
      this.memoryManager.memoryStats.currentUsage -= size;
    }
  }
  /**
   * Handle memory leak
   */
  handleMemoryLeak(data) {
    const { object, size } = data;
    this.memoryManager.memoryLeaks.set(object, size);
    this.logger.warn(`Memory leak detected: ${object} (${size} bytes)`);
  }
  /**
   * Handle render object
   */
  handleRenderObject(data) {
    const { object } = data;
    this.performanceState.renderQueue.push(object);
  }
  /**
   * Handle render batch
   */
  handleRenderBatch(data) {
    const { objects } = data;
    this.performanceState.renderQueue.push(...objects);
  }
  /**
   * Handle render cull
   */
  handleRenderCull(data) {
    const { objects } = data;
    this.renderingOptimizer.culledObjects.push(...objects);
  }
  /**
   * Handle asset load
   */
  handleAssetLoad(data) {
    const { url, asset } = data;
    this.assetManager.loadedAssets.set(url, asset);
    this.assetManager.assetStats.totalLoaded++;
  }
  /**
   * Handle asset unload
   */
  handleAssetUnload(data) {
    const { url } = data;
    this.assetManager.loadedAssets.delete(url);
    this.assetManager.assetStats.totalLoaded--;
  }
  /**
   * Handle asset cache
   */
  handleAssetCache(data) {
    const { url, asset } = data;
    this.addAssetToCache(url, asset);
  }
  /**
   * Handle resource create
   */
  handleResourceCreate(data) {
    const { type, object } = data;
    this.getObjectFromPool(type);
  }
  /**
   * Handle resource destroy
   */
  handleResourceDestroy(data) {
    const { type, object } = data;
    this.returnObjectToPool(type, object);
  }
  /**
   * Handle resource pool
   */
  handleResourcePool(data) {
    const { type, objects } = data;
    const pool = this.performanceState.resourcePools.get(type);
    if (pool) {
      pool.objects.push(...objects);
    }
  }
  /**
   * Clear resource pools
   */
  clearResourcePools() {
    for (const pool of this.performanceState.resourcePools.values()) {
      pool.objects = [];
      pool.activeCount = 0;
    }
  }
  /**
   * Clear asset cache
   */
  clearAssetCache() {
    this.assetCache.assets.clear();
    this.assetCache.accessTimes.clear();
    this.assetCache.sizes.clear();
  }
  /**
   * Get performance metrics
   */
  getPerformanceMetrics() {
    return {
      current: this.performanceState,
      monitor: this.performanceMonitor.metrics,
      thresholds: this.performanceConfig
    };
  }
  /**
   * Get memory statistics
   */
  getMemoryStatistics() {
    return {
      current: this.memoryManager.memoryStats,
      allocated: this.memoryManager.allocatedObjects.size,
      leaks: this.memoryManager.memoryLeaks.size
    };
  }
  /**
   * Get asset statistics
   */
  getAssetStatistics() {
    return {
      current: this.assetManager.assetStats,
      cache: this.assetCache.stats,
      loaded: this.assetManager.loadedAssets.size
    };
  }
  /**
   * Get resource pool statistics
   */
  getResourcePoolStatistics() {
    return {
      current: this.resourcePooler.poolStats,
      pools: Array.from(this.performanceState.resourcePools.values())
    };
  }
  /**
   * Set performance level
   */
  setPerformanceLevel(level) {
    this.performanceState.performanceLevel = level;
    const settings = this.performanceConfig.optimizationLevels[level];
    if (settings) {
      this.applyPerformanceSettings(settings);
    }
  }
  /**
   * Apply performance settings
   */
  applyPerformanceSettings(settings) {
    this.logger.info(`Applied performance settings: ${JSON.stringify(settings)}`);
  }
  /**
   * Enable optimization
   */
  enableOptimization() {
    this.performanceState.optimizationEnabled = true;
  }
  /**
   * Disable optimization
   */
  disableOptimization() {
    this.performanceState.optimizationEnabled = false;
  }
  /**
   * Enable monitoring
   */
  enableMonitoring() {
    this.performanceState.monitoringEnabled = true;
    this.startPerformanceMonitoring();
  }
  /**
   * Disable monitoring
   */
  disableMonitoring() {
    this.performanceState.monitoringEnabled = false;
    this.stopPerformanceMonitoring();
  }
  /**
   * Enable profiling
   */
  enableProfiling() {
    this.performanceState.profilingEnabled = true;
    this.startProfiling();
  }
  /**
   * Disable profiling
   */
  disableProfiling() {
    this.performanceState.profilingEnabled = false;
    this.stopProfiling();
  }
};

// src/ARPGIntegration.js
var ARPGIntegration = class {
  constructor(config = {}) {
    this.config = this.validateConfig({
      debug: false,
      enableARPG: true,
      enableCombat: true,
      enableProcedural: true,
      enableItemization: true,
      enableEndgame: true,
      enableTrading: true,
      enableErrorHandling: true,
      enableMobile: true,
      enablePerformance: true,
      ...config
    });
    this.eventBus = new EventBus();
    this.logger = new Logger(this.config.debug);
    this.systems = {};
    this.initializeSystems();
    this.gameState = {
      isRunning: false,
      isPaused: false,
      currentArea: null,
      player: null,
      enemies: [],
      items: [],
      activeTrades: [],
      performanceMetrics: {},
      mobileState: {},
      errorCount: 0
    };
    this.setupEventHandlers();
    this.logger.info("ARPGIntegration initialized");
  }
  /**
   * Initialize all ARPG systems
   */
  initializeSystems() {
    const dependencies = {
      eventBus: this.eventBus,
      logger: this.logger,
      config: this.config
    };
    if (this.config.enableErrorHandling) {
      this.systems.errorHandling = new ErrorHandlingSystem(dependencies);
    }
    if (this.config.enablePerformance) {
      this.systems.performance = new PerformanceOptimizationSystem(dependencies);
    }
    if (this.config.enableMobile) {
      this.systems.mobile = new MobileOptimizationSystem(dependencies);
    }
    if (this.config.enableARPG) {
      this.systems.arpgUI = new ARPGUISystem(dependencies);
    }
    if (this.config.enableCombat) {
      this.systems.combat = new CombatSystem(dependencies);
    }
    if (this.config.enableProcedural) {
      this.systems.procedural = new ProceduralAreaSystem(dependencies);
    }
    if (this.config.enableItemization) {
      this.systems.itemization = new ItemizationSystem(dependencies);
    }
    if (this.config.enableEndgame) {
      this.systems.endgame = new EndgameSystem(dependencies);
    }
    if (this.config.enableTrading) {
      this.systems.trading = new TradingSystem(dependencies);
    }
  }
  /**
   * Validate configuration
   */
  validateConfig(config) {
    const validatedConfig = { ...config };
    Object.keys(validatedConfig).forEach((key) => {
      if (typeof validatedConfig[key] === "boolean") {
        validatedConfig[key] = Boolean(validatedConfig[key]);
      }
    });
    return validatedConfig;
  }
  /**
   * Initialize the ARPG integration
   */
  async initialize() {
    this.logger.info("Initializing ARPG Integration...");
    try {
      const initOrder = [
        "errorHandling",
        "performance",
        "mobile",
        "arpgUI",
        "combat",
        "procedural",
        "itemization",
        "endgame",
        "trading"
      ];
      for (const systemName of initOrder) {
        if (this.systems[systemName]) {
          await this.systems[systemName].initialize();
          this.logger.info(`${systemName} system initialized`);
        }
      }
      this.setupCrossSystemCommunication();
      this.logger.info("ARPG Integration initialized successfully");
    } catch (error) {
      this.logger.error("Failed to initialize ARPG Integration:", error);
      throw error;
    }
  }
  /**
   * Set up cross-system communication
   */
  setupCrossSystemCommunication() {
    if (this.systems.combat && this.systems.arpgUI) {
      this.eventBus.on("combat:enemyDefeated", (data) => {
        this.systems.arpgUI.handleEnemyDefeated(data);
      });
      this.eventBus.on("combat:playerDamaged", (data) => {
        this.systems.arpgUI.handlePlayerDamaged(data);
      });
    }
    if (this.systems.itemization && this.systems.arpgUI) {
      this.eventBus.on("item:generated", (data) => {
        this.systems.arpgUI.handleItemGenerated(data);
      });
      this.eventBus.on("item:equipped", (data) => {
        this.systems.arpgUI.handleItemEquipped(data);
      });
    }
    if (this.systems.trading && this.systems.arpgUI) {
      this.eventBus.on("trade:initiated", (data) => {
        this.systems.arpgUI.handleTradeInitiated(data);
      });
      this.eventBus.on("trade:completed", (data) => {
        this.systems.arpgUI.handleTradeCompleted(data);
      });
    }
    if (this.systems.procedural && this.systems.combat) {
      this.eventBus.on("area:generated", (data) => {
        this.systems.combat.handleAreaGenerated(data);
      });
      this.eventBus.on("area:explored", (data) => {
        this.systems.combat.handleAreaExplored(data);
      });
    }
    if (this.systems.endgame && this.systems.combat) {
      this.eventBus.on("boss:spawned", (data) => {
        this.systems.combat.handleBossSpawned(data);
      });
      this.eventBus.on("boss:defeated", (data) => {
        this.systems.combat.handleBossDefeated(data);
      });
    }
    if (this.systems.performance) {
      this.eventBus.on("performance:thresholdExceeded", (data) => {
        this.handlePerformanceThresholdExceeded(data);
      });
    }
    if (this.systems.errorHandling) {
      this.eventBus.on("error:occurred", (data) => {
        this.handleSystemError(data);
      });
    }
  }
  /**
   * Set up event handlers
   */
  setupEventHandlers() {
    this.eventBus.on("game:start", this.startGame.bind(this));
    this.eventBus.on("game:pause", this.pauseGame.bind(this));
    this.eventBus.on("game:resume", this.resumeGame.bind(this));
    this.eventBus.on("game:stop", this.stopGame.bind(this));
    this.eventBus.on("player:created", this.handlePlayerCreated.bind(this));
    this.eventBus.on("player:levelUp", this.handlePlayerLevelUp.bind(this));
    this.eventBus.on("player:death", this.handlePlayerDeath.bind(this));
    this.eventBus.on("system:error", this.handleSystemError.bind(this));
    this.eventBus.on("system:performance", this.handleSystemPerformance.bind(this));
  }
  /**
   * Start the game
   */
  async startGame() {
    if (this.gameState.isRunning) {
      this.logger.warn("Game is already running");
      return;
    }
    try {
      this.logger.info("Starting ARPG game...");
      this.gameState.isRunning = true;
      this.gameState.isPaused = false;
      this.gameState.startTime = Date.now();
      for (const [name, system] of Object.entries(this.systems)) {
        if (system.start) {
          await system.start();
        }
      }
      this.startGameLoop();
      this.eventBus.emit("game:started", {
        timestamp: this.gameState.startTime,
        systems: Object.keys(this.systems)
      });
      this.logger.info("ARPG game started successfully");
    } catch (error) {
      this.logger.error("Failed to start ARPG game:", error);
      throw error;
    }
  }
  /**
   * Pause the game
   */
  pauseGame() {
    if (!this.gameState.isRunning || this.gameState.isPaused) {
      return;
    }
    this.gameState.isPaused = true;
    for (const [name, system] of Object.entries(this.systems)) {
      if (system.pause) {
        system.pause();
      }
    }
    this.eventBus.emit("game:paused", {
      timestamp: Date.now()
    });
    this.logger.info("ARPG game paused");
  }
  /**
   * Resume the game
   */
  resumeGame() {
    if (!this.gameState.isRunning || !this.gameState.isPaused) {
      return;
    }
    this.gameState.isPaused = false;
    for (const [name, system] of Object.entries(this.systems)) {
      if (system.resume) {
        system.resume();
      }
    }
    this.eventBus.emit("game:resumed", {
      timestamp: Date.now()
    });
    this.logger.info("ARPG game resumed");
  }
  /**
   * Stop the game
   */
  stopGame() {
    if (!this.gameState.isRunning) {
      return;
    }
    this.gameState.isRunning = false;
    this.gameState.isPaused = false;
    for (const [name, system] of Object.entries(this.systems)) {
      if (system.stop) {
        system.stop();
      }
    }
    this.stopGameLoop();
    this.eventBus.emit("game:stopped", {
      timestamp: Date.now()
    });
    this.logger.info("ARPG game stopped");
  }
  /**
   * Start game loop
   */
  startGameLoop() {
    this.gameLoopId = requestAnimationFrame(this.gameLoop.bind(this));
  }
  /**
   * Stop game loop
   */
  stopGameLoop() {
    if (this.gameLoopId) {
      cancelAnimationFrame(this.gameLoopId);
      this.gameLoopId = null;
    }
  }
  /**
   * Main game loop
   */
  gameLoop(currentTime) {
    if (!this.gameState.isRunning || this.gameState.isPaused) {
      return;
    }
    const deltaTime = currentTime - (this.lastUpdateTime || currentTime);
    this.lastUpdateTime = currentTime;
    try {
      for (const [name, system] of Object.entries(this.systems)) {
        if (system.update) {
          system.update(deltaTime, this.gameState);
        }
      }
      this.updateGameState(deltaTime);
      this.gameLoopId = requestAnimationFrame(this.gameLoop.bind(this));
    } catch (error) {
      this.logger.error("Error in game loop:", error);
      this.handleSystemError({ error, context: "gameLoop" });
    }
  }
  /**
   * Update game state
   */
  updateGameState(deltaTime) {
    if (this.systems.performance) {
      this.gameState.performanceMetrics = this.systems.performance.getPerformanceMetrics();
    }
    if (this.systems.mobile) {
      this.gameState.mobileState = this.systems.mobile.getMobileState();
    }
    if (this.systems.errorHandling) {
      const errorStats = this.systems.errorHandling.getErrorStatistics();
      this.gameState.errorCount = errorStats.totalErrors;
    }
  }
  /**
   * Handle player created
   */
  handlePlayerCreated(data) {
    this.gameState.player = data.player;
    this.logger.info(`Player created: ${data.player.name}`);
  }
  /**
   * Handle player level up
   */
  handlePlayerLevelUp(data) {
    this.logger.info(`Player leveled up to level ${data.level}`);
    if (this.systems.arpgUI) {
      this.systems.arpgUI.handlePlayerLevelUp(data);
    }
  }
  /**
   * Handle player death
   */
  handlePlayerDeath(data) {
    this.logger.info("Player died");
    for (const [name, system] of Object.entries(this.systems)) {
      if (system.handlePlayerDeath) {
        system.handlePlayerDeath(data);
      }
    }
  }
  /**
   * Handle system error
   */
  handleSystemError(data) {
    this.logger.error("System error occurred:", data.error);
    if (this.systems.errorHandling) {
      this.systems.errorHandling.handleError(data);
    }
  }
  /**
   * Handle system performance
   */
  handleSystemPerformance(data) {
    if (this.systems.performance) {
      this.systems.performance.handlePerformanceMetric(data);
    }
  }
  /**
   * Handle performance threshold exceeded
   */
  handlePerformanceThresholdExceeded(data) {
    this.logger.warn(`Performance threshold exceeded: ${data.threshold}`);
    if (this.systems.performance) {
      this.systems.performance.handlePerformanceThreshold(data);
    }
  }
  /**
   * Get system by name
   */
  getSystem(name) {
    return this.systems[name];
  }
  /**
   * Get game state
   */
  getGameState() {
    return { ...this.gameState };
  }
  /**
   * Get all systems
   */
  getAllSystems() {
    return { ...this.systems };
  }
  /**
   * Get system status
   */
  getSystemStatus() {
    const status = {};
    for (const [name, system] of Object.entries(this.systems)) {
      status[name] = {
        initialized: !!system,
        running: system && system.isRunning ? system.isRunning() : false,
        errorCount: system && system.getErrorCount ? system.getErrorCount() : 0,
        performance: system && system.getPerformanceMetrics ? system.getPerformanceMetrics() : null
      };
    }
    return status;
  }
  /**
   * Cleanup and destroy
   */
  destroy() {
    this.logger.info("Destroying ARPG Integration...");
    this.stopGame();
    for (const [name, system] of Object.entries(this.systems)) {
      if (system.cleanup) {
        system.cleanup();
      }
    }
    this.systems = {};
    this.gameState = null;
    this.eventBus.removeAllListeners();
    this.logger.info("ARPG Integration destroyed");
  }
};
var ARPGIntegration_default = ARPGIntegration;
export {
  ARPGIntegration,
  ARPGIntegration_default as default
};
//# sourceMappingURL=src_ARPGIntegration__js.js.map
